<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>基础原理 on ykikoqAq</title><link>https://ykiko.top/categories/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/</link><description>Recent content in 基础原理 on ykikoqAq</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 07 Jan 2022 00:22:00 +0800</lastBuildDate><atom:link href="https://ykiko.top/categories/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>编译原理笔记</title><link>https://ykiko.top/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</link><pubDate>Fri, 07 Jan 2022 00:22:00 +0800</pubDate><guid>https://ykiko.top/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</guid><description>&lt;h1 id="编译原理笔记">编译原理笔记&lt;/h1>
&lt;p>笔记待迁移，先占位。&lt;/p></description></item><item><title>ARM汇编基础(待补充)</title><link>https://ykiko.top/p/arm%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%BE%85%E8%A1%A5%E5%85%85/</link><pubDate>Sat, 10 Aug 2019 00:00:00 +0800</pubDate><guid>https://ykiko.top/p/arm%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%BE%85%E8%A1%A5%E5%85%85/</guid><description>&lt;h1 id="arm汇编基础待补充">ARM汇编基础(待补充)&lt;/h1>
&lt;h2 id="arm汇编基础简">ARM汇编基础(简)&lt;/h2>
&lt;p>经常忘记，做个笔记，好作复习。。&lt;/p>
&lt;p>内容主要来源于《Android软件安全与逆向分析》和《逆向工程权威指南》以及 &lt;a class="link" href="https://www.anquanke.com/post/id/86383" target="_blank" rel="noopener"
>ARM 汇编&lt;/a> 和&lt;a class="link" href="https://azeria-labs.com/writing-arm-assembly-part-1/" target="_blank" rel="noopener"
>Azeria-labs&lt;/a>&lt;/p>
&lt;h3 id="arm架构">ARM架构&lt;/h3>
&lt;p>ARM属于RISC CPU，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ARM模式 4个字节opcode 32位&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Thumb模式 2个字节opcode 16位&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Thumb-2模式 同上（只是有部分4个字节的opcode)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>64位ARM 4个字节opcode&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ARM机器码在版本3之前是小端。但是之后默认采用大端格式，但可以设置切换到小端。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810112415.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;h3 id="数据类型">数据类型&lt;/h3>
&lt;p>数据类型在汇编语言中的扩展后缀为**-h&lt;strong>或者&lt;/strong>-sh&lt;strong>对应着半字，&lt;/strong>-b&lt;strong>或者&lt;/strong>-sb**对应着字节，但是对于字并没有对应的扩展&lt;/p>
&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810113108.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">ldr = 加载字，宽度四字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ldrh = 加载无符号的半字，宽度两字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ldrsh = 加载有符号的半字，宽度两字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ldrb = 加载无符号的字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ldrsb = 加载有符号的字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">str = 存储字，宽度四字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">strh = 存储无符号的半字，宽度两字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">strsh = 存储有符号的半字，宽度两字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">strb = 存储无符号的字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">strsb = 存储有符号的字节
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="字节序">字节序&lt;/h3>
&lt;p>在内存中有两种字节排布顺序，大端序(BE)或者小端序(LE)。两者的主要不同是对象中的每个字节在内存中的存储顺序存在差异。一般X86中是小端序，最低的字节存储在最低的地址上。在大端机中最高的字节存储在最低的地址上。&lt;/p>
&lt;p>&lt;img src="https://p0.ssl.qhimg.com/t01b6d7f41b02b0a58d.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>数据访问时采取大端序还是小端序使用程序状态寄存器(CPSR)的第9比特位来决定的。&lt;/p>
&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810120701.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;h3 id="寄存器">寄存器&lt;/h3>
&lt;p>37个32位寄存器，其中31个为基础寄存器，6个为状态寄存器。&lt;/p>
&lt;p>用户模式下有&lt;/p>
&lt;ul>
&lt;li>
&lt;p>不分组寄存器（R0-R7） R7一般存放系统调用号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分组寄存器（R8-R14）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>程序计数器（R15）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>单前程序状态寄存器（CPSR）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>两种状态：&lt;/p>
&lt;table>
&lt;tr>
&lt;th>ARM状态（32位对齐）&lt;/th>
&lt;th>Thumb状态(16位对齐)&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>R0-R7&lt;/th>
&lt;th>R0-R7(相同)&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>CPSR&lt;/th>
&lt;th>CPSR（同）&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>R11&lt;/th>
&lt;th>FP（栈帧指针）&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>R12&lt;/th>
&lt;th>IP（内部程序调用）&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>R13&lt;/th>
&lt;th>SP（栈指针）&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>R14&lt;/th>
&lt;th>LR（链接寄存器）一般存放函数返回地址&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>R15&lt;/th>
&lt;th>PC（程序计数器）&lt;/th>
&lt;/tr>&lt;/table>
&lt;p>和x86对比：&lt;/p>
&lt;p>&lt;img src="https://p5.ssl.qhimg.com/t01a8e5d24fa91f9f0f.jpg"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>CSPR:&lt;/p>
&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810122226.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>32位的CPSR寄存器的比特位含义，左边是最大比特位，右边是最小比特位。每个单元代表一个比特。&lt;/p>
&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810122258.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;table>
&lt;tr>
&lt;th>条件码&lt;/th>
&lt;th>助记符后缀&lt;/th>
&lt;th>标志&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>0000&lt;/th>
&lt;th>EQ&lt;/th>
&lt;th>Z置位&lt;/th>
&lt;th>相等&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>0001&lt;/th>
&lt;th>NE&lt;/th>
&lt;th>Z清零&lt;/th>
&lt;th>不相等&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>0010&lt;/th>
&lt;th>CS&lt;/th>
&lt;th>C置位&lt;/th>
&lt;th>无符号数大于或等于&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>0011&lt;/th>
&lt;th>CC&lt;/th>
&lt;th>C清零&lt;/th>
&lt;th>无符号数小于&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>0100&lt;/th>
&lt;th>MI&lt;/th>
&lt;th>N置位&lt;/th>
&lt;th>负数&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>0101&lt;/th>
&lt;th>PL&lt;/th>
&lt;th>N清零&lt;/th>
&lt;th>正数或零&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>0110&lt;/th>
&lt;th>VS&lt;/th>
&lt;th>V置位&lt;/th>
&lt;th>溢出&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>0111&lt;/th>
&lt;th>VC&lt;/th>
&lt;th>V清零&lt;/th>
&lt;th>未溢出&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>1000&lt;/th>
&lt;th>HI&lt;/th>
&lt;th>C置位Z清零&lt;/th>
&lt;th>无符号数大于&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>1001&lt;/th>
&lt;th>LS&lt;/th>
&lt;th>C清零Z置位&lt;/th>
&lt;th>无符号数小于或等于&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>1010&lt;/th>
&lt;th>GE&lt;/th>
&lt;th>N等于V&lt;/th>
&lt;th>带符号数大于或等于&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>1011&lt;/th>
&lt;th>LT&lt;/th>
&lt;th>N不等于V&lt;/th>
&lt;th>带符号数小于&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>1100&lt;/th>
&lt;th>GT&lt;/th>
&lt;th>Z清零且（N等于V）&lt;/th>
&lt;th>带符号数大于&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>1101&lt;/th>
&lt;th>LE&lt;/th>
&lt;th>Z置位或（N不等于V）&lt;/th>
&lt;th>带符号数小于或等于&lt;/th>
&lt;/tr>&lt;tr>
&lt;th>1110&lt;/th>
&lt;th>AL&lt;/th>
&lt;th>忽略&lt;/th>
&lt;th>无条件执行&lt;/th>
&lt;/tr>&lt;/table>
&lt;h3 id="程序结构">程序结构&lt;/h3>
&lt;p>Android平台采用的是GUN ARM汇编格式，汇编器为GAS&lt;/p>
&lt;p>参数传递：R0-R3这4个寄存器用来传递函数调用的第1到4个参数，超出的参数通过堆栈来传递。R0还用来存放函数调用的返回值。&lt;/p>
&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810112712.gif"
loading="lazy"
alt="img"
>&lt;/p>
&lt;h3 id="汇编器指令">汇编器指令&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>.file&lt;/code>:源文件名&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>.align&lt;/code>:代码对齐方式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>.ascii&lt;/code>:声明字符串&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>.global&lt;/code>:声明全局符号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>.type&lt;/code>：指定符号的类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>.word&lt;/code>：存放地址值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>.size&lt;/code>：设置指定符号的大小&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>.ident&lt;/code>：编译器标识&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="寻址方式">寻址方式&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>立即寻址&lt;/p>
&lt;p>&lt;code>MOV R0, #1234&lt;/code> -&amp;gt;R0=1234&lt;/p>
&lt;/li>
&lt;li>
&lt;p>寄存器寻址&lt;/p>
&lt;p>&lt;code>MOV R1 = R2&lt;/code> -&amp;gt;R0=R1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>寄存器移位寻址&lt;/p>
&lt;ul>
&lt;li>
&lt;p>LSL ：逻辑左移，移位后寄存器空出的低位补0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LSR：逻辑右移，移位后寄存器空出的高位补0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ASR：算术右移，移位过程中符号位保持不变，若源操作数为正数，则移位后空出的高位补0，否则补1。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ROR：循环右移，移位后移出的低位填入移位空出的高位。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RRX：带扩展的循环右移，操作数右移一位，移出的空位用C标志的值填充。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>MOV R0, R1, LSL #2&lt;/code> -&amp;gt;R1左移两位（R1&amp;laquo;2）赋值给R0,相当于R0 = R1*4&lt;/p>
&lt;/li>
&lt;li>
&lt;p>寄存器间接寻址&lt;/p>
&lt;p>&lt;code>LDR RO, [R1]&lt;/code> -&amp;gt;将R1寄存器的数值作为地址，取出此地址中的值赋给R0寄存器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基址寻址&lt;/p>
&lt;p>多用于查表、数组访问操作。&lt;/p>
&lt;p>&lt;code>LDR R0, [R1,#-4]&lt;/code> -&amp;gt;将R1寄存器的数值减4作为地址，取出此地址的值赋给R0寄存器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多寄存器寻址&lt;/p>
&lt;p>一条指令最多完成16个通用寄存器值的传送。&lt;/p>
&lt;p>&lt;code>LDMIA R0,{R1,R2,R3,R4}&lt;/code> -&amp;gt;LDM为数据加载指令，指令的后缀IA表示每次执行完加载操作后R0寄存器的值自增1个字，ARM指令集中，子表示的是一个32位数值。这条指令作用为：R1 = [R0],R2 = [R0+#4],R3 = [R0+#8],R4 = [R0+#12]。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆栈寻址&lt;/p>
&lt;p>特定的指令来完成：&lt;code>LDMFA/STMFA&lt;/code>、&lt;code>LDMEA/STMEA&lt;/code>、&lt;code>LDMFD/STMFD&lt;/code>、&lt;code>LDMED/STMED&lt;/code>。&lt;/p>
&lt;p>LDM和STM为指令前缀，表示多寄存器寻址，即一次传送多个寄存器的值。后面的后缀为指令后缀。&lt;/p>
&lt;p>&lt;code>STMFD SP!, {R1-R7,LR}&lt;/code> -&amp;gt;将R1~R7,LR入栈，多用于保存子程序的现场。&lt;/p>
&lt;p>&lt;code>LDMFD SP!, {R1-R7,LR}&lt;/code> -&amp;gt;出栈，恢复现场。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>块拷贝寻址&lt;/p>
&lt;p>实现从连续地址数据从存储器的某一位置拷贝到另外一个位置，指令有：&lt;code>LDMIA/STMIA&lt;/code>、&lt;code>LDMDA/STMDA&lt;/code>、&lt;code>LDMIB/STMIB&lt;/code>、&lt;code>LDMDB/STMDB&lt;/code>。&lt;/p>
&lt;p>&lt;code>LDMIA R0! {R0-R3}&lt;/code> 从R0寄存器指向的存储单元中读取3个字到R1-R3寄存器&lt;/p>
&lt;p>&lt;code>STMIA R0! {R0-R3}&lt;/code> 存储从R1-R3寄存器的内容到R0寄存器指向的存储单元&lt;/p>
&lt;/li>
&lt;li>
&lt;p>相对寻址&lt;/p>
&lt;p>以程序计数器PC的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到操作数的有效地址。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">BL NEXT ····NEXT: ········
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="arm和thumb指令集">ARM和Thumb指令集&lt;/h3>
&lt;h3 id="基本指令简述">基本指令简述&lt;/h3>
&lt;p>&lt;code>MNEMONIC{S}{condition} {Rd}, Operand1, Operand2&lt;/code>&lt;/p>
&lt;p>&lt;code>助记符{是否使用CPSR}{是否条件执行以及条件} {目的寄存器}, 操作符1, 操作符2&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>MNEMONIC     - 指令的助记符如ADD&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>{S}           - 可选的扩展位，如果指令后加了S，则需要依据计算结果更新CPSR寄存器中的条件跳转相关 的FLAG
{condition}   - 如果机器码要被条件执行，那它需要满足的条件标示
{Rd}          - 存储结果的目的寄存器
Operand1     - 第一个操作数，寄存器或者是一个立即数
Operand2     - 第二个(可变的)操作数，可以是一个立即数或者寄存器或者有偏移量的寄存器
&lt;/code>&lt;/pre>
&lt;p>第二操作数还有如下操作：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">#123 - 立即数
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Rx - 寄存器比如R1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Rx, ASR n - 对寄存器中的值进行算术右移n位后的值
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Rx, LSL n - 对寄存器中的值进行逻辑左移n位后的值
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Rx, LSR n - 对寄存器中的值进行逻辑右移n位后的值
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Rx, ROR n - 对寄存器中的值进行循环右移n位后的值
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Rx, RRX - 对寄存器中的值进行带扩展的循环右移1位后的值
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">ADD R0, R1, R2 - 将第一操作数R1的内容与第二操作数R2的内容相加，将结果存储到R0中。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ADD R0, R1, #2 - 将第一操作数R1的内容与第二操作数一个立即数相加，将结果存到R0中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">MOVLE R0, #5 - 当满足条件LE(Less and Equal,小于等于0)将第二操作数立即数5移动到R0中,注意这条指令与MOVLE R0, R0, #5相同
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">MOV R0, R1, LSL #1 - 将第二操作数R1寄存器中的值逻辑左移1位后存入R0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810144732.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;h3 id="内存访问相关指令">内存访问相关指令&lt;/h3>
&lt;p>通常，LDR被用来从内存中加载数据到寄存器，STR被用作将寄存器的值存放到内存中。&lt;/p>
&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810145231.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">.data /* 数据段是在内存中动态创建的，所以它的在内存中的地址不可预测*/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var1: .word 3 /* 内存中的第一个变量 */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var2: .word 4 /* 内存中的第二个变量 */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.text /* 代码段开始 */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.global _start
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">_start:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> str r2, [r1] @ 将R2中的值0x3存放到R1做指向的地址
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> bkpt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">adr_var1: .word var1 /* var1的地址助记符 */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">adr_var2: .word var2 /* var2的地址助记符 */
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810145711.gif"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810154906.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>第一种偏移形式：立即数作偏移&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">STR Ra, [Rb, imm]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LDR Ra, [Rc, imm]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">.data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var1: .word 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var2: .word 4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.text
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.global _start
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">_start:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> str r2, [r1, #2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加2所指向地址处。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> str r2, [r1, #4]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加4所指向地址处，之后R1寄存器中存储的值加4,也就是R1=R1+4。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r3, [r1], #4 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中存储的值加4,也就是R1=R1+4。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> bkpt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">adr_var1: .word var1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">adr_var2: .word var2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810160844.gif"
loading="lazy"
alt="img"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>第二种偏移形式：寄存器作偏移&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">STR Ra, [Rb, Rc]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LDR Ra, [Rb, Rc]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">.data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var1: .word 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var2: .word 4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.text
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.global _start
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">_start:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> str r2, [r1, r2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处。R1寄存器不会被修改。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> str r2, [r1, r2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处，之后R1寄存器中的值被更新,也就是R1=R1+R2。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r3, [r1], r2 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1=R1+R2。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> bx lr
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">adr_var1: .word var1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810162217.gif"
loading="lazy"
alt="img"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第三种偏移形式：寄存器缩放值作偏移&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">LDR Ra, [Rb, Rc, &amp;lt;shifter&amp;gt;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">STR Ra, [Rb, Rc, &amp;lt;shifter&amp;gt;]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">.data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var1: .word 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">var2: .word 4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.text
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.global _start
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">_start:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> str r2, [r1, r2, LSL#2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处。R1寄存器不会被修改。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> str r2, [r1, r2, LSL#2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处，之后R1寄存器中的值被更新,也就R1 = R1 + R2&amp;lt;&amp;lt;2。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r3, [r1], r2, LSL#2 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1 = R1 + R2&amp;lt;&amp;lt;2。
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> bkpt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">adr_var1: .word var1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">adr_var2: .word var2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="http://my-md-1253484710.coscd.myqcloud.com/20180810162414.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>如何区分取址模式：&lt;/p>
&lt;p>如果有一个叹号!，那就是索引前置取址模式，即使用计算后的地址，之后更新基址寄存器。&lt;/p>
&lt;p>如果在外有一个寄存器，那就是索引后置取址模式，即使用原有基址寄存器重的地址，之后再更新基址寄存器&lt;/p>
&lt;p>除此之外，就都是偏移取址模式了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>关于PC相对取址的LDR指令&lt;/strong>&lt;/p>
&lt;p>有时候LDR并不仅仅被用来从内存中加载数据。还有如下这操作:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">.section .text
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.global _start
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">_start:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r0, =jump /* 加载jump标签所在的内存位置到R0 */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r1, =0x68DB00AD /* 加载立即数0x68DB00AD到R1 */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">jump:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r2, =511 /* 加载立即数511到R2 */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> bkpt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这些指令学术上被称作伪指令。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>在ARM中使用立即数的规律&lt;/strong>&lt;/p>
&lt;p>在ARM中不能像X86那样直接将立即数加载到寄存器中。因为你使用的立即数是受限的。&lt;/p>
&lt;p>立即数的值：v = n ror 2*r 有效的立即数都可以通过循环右移来得到&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">#256 // 1 循环右移 24位 --&amp;gt; 256
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#384 // 6 循环右移 26位 --&amp;gt; 384
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#484 // 121 循环右移 30位 --&amp;gt; 484
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#16384 // 1 循环右移 18位 --&amp;gt; 16384
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#2030043136 // 121 循环右移 8位 --&amp;gt; 2030043136
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#0x06000000 // 6 循环右移 8位 --&amp;gt; 100663296 (十六进制值0x06000000)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Invalid values:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#370 // 185 循环右移 31位 --&amp;gt; 31不在范围内 (0 – 30)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#511 // 1 1111 1111 --&amp;gt; 比特模型不符合
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#0x06010000 // 1 1000 0001.. --&amp;gt; 比特模型不符合
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样并不能一次性加载所有的32位值。不过我们可以通过以下的两个选项来解决这个问题：&lt;/p>
&lt;ul>
&lt;li>用小部分去组成更大的值。 MOV r0, #511 将511分成两部分：MOV r0, #256, and ADD r0, #255&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">.section .text
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.global _start
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">_start:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> mov r0, &lt;span class="c1">#256 /* 1 ror 24 = 256, so it&amp;#39;s valid */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> add r0, &lt;span class="c1">#255 /* 255 ror 0 = 255, valid. r0 = 256 + 255 = 511 */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ldr r1, &lt;span class="o">=&lt;/span>&lt;span class="m">511&lt;/span> /* load &lt;span class="m">511&lt;/span> from the literal pool using LDR */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> bkpt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>计算立即数的有效值脚本：https://raw.githubusercontent.com/azeria-labs/rotator/master/rotator.py&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">azeria@labs:~$ python rotator.py
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Enter the value you want to check: &lt;span class="m">511&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Sorry, &lt;span class="m">511&lt;/span> cannot be used as an immediate number and has to be split.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">azeria@labs:~$ python rotator.py
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Enter the value you want to check: &lt;span class="m">256&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">The number &lt;span class="m">256&lt;/span> can be used as a valid immediate number.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">1&lt;/span> ror &lt;span class="m">24&lt;/span> --&amp;gt; &lt;span class="m">256&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面的部分指令用到在详细查，记的话脑壳痛&lt;/p>
&lt;h3 id="跳转指令">跳转指令&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;code>B&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>BL&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>BX&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>BXL&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="存储器操作指令">存储器操作指令&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;code>LDM&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>STM&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>PUSH&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>POP&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>SWP&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="数据处理">数据处理&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;code>MOV&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>MVN&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ADD&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ADC&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>SUB&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>RSB&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>SBC&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>RSC&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>MUL&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>MLS&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>MLA&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>UMULL&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>UMLAL&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>SMUULL&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>SMLAL&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>SMLAD&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>SMLSD&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>SDIV&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>UDIV&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ASR&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>AND&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ORR&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>EOR&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>BIC&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LSL&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>LSR&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>RRX&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ROR&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>CMP&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>CMN&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TSL&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>TEQ&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="其他指令">其他指令&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;code>SWI&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>NOP&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>MRS&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>MSR&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="heading">&lt;/h3>
&lt;/li>
&lt;/ul></description></item></channel></rss>