[{"content":"IDA_动态调试.so_基本步骤 IDA 动态调试.so 基本步骤 待补图 0x00 IDA快捷键 Shirt+F12 字符串窗口\nF5大法好 反汇编\nCtrl+S 查看so对应段的信息（非调试），快速定位so文件的内存地址（Debug）\nG 快速跳转到对应地址。s\n调试-F7单步进入调试、F8单步、F9运行\n0x01 方法一 获取运行Android_server。\nandroid_server文件放在IDA安装目录下的注意版本的不同。\n之后只需 push android_server /data/local/tmp/。\n之后adb shell，su ，cd /data/local/tmp/。\n可能还得chmod 755 android_server 才有权限运行。\n建立通信、attach进程。\nadb forward tcp:23946 tcp:23946命令。\n在IDA的Debugger选项中attach进程。\n加载so、找函数下断点\n双开IDA ，Ctrl+S找到so文件的基地址，另外一个IDA找到函数的相对地址。相加得到绝对地址。\n0x02 方法二 无法加载so文件需要在加载之前断点。反调试之类\nDebug方式启动app。需要应用可调试开启\nadb shell am start -D -n 包名/.MainActivity\n方法一的1，2两步 勾选选项。\njdb attach程序\njdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700\n开始调试 同上\n","date":"2018-08-31T00:00:00+08:00","permalink":"https://ykiko.top/p/ida_%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so_%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/","title":"IDA_动态调试.so_基本步骤"},{"content":"Android应用安全防护和逆向分析-基础篇5-6 一、 基础篇⑤-⑥ 这两章主要描述AndroidManifest.xml和resourec.arsc这两个android文件。内容不是很多，下面是两章的笔记。\n第五章 AndroidManifest.xml格式解析 AndroidManifest.xml\nAndroidManifest.xml文件格式图\n头部信息 文件魔数：4bytes。\n文件大小：4bytes。\nChunk内容 头部相同（ChunkType(4bytes)、ChunkSize(4bytes)）。\nSting Chunk ：主要用于存放AndroidManifest.xml文件中所有的字符串信息。\nChunkType：类型，固定4bytes（0x001C001)。\nChunkSize：大小，4bytes。\nStringCount：字符串的个数 ，4bytes。\nStyleCount ：样式的个数，4bytes。\nUnknown ：位置区域。4bytes。\nStringPoolOffset ：字符串池的偏移值。4bytes。偏移值相对于StringChunk头部的位置。\nStylePoolOffset : 样式池的偏移值。4bytes。没有Style可忽略。\nStringOffsets ：每一个字符串的偏移值，大小为StringChunk*4。\nStyleOffsets：每个样式的偏移值，大小为StyleChunk*4。\n如何读取这个文件？\nResourceld Chunk ：主要用来存放AndroidManifest 中用到的系统属性值对应的资源ID\nChunkType：类型，固定4bytes（0x00080108）。\nChunkSize：大小，4bytes。\nResourceIds : 内容，大小为Resourceld Chunk大小除以4减去头部的8字节。\n解析？\nStart Namespace Chunk：主要包含了AndroidMaifest文件中的命名空间的内容，android中的xml都是采用Schema格式（两种格式DTD和Schema）的，所有肯定有Prefix和URI。\nChunk Type：类型，固定4bytes。（0x00100100)。\nChunk Size：大小，4bytes。\nLine Number ：AndroidMaifest文件中行号，4bytes。\nUnknown：未知区域,4bytes。\nPrefix：命名空间的前缀（在字符串中的索引值），eg:android。\nUri：命名空间的URI（在字符串中的索引值），eg:http://schemas.android.com/apk/res/android\nStart Tag Chunk：AndroidMaifest.xml的标签信息，最核心的内容，也是最复杂的内容。\nChunk Type：类型，固定4bytes。（0x00100102)。\nChunk Size：大小，4bytes。\nLine Number ：对应AndroidMaifest中的行号，4bytes。\nUnknown：未知区域,4bytes。\nNamespace Uri ：命名空间的Uri，4bytes。\nName：标签名称（在字符串中的索引值），4bytes。\nFlags：标签的类型，4bytes。eg：是开始标签还是结束标签？\nAttributes Counk：便签中包含的属性的个数，4bytes。\nClass Attribute：标签包含的类属性，4bytes。\nAttributes ：属性内容，每个属性算是一个Entry，Entry是一个大小5的字节数组[Namespace,URI,Name,ValueString,Data]，大小为”属性个数* 5 *4\u0026quot;个字节。\nAXMLPrinter工具 aapt 工具 第六章 resourec.arsc文件格式解析 资源文件id格式 resourec.arsc文件格式\n数据结构 上图\n头部信息\nresourec.arsc文件格式由一系列chunk组成，每一个chunk均包含一个ResChunk_header\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ResChunkHeader{ public short type; //当前chunk的类型 public short headerSize; //当前chunk的头部大小 public int size; //当前chunk的大小 public int getHeaderSize(){ return 2+2+4 } @Override public String toString(){ return \u0026#34;type:\u0026#34;+Utils.bytesToHexString( Utils.int2Byte(type))+\u0026#34;,headerSize:\u0026#34;+headerSize+\u0026#34;,size:\u0026#34;+size; } } 资源索引表的头部信息\nresourec.arsc的第一个结构，结构描述了Resource.arsc文件的大小和资源包数量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ResTableHeader { public ResChunkHeader header; //就是标准的Chunk头部信息格式 public int packageCount; //被编译的资源包的个数 public ResTableHeader(){ header = new ResChunkHeader(); } public int getHeaderSize(){ return header.getHeaderSize() + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34; + \u0026#34;packageCount:\u0026#34;+packageCount; } } 资源项的值字符串资源池接着头部的的是两个偏移数组，分别是字符串偏移数组和字符串样式偏移数组。这两个偏移数组的大小分别等于stringCount和styleCount的值，而每一个元素的类型都是无符号整型。整个字符中资源池结构如下。\n包含了所有在资源包里面定义的资源项的值字符串，结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class ResStringPoolHeader { public ResChunkHeader header; //标准的Chunk头部信息结构 public int stringCount; //字符串的个数 public int styleCount; //字符串样式的个数 public final static int SORTED_FLAG = 1; public final static int UTF8_FLAG = (1\u0026lt;\u0026lt;8); public int flags; //字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值 public int stringsStart; //字符串内容块相对于其头部的距离 public int stylesStart; //字符串样式块相对于其头部的距离 public ResStringPoolHeader(){ header = new ResChunkHeader(); } public int getHeaderSize(){ return header.getHeaderSize() + 4 + 4 + 4 + 4 + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34; + \u0026#34;stringCount:\u0026#34;+stringCount+\u0026#34;,styleCount:\u0026#34;+styleCount+\u0026#34;,flags:\u0026#34;+flags+\u0026#34;,stringStart:\u0026#34;+stringsStart+\u0026#34;,stylesStart:\u0026#34;+stylesStart; } } 字符串资源池中的字符串前两个字节为字符串长度,长度计算方法如下：\nlen = (((hbyte \u0026amp; 0x7F) \u0026lt;\u0026lt; 8)) | lbyte;\n如果字符串编码格式为UTF-8则字符串以0X00作为结束符,UTF-16则以0X0000作为结束符。\nPackage数据块\n这个数据块记录编译包的元数据，头部信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTablePackage { public ResChunkHeader header; //Chunk的头部信息数据结构 public int id; //包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01； public char[] name = new char[128]; //包名 public int typeStrings; //类型字符串资源池相对头部的偏移 public int lastPublicType; //最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途 public int keyStrings; //资源项名称字符串相对头部的偏移 public int lastPublicKey; // 最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途 public ResTablePackage(){ header = new ResChunkHeader(); } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34;+\u0026#34;,id=\u0026#34;+id+\u0026#34;,name:\u0026#34;+name.toString()+\u0026#34;,typeStrings:\u0026#34;+typeStrings+\u0026#34;,lastPublicType:\u0026#34;+lastPublicType+\u0026#34;,keyStrings:\u0026#34;+keyStrings+\u0026#34;,lastPublicKey:\u0026#34;+lastPublicKey; } } 类型规范数据块\n用来描述资源项的配置差异性。每一种类型都对应有一个类型规范数据块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTableTypeSpec { public final static int SPEC_PUBLIC = 0x40000000; public ResChunkHeader header; //Chunk的头部信息结构 public byte id; //标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。 public byte res0; //保留,始终为0 public short res1; //保留,始终为0 public int entryCount; //等于本类型的资源项个数,指名称相同的资源项的个数。 public ResTableTypeSpec(){ header = new ResChunkHeader(); } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;,id:\u0026#34;+id+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,res1:\u0026#34;+res1+\u0026#34;,entryCount:\u0026#34;+entryCount; } } 资源类型项数据块\n描述资源项的具体信息，名称、值、配置等信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class ResTableType { public ResChunkHeader header; //Chunk的头部信息结构 public final static int NO_ENTRY = 0xFFFFFFFF; public byte id; //标识资源的Type ID public byte res0; //保留,始终为0 public short res1; //保留,始终为0 public int entryCount; //等于本类型的资源项个数,指名称相同的资源项的个数。 public int entriesStart; //等于资源项数据块相对头部的偏移值。 public ResTableConfig resConfig; //指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等 public ResTableType(){ header = new ResChunkHeader(); resConfig = new ResTableConfig(); } public int getSize(){ return header.getHeaderSize() + 1 + 1 + 2 + 4 + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;,id:\u0026#34;+id+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,res1:\u0026#34;+res1+\u0026#34;,entryCount:\u0026#34;+entryCount+\u0026#34;,entriesStart:\u0026#34;+entriesStart; } } ResTable_type后接着是一个大小为entryCount的uint32_t数组，每一个数组元素都用来描述一个资源项数据块的偏移位置。 紧跟在这个偏移数组后面的是一个大小为entryCount的ResTable_entry数组,每一个数组元素都用来描述一个资源项的具体信息。ResTable_entry的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class ResTableEntry { public final static int FLAG_COMPLEX = 0x0001; public final static int FLAG_PUBLIC = 0x0002; public short size; public short flags; public ResStringPoolRef key; public ResTableEntry(){ key = new ResStringPoolRef(); } public int getSize(){ return 2+2+key.getSize(); } @Override public String toString(){ return \u0026#34;size:\u0026#34;+size+\u0026#34;,flags:\u0026#34;+flags+\u0026#34;,key:\u0026#34;+key.toString()+\u0026#34;,str:\u0026#34;+ParseResourceUtils.getKeyString(key.index); } } ResTable_entry根据flags的不同,后面跟随的数据也不相同,如果flags此位为1,则ResTable_entry是ResTable_map_entry,ResTable_map_entry继承自ResTable_entry,其结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTableMapEntry extends ResTableEntry{ public ResTableRef parent; public int count; public ResTableMapEntry(){ parent = new ResTableRef(); } @Override public int getSize(){ return super.getSize() + parent.getSize() + 4; } @Override public String toString(){ return super.toString() + \u0026#34;,parent:\u0026#34;+parent.toString()+\u0026#34;,count:\u0026#34;+count; } } ResTable_map_entry其后跟随则count个ResTable_map类型的数组,ResTable_map的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.wjdiankong.parseresource.type; /** struct ResTable_map { //bag资源项ID ResTable_ref name; //bag资源项值 Res_value value; }; * @author i * */ public class ResTableMap { public ResTableRef name; public ResValue value; public ResTableMap(){ name = new ResTableRef(); value = new ResValue(); } public int getSize(){ return name.getSize() + value.getSize(); } @Override public String toString(){ return name.toString()+\u0026#34;,value:\u0026#34;+value.toString(); } } 如果flags此位为0,则ResTable_entry其后跟随的是一个Res_value,描述一个普通资源的值,Res_value结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 public class ResValue { //dataType字段使用的常量 public final static int TYPE_NULL = 0x00; public final static int TYPE_REFERENCE = 0x01; public final static int TYPE_ATTRIBUTE = 0x02; public final static int TYPE_STRING = 0x03; public final static int TYPE_FLOAT = 0x04; public final static int TYPE_DIMENSION = 0x05; public final static int TYPE_FRACTION = 0x06; public final static int TYPE_FIRST_INT = 0x10; public final static int TYPE_INT_DEC = 0x10; public final static int TYPE_INT_HEX = 0x11; public final static int TYPE_INT_BOOLEAN = 0x12; public final static int TYPE_FIRST_COLOR_INT = 0x1c; public final static int TYPE_INT_COLOR_ARGB8 = 0x1c; public final static int TYPE_INT_COLOR_RGB8 = 0x1d; public final static int TYPE_INT_COLOR_ARGB4 = 0x1e; public final static int TYPE_INT_COLOR_RGB4 = 0x1f; public final static int TYPE_LAST_COLOR_INT = 0x1f; public final static int TYPE_LAST_INT = 0x1f; public static final int COMPLEX_UNIT_PX\t=0, COMPLEX_UNIT_DIP\t=1, COMPLEX_UNIT_SP\t=2, COMPLEX_UNIT_PT\t=3, COMPLEX_UNIT_IN\t=4, COMPLEX_UNIT_MM\t=5, COMPLEX_UNIT_SHIFT\t=0, COMPLEX_UNIT_MASK\t=15, COMPLEX_UNIT_FRACTION\t=0, COMPLEX_UNIT_FRACTION_PARENT=1, COMPLEX_RADIX_23p0\t=0, COMPLEX_RADIX_16p7\t=1, COMPLEX_RADIX_8p15\t=2, COMPLEX_RADIX_0p23\t=3, COMPLEX_RADIX_SHIFT\t=4, COMPLEX_RADIX_MASK\t=3, COMPLEX_MANTISSA_SHIFT\t=8, COMPLEX_MANTISSA_MASK\t=0xFFFFFF; public short size; //ResValue的头部大小 public byte res0; //保留，始终为0 public byte dataType; //数据的类型,可以从上面的枚举类型中获取 public int data; //数据对应的索引 public int getSize(){ return 2 + 1 + 1 + 4; } public String getTypeStr(){ switch(dataType){ case TYPE_NULL: return \u0026#34;TYPE_NULL\u0026#34;; case TYPE_REFERENCE: return \u0026#34;TYPE_REFERENCE\u0026#34;; case TYPE_ATTRIBUTE: return \u0026#34;TYPE_ATTRIBUTE\u0026#34;; case TYPE_STRING: return \u0026#34;TYPE_STRING\u0026#34;; case TYPE_FLOAT: return \u0026#34;TYPE_FLOAT\u0026#34;; case TYPE_DIMENSION: return \u0026#34;TYPE_DIMENSION\u0026#34;; case TYPE_FRACTION: return \u0026#34;TYPE_FRACTION\u0026#34;; case TYPE_FIRST_INT: return \u0026#34;TYPE_FIRST_INT\u0026#34;; case TYPE_INT_HEX: return \u0026#34;TYPE_INT_HEX\u0026#34;; case TYPE_INT_BOOLEAN: return \u0026#34;TYPE_INT_BOOLEAN\u0026#34;; case TYPE_FIRST_COLOR_INT: return \u0026#34;TYPE_FIRST_COLOR_INT\u0026#34;; case TYPE_INT_COLOR_RGB8: return \u0026#34;TYPE_INT_COLOR_RGB8\u0026#34;; case TYPE_INT_COLOR_ARGB4: return \u0026#34;TYPE_INT_COLOR_ARGB4\u0026#34;; case TYPE_INT_COLOR_RGB4: return \u0026#34;TYPE_INT_COLOR_RGB4\u0026#34;; } return \u0026#34;\u0026#34;; } /*public String getDataStr(){ if(dataType == TYPE_STRING){ return ParseResourceUtils.getResString(data); }else if(dataType == TYPE_FIRST_COLOR_INT){ return Utils.bytesToHexString(Utils.int2Byte(data)); }else if(dataType == TYPE_INT_BOOLEAN){ return data==0 ? \u0026#34;false\u0026#34; : \u0026#34;true\u0026#34;; } return data+\u0026#34;\u0026#34;; }*/ public String getDataStr() { if (dataType == TYPE_STRING) { return ParseResourceUtils.getResString(data); } if (dataType == TYPE_ATTRIBUTE) { return String.format(\u0026#34;?%s%08X\u0026#34;,getPackage(data),data); } if (dataType == TYPE_REFERENCE) { return String.format(\u0026#34;@%s%08X\u0026#34;,getPackage(data),data); } if (dataType == TYPE_FLOAT) { return String.valueOf(Float.intBitsToFloat(data)); } if (dataType == TYPE_INT_HEX) { return String.format(\u0026#34;0x%08X\u0026#34;,data); } if (dataType == TYPE_INT_BOOLEAN) { return data!=0?\u0026#34;true\u0026#34;:\u0026#34;false\u0026#34;; } if (dataType == TYPE_DIMENSION) { return Float.toString(complexToFloat(data))+ DIMENSION_UNITS[data \u0026amp; COMPLEX_UNIT_MASK]; } if (dataType == TYPE_FRACTION) { return Float.toString(complexToFloat(data))+ FRACTION_UNITS[data \u0026amp; COMPLEX_UNIT_MASK]; } if (dataType \u0026gt;= TYPE_FIRST_COLOR_INT \u0026amp;\u0026amp; dataType \u0026lt;= TYPE_LAST_COLOR_INT) { return String.format(\u0026#34;#%08X\u0026#34;,data); } if (dataType \u0026gt;= TYPE_FIRST_INT \u0026amp;\u0026amp; dataType \u0026lt;= TYPE_LAST_INT) { return String.valueOf(data); } return String.format(\u0026#34;\u0026lt;0x%X, type 0x%02X\u0026gt;\u0026#34;,data, dataType); } private static String getPackage(int id) { if (id\u0026gt;\u0026gt;\u0026gt;24==1) { return \u0026#34;android:\u0026#34;; } return \u0026#34;\u0026#34;; } public static float complexToFloat(int complex) { return (float)(complex \u0026amp; 0xFFFFFF00)*RADIX_MULTS[(complex\u0026gt;\u0026gt;4) \u0026amp; 3]; } private static final float RADIX_MULTS[]={ 0.00390625F,3.051758E-005F,1.192093E-007F,4.656613E-010F }; private static final String DIMENSION_UNITS[]={ \u0026#34;px\u0026#34;,\u0026#34;dip\u0026#34;,\u0026#34;sp\u0026#34;,\u0026#34;pt\u0026#34;,\u0026#34;in\u0026#34;,\u0026#34;mm\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; }; private static final String FRACTION_UNITS[]={ \u0026#34;%\u0026#34;,\u0026#34;%p\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; }; @Override public String toString(){ return \u0026#34;size:\u0026#34;+size+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,dataType:\u0026#34;+getTypeStr()+\u0026#34;,data:\u0026#34;+getDataStr(); } } 以上代码来自于书的原作者的博客：https://blog.csdn.net/jiangwei0910410003/article/details/50628894\n博客里还有如何解析操作，留看。\n总结 这两章讲的还是挺详细的，可以留着备用查阅，这两个文件都能加以混淆来保护应用，所以还是挺重要的。\n","date":"2018-08-29T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/","title":"Android应用安全防护和逆向分析-基础篇5-6"},{"content":"Android应用安全防护和逆向分析-基础篇1 第一章 Android中锁屏密码加密算法分析 1. 锁屏密码方式： 手势\n九宫格连线\n输入密码\n指纹、人脸、虹膜\n可穿戴设备\n2. 这儿分析手势密码和输入密码 找到android源代码中的LockPatternUtils,java 这个工具类\n路径：Android-5.1.1\\frameworks\\base\\core\\java\\com\\android\\internal\\widget\n2.1 输入密码算法分析 (5.1版本的源代码 和书上细微差异)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public byte[] passwordToHash(String password, int userId) {//参数为密码和对应用户ID 默认0 if (password == null) { return null; } try { byte[] saltedPassword = (password + getSalt(userId)).getBytes(); byte[] sha1 = MessageDigest.getInstance(\u0026#34;SHA-1\u0026#34;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;).digest(saltedPassword); //首先让 password+salt值 再SHA-1和MD5 byte[] combined = new byte[sha1.length + md5.length]; System.arraycopy(sha1, 0, combined, 0, sha1.length); System.arraycopy(md5, 0, combined, sha1.length, md5.length); //装换成hex值 再拼接起来 final char[] hexEncoded = HexEncoding.encode(combined); return new String(hexEncoded).getBytes(StandardCharsets.UTF_8); } catch (NoSuchAlgorithmException e) { throw new AssertionError(\u0026#34;Missing digest algorithm: \u0026#34;, e); } } 如何获取设备对应的salt值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 private String getSalt(int userId) { long salt = getLong(LOCK_PASSWORD_SALT_KEY, 0, userId); if (salt == 0) { //值为0 重新生成 try { salt = SecureRandom.getInstance(\u0026#34;SHA1PRNG\u0026#34;).nextLong(); setLong(LOCK_PASSWORD_SALT_KEY, salt, userId); //保存值 Log.v(TAG, \u0026#34;Initialized lock password salt for user: \u0026#34; + userId); } catch (NoSuchAlgorithmException e) { throw new IllegalStateException(\u0026#34;Couldn\u0026#39;t get SecureRandom number\u0026#34;, e); } } return Long.toHexString(salt); // hex之后返回 } 继续跟踪 看保存的地方\n1 2 3 4 5 6 7 private long getLong(String secureSettingKey, long defaultValue, int userHandle) { try { return getLockSettings().getLong(secureSettingKey, defaultValue, userHandle); } catch (RemoteException re) { return defaultValue; } } 继续跟踪代码\n1 2 3 4 5 6 7 8 9 @VisibleForTesting public ILockSettings getLockSettings() { if (mLockSettingsService == null) { ILockSettings service = ILockSettings.Stub.asInterface( ServiceManager.getService(\u0026#34;lock_settings\u0026#34;)); //获取服务来操作 mLockSettingsService = service; } return mLockSettingsService; } 在android中 这种获取服务的方式最终实现逻辑都是在XXXService类中\n这里在LockSettingService.java中 找到这个类的getLong方法\n1 2 3 4 5 public long getLong(String key, long defaultValue, int userId) { checkReadPermission(key, userId); String value = getStringUnchecked(key, null, userId); return TextUtils.isEmpty(value) ? defaultValue : Long.parseLong(value); } 保存在数据库？\n继续跟踪\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 static class Injector { protected Context mContext; public Injector(Context context) { mContext = context; } public Context getContext() { return mContext; } public Handler getHandler() { return new Handler(); } public LockSettingsStorage getStorage() { final LockSettingsStorage storage = new LockSettingsStorage(mContext); storage.setDatabaseOnCreateCallback(new LockSettingsStorage.Callback() { @Override public void initialize(SQLiteDatabase db) { // Get the lockscreen default from a system property, if available boolean lockScreenDisable = SystemProperties.getBoolean( \u0026#34;ro.lockscreen.disable.default\u0026#34;, false); if (lockScreenDisable) { storage.writeKeyValue(db, LockPatternUtils.DISABLE_LOCKSCREEN_KEY, \u0026#34;1\u0026#34;, 0); } } }); return storage; } public LockSettingsService(Context context) { this(new Injector(context)); } 继续 查看LockSettingsStorage.java 类中 存在数据库中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 static class DatabaseHelper extends SQLiteOpenHelper { private static final String TAG = \u0026#34;LockSettingsDB\u0026#34;; private static final String DATABASE_NAME = \u0026#34;locksettings.db\u0026#34;; private static final int DATABASE_VERSION = 2; private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000; private Callback mCallback; public DatabaseHelper(Context context) { super(context, DATABASE_NAME, null, DATABASE_VERSION); setWriteAheadLoggingEnabled(true); // Memory optimization - close idle connections after 30s of inactivity setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS); } public void setCallback(Callback callback) { mCallback = callback; } private void createTable(SQLiteDatabase db) { db.execSQL(\u0026#34;CREATE TABLE \u0026#34; + TABLE + \u0026#34; (\u0026#34; + \u0026#34;_id INTEGER PRIMARY KEY AUTOINCREMENT,\u0026#34; + COLUMN_KEY + \u0026#34; TEXT,\u0026#34; + COLUMN_USERID + \u0026#34; INTEGER,\u0026#34; + COLUMN_VALUE + \u0026#34; TEXT\u0026#34; + \u0026#34;);\u0026#34;); } @Override public void onCreate(SQLiteDatabase db) { createTable(db); if (mCallback != null) { mCallback.initialize(db); } } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) { int upgradeVersion = oldVersion; if (upgradeVersion == 1) { // Previously migrated lock screen widget settings. Now defunct. upgradeVersion = 2; } if (upgradeVersion != DATABASE_VERSION) { Log.w(TAG, \u0026#34;Failed to upgrade database!\u0026#34;); } } } 看到了数据库的名字叫作：locksettings.db 保存在了：\n1 2 3 4 5 6 7 8 private static final String SYSTEM_DIRECTORY = \u0026#34;/system/\u0026#34;; //目录 private static final String LOCK_PATTERN_FILE = \u0026#34;gatekeeper.pattern.key\u0026#34;; private static final String BASE_ZERO_LOCK_PATTERN_FILE = \u0026#34;gatekeeper.gesture.key\u0026#34;; private static final String LEGACY_LOCK_PATTERN_FILE = \u0026#34;gesture.key\u0026#34;; //key1 private static final String LOCK_PASSWORD_FILE = \u0026#34;gatekeeper.password.key\u0026#34;; private static final String LEGACY_LOCK_PASSWORD_FILE = \u0026#34;password.key\u0026#34;; //key2 private static final String CHILD_PROFILE_LOCK_FILE = \u0026#34;gatekeeper.profile.key\u0026#34;; private static final String SYNTHETIC_PASSWORD_DIRECTORY = \u0026#34;spblob/\u0026#34;; 数据库文件存在/data/system/locksetting.db\n测试 在/data/system/下看到password.key\n打开看看：\n手动简单实现加密算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public byte[] passwordToHash(String password) { if (password == null) { return null; } byte [] hashed = null; try { byte[] saltedPassword = (password + SALT).getBytes(); //SALT 值从数据库中得到 拿到之后进行hex转换 byte[] sha1 = MessageDigest.getInstance(\u0026#34;SHA-1\u0026#34;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;).digest(saltedPassword); hashed = (toHex(sha1)+toHex(md5)).getBytes(); } catch(Exception e){ } return hashed; } private static String toHex(byte[] ary){ final String hex = \u0026#34;102031398sjdfklaj\u0026#34;; String ret = \u0026#34;\u0026#34;; for(int i=0;i\u0026lt;ary.length;i++){ ret += hex.charAt((ary[i]\u0026gt;\u0026gt; 4)\u0026amp; 0xf); ret += hex.charAt(ary[i]\u0026amp; 0xf); } return ret; } SALT 的值可以从数据库中拿到 也可以利用反射获取\n总结：\n​ MD5(输的明文密码+设备的salt).hex+ SHA1(输的的明文密码+设备的salt值).hex\n2.2 手势密码分析\n大致同上\n3. 简要： ​ 九宫格团装化成字节数组-\u0026gt;sha1 加密 即可\n其实大致流程和分析输入密码差不多 保存到本地的目录/data/system/gesture.key 文件\n","date":"2018-07-02T17:33:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%871/","title":"Android应用安全防护和逆向分析-基础篇1"},{"content":"EnvRecord 用来不时记录平时所用环境配置，以及遇到的各种问题以及解决办法。主要是为了防丢失，以及总是和空气斗志斗勇。\nWin10 日常使用\nWSL 默认不是root 设置默认root用户。ubuntu config --default-user root\non my zsh 装上\n官方github\n需要先安装ZSH。\n安装on my zsh:\nvia curl：sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026quot;\nvia wget: sh -c \u0026quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\u0026quot;\n然后配置喜欢的 插件+主题。vi ~/.zshrc 修改plugins属性\n必备插件git、autojump、zsh-autosuggestions。主题 经常使用ys\nGDB装上+pwndbg+peda+gef\nwsl的ubuntu不支持x86，所以主要只能调试x64的程序，而且可能会出现莫名其妙的错误。\n不过可以使用qemu来运行x86的程序，调试还是不行会出错。参考\n1 2 3 4 5 sudo apt update sudo apt install qemu-user-static sudo update-binfmts --install i386 /usr/bin/qemu-i386-static --magic \u0026#39;\\x7fELF\\x01\\x01\\x01\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x03\\x00\\x01\\x00\\x00\\x00\u0026#39; --mask \u0026#39;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\xff\\xff\\xff\\xff\\xff\\xff\\xff\u0026#39; # 运行下面的一条命令就行跑x86 不过每次打开wsl都得运行一次，很麻烦，可以写脚本自动开启。 sudo service binfmt-support start pwndbg+peda+gef\n三个都可能用到，三个工具特性不一样。各有强项，所以三个都装，使用脚本gdb.sh启动选项\n安装pwndbg:\n1 2 3 git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh peda:\n1 2 git clone https://github.com/longld/peda.git ~/peda echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit gef:\n1 2 3 4 5 6 # via the install script $ wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh # manually $ wget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.py $ echo source ~/.gdbinit-gef.py \u0026gt;\u0026gt; ~/.gdbinit gdb.sh 把该文件放在/usr/local/sbin 参考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #!/bin/bash function Mode_change { name=$1 gdbinitfile=~/.gdbinit#这个路径按照你的实际情况修改# gdbinitfile=/root/Desktop/mode#路径按照你的实际情况修改 peda=\u0026#34;source ~/peda/peda.py\u0026#34; gef=\u0026#34;source ~/.gdbinit-gef.py\u0026#34; pwndbg=\u0026#34;source /home/pwndbg/gdbinit.py\u0026#34; sign=$(cat $gdbinitfile | grep -n \u0026#34;#this place is controled by user\u0026#39;s shell\u0026#34;) #此处上面的查找内容要和你自己的保持一致 pattern=\u0026#34;:#this place is controled by user\u0026#39;s shell\u0026#34; number=${sign%$pattern} location=$[number+2] parameter_add=${location}i parameter_del=${location}d message=\u0026#34;TEST\u0026#34; if [ $name -eq \u0026#34;1\u0026#34; ];then sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $peda\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the peda!\\n\u0026#34; elif [ $name -eq \u0026#34;2\u0026#34; ];then sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $gef\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the gef!\\n\u0026#34; else sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $pwndbg\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the pwndbg!\\n\u0026#34; fi } echo -e \u0026#34;Please choose one mode of GDB?\\n1.peda 2.gef 3.pwndbg\u0026#34; read -p \u0026#34;Input your choice:\u0026#34; num if [ $num -eq \u0026#34;1\u0026#34; ];then Mode_change $num elif [ $num -eq \u0026#34;2\u0026#34; ];then Mode_change $num elif [ $num -eq \u0026#34;3\u0026#34; ];then Mode_change $num else echo -e \u0026#34;Error!\\nPleasse input right number!\u0026#34; fi gdb $1 $2 $3 $4 $5 $6 $7 $8 $9# r2全家桶 （逆向调试神器）\n1 2 3 git clone https://github.com/radare/radare2.git cd radare2 sys/install.sh#Install / Update gcc arm aarch aarch64\nsudo apt install gcc-arm-linux-gnueabi 使用命令arm-linux-gnueabi-gcc\nsudo apt install gcc-aarch64-linux-gnu 使用命令aarch64-linux-gnu-gcc\nclang+llvm\n方法一，手动编译安装，费时费力\n方法二 apt\n完整方法这个地址\n只写ubuntu 18,04\n编辑 /etc/apt/sources.list，添加源 1 2 3 4 5 6 7 8 9 # i386 not available deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic main # 7 deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-7 main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-7 main # 8 deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-8 main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-8 main 添加证书 1 2 wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add - # Fingerprint: 6084 F3CF 814B 57C1 CF12 EFD5 15CF 4D18 AF4F 7421 安装 版本8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # LLVM apt-get install libllvm-8-ocaml-dev libllvm8 llvm-8 llvm-8-dev llvm-8-doc llvm-8-examples llvm-8-runtime # Clang and co apt-get install clang-8 clang-tools-8 clang-8-doc libclang-common-8-dev libclang-8-dev libclang1-8 clang-format-8 python-clang-8 # libfuzzer apt-get install libfuzzer-8-dev # lldb apt-get install lldb-8 # lld (linker) apt-get install lld-8 # libc++ apt-get install libc++-8-dev libc++abi-8-dev # OpenMP apt-get install libomp-8-dev python3+pip\napt install python3 python3-pip、python-pip\npython库\nfrida （hook) 同win下使用\npwntools (py2)\ngmpy2 (py2-3)\nr2Frida\nBrida\nvscode （666） 主要是各种插件\nzh-ch （汉化包）\nbackground （右下角小萌人）\ncmder** (Win下强大的终端工具)** 官网下载安装\n简单配置：\nwsl vim 无法使用上下左右键解决\npy2-py3 官网找想要的包下载，同时装两个版本。\n修改环境变量，日常使用py3,把py3的环境变量放在前面，去py2的安装目录复制一份python.exe 更名为python2.exe，就可以使用python2作为命令输入。\npip配置为国内源会快很多\nJava8+jdk最新 官网下载安装\n下个jdk最新版防止部分工具需要。\n可能有时候还需要配置环境变量JAVA_HOME为JDK路径。\nGolang 也是只需下载安装就ok.\nNodeJS 也是只需下载安装就ok. 推荐稳定版。\n会默认安装npm，然而下载速度实在太慢，使用淘宝镜像cnpm ,用法相同\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\ngit 官网下载安装完事\nYarn 官网下载安装完事\nCMake 下载安装ok\nhugo (博客工具) 下载exe到本地，配置环境变量\nHaskell Stack 官方文档、win直接下载安装\nStartlsBack (win下的美化工具) 下载安装 配置底部透明和居中\nNotepad++ (轻便的编辑器) 下载安装\nAndroid SDK 配置 adb工具 在目录platform-tools\nemulator、monitor 在tools下\nNDK-build 在ndk-bundle\nflutter (Google 跨平台框架) 有官网了\n下载SDK-\u0026gt;配置环境变量 flutter\\bin 。添加名为”PUB_HOSTED_URL”和”FLUTTER_STORAGE_BASE_URL”的条目。\nAndorid Studio设置\n安装插件\nFlutter插件： 支持Flutter开发工作流 (运行、调试、热重载等).\nDart插件： 提供代码分析 (输入代码时进行验证、代码补全等).\nVScode设置\n安装插件\nflutter Genymotion+逍遥Android (Android 模拟器) 下载安装ok\nCUDA （N卡xxx) 根据自己的显卡官网下载包\n根据需求安装。\n有个坑，如果为pytorch 或TensorFlow做前提 先看看这两支持的版本再安装相应的版本。\npytorch 需求前置环境也得装好 官方有很方便的安装方法 根据不同平台和环境\nTensorFlow 前置环境查官网 1 2 3 4 5 # GPU版本 py3 pip3 install tensorflow-gpu# stable pip3 install tf-nightly-gpu# preview pip3 install tensorflow-gpu==2.0.0-alpha0##TensorFlow 2.0 Alpha# CPU 版本 pip3 install --user --upgrade tensorflow tensorflow - 仅支持 CPU 的最新稳定版（建议新手使用）\ntensorflow-gpu - 支持 GPU 的最新稳定版（适用于 Ubuntu 和 Windows）\ntf-nightly - 仅支持 CPU 的预览每夜版（不稳定）\ntf-nightly-gpu - 支持 GPU 的预览每夜版（不稳定，适用于 Ubuntu 和 Windows）\ntensorflow==2.0.0-alpha0 - 仅支持 CPU 的预览 TF 2.0 Alpha 版（不稳定）\ntensorflow-gpu==2.0.0-alpha0 - 支持 GPU 的预览 TF 2.0 Alpha 版（不稳定，Ubuntu 和 Windows）\nVMware pro （虚拟机） 装MacOS记录 VBox （虚拟机） 安装拓展包 Xshell、Xftp (free for Home/School) free 的要去官网下载 填写信息，邮箱打开链接下载。\nTeamViewer (远程连接) 各种IDE、集成环境 只记录 Visual Studio 2019\nPycharm\nIDEA\n微信web开发工具\nphpStudy\nAndroid Studio (风扇~~ ~~)\nOther 不做记录\nUbuntu 18.04 一般用来调代码。 大部分配置同上面WSL,只记录不做过多介绍\non my zsh gdb+pwndbg+peda+gef 美化 manjaro 很喜欢的Linux发行版。基于ArchLinux，软件多，好看又好用。\nMac m2 没法用 放弃 等等 ","date":"0001-01-01T00:00:00Z","permalink":"https://ykiko.top/p/envrecord/","title":"EnvRecord"}]