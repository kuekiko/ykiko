[{"content":"IDA_动态调试.so_基本步骤 IDA 动态调试.so 基本步骤 待补图 0x00 IDA快捷键 Shirt+F12 字符串窗口\nF5大法好 反汇编\nCtrl+S 查看so对应段的信息（非调试），快速定位so文件的内存地址（Debug）\nG 快速跳转到对应地址。s\n调试-F7单步进入调试、F8单步、F9运行\n0x01 方法一 获取运行Android_server。\nandroid_server文件放在IDA安装目录下的注意版本的不同。\n之后只需 push android_server /data/local/tmp/。\n之后adb shell，su ，cd /data/local/tmp/。\n可能还得chmod 755 android_server 才有权限运行。\n建立通信、attach进程。\nadb forward tcp:23946 tcp:23946命令。\n在IDA的Debugger选项中attach进程。\n加载so、找函数下断点\n双开IDA ，Ctrl+S找到so文件的基地址，另外一个IDA找到函数的相对地址。相加得到绝对地址。\n0x02 方法二 无法加载so文件需要在加载之前断点。反调试之类\nDebug方式启动app。需要应用可调试开启\nadb shell am start -D -n 包名/.MainActivity\n方法一的1，2两步 勾选选项。\njdb attach程序\njdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700\n开始调试 同上\n","date":"2018-08-31T00:00:00+08:00","permalink":"https://ykiko.top/p/ida_%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so_%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/","title":"IDA_动态调试.so_基本步骤"},{"content":"Android应用安全防护和逆向分析-基础篇1 第一章 Android中锁屏密码加密算法分析 1. 锁屏密码方式： 手势\n九宫格连线\n输入密码\n指纹、人脸、虹膜\n可穿戴设备\n2. 这儿分析手势密码和输入密码 找到android源代码中的LockPatternUtils,java 这个工具类\n路径：Android-5.1.1\\frameworks\\base\\core\\java\\com\\android\\internal\\widget\n2.1 输入密码算法分析 (5.1版本的源代码 和书上细微差异)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public byte[] passwordToHash(String password, int userId) {//参数为密码和对应用户ID 默认0 if (password == null) { return null; } try { byte[] saltedPassword = (password + getSalt(userId)).getBytes(); byte[] sha1 = MessageDigest.getInstance(\u0026#34;SHA-1\u0026#34;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;).digest(saltedPassword); //首先让 password+salt值 再SHA-1和MD5 byte[] combined = new byte[sha1.length + md5.length]; System.arraycopy(sha1, 0, combined, 0, sha1.length); System.arraycopy(md5, 0, combined, sha1.length, md5.length); //装换成hex值 再拼接起来 final char[] hexEncoded = HexEncoding.encode(combined); return new String(hexEncoded).getBytes(StandardCharsets.UTF_8); } catch (NoSuchAlgorithmException e) { throw new AssertionError(\u0026#34;Missing digest algorithm: \u0026#34;, e); } } 如何获取设备对应的salt值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 private String getSalt(int userId) { long salt = getLong(LOCK_PASSWORD_SALT_KEY, 0, userId); if (salt == 0) { //值为0 重新生成 try { salt = SecureRandom.getInstance(\u0026#34;SHA1PRNG\u0026#34;).nextLong(); setLong(LOCK_PASSWORD_SALT_KEY, salt, userId); //保存值 Log.v(TAG, \u0026#34;Initialized lock password salt for user: \u0026#34; + userId); } catch (NoSuchAlgorithmException e) { throw new IllegalStateException(\u0026#34;Couldn\u0026#39;t get SecureRandom number\u0026#34;, e); } } return Long.toHexString(salt); // hex之后返回 } 继续跟踪 看保存的地方\n1 2 3 4 5 6 7 private long getLong(String secureSettingKey, long defaultValue, int userHandle) { try { return getLockSettings().getLong(secureSettingKey, defaultValue, userHandle); } catch (RemoteException re) { return defaultValue; } } 继续跟踪代码\n1 2 3 4 5 6 7 8 9 @VisibleForTesting public ILockSettings getLockSettings() { if (mLockSettingsService == null) { ILockSettings service = ILockSettings.Stub.asInterface( ServiceManager.getService(\u0026#34;lock_settings\u0026#34;)); //获取服务来操作 mLockSettingsService = service; } return mLockSettingsService; } 在android中 这种获取服务的方式最终实现逻辑都是在XXXService类中\n这里在LockSettingService.java中 找到这个类的getLong方法\n1 2 3 4 5 public long getLong(String key, long defaultValue, int userId) { checkReadPermission(key, userId); String value = getStringUnchecked(key, null, userId); return TextUtils.isEmpty(value) ? defaultValue : Long.parseLong(value); } 保存在数据库？\n继续跟踪\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 static class Injector { protected Context mContext; public Injector(Context context) { mContext = context; } public Context getContext() { return mContext; } public Handler getHandler() { return new Handler(); } public LockSettingsStorage getStorage() { final LockSettingsStorage storage = new LockSettingsStorage(mContext); storage.setDatabaseOnCreateCallback(new LockSettingsStorage.Callback() { @Override public void initialize(SQLiteDatabase db) { // Get the lockscreen default from a system property, if available boolean lockScreenDisable = SystemProperties.getBoolean( \u0026#34;ro.lockscreen.disable.default\u0026#34;, false); if (lockScreenDisable) { storage.writeKeyValue(db, LockPatternUtils.DISABLE_LOCKSCREEN_KEY, \u0026#34;1\u0026#34;, 0); } } }); return storage; } public LockSettingsService(Context context) { this(new Injector(context)); } 继续 查看LockSettingsStorage.java 类中 存在数据库中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 static class DatabaseHelper extends SQLiteOpenHelper { private static final String TAG = \u0026#34;LockSettingsDB\u0026#34;; private static final String DATABASE_NAME = \u0026#34;locksettings.db\u0026#34;; private static final int DATABASE_VERSION = 2; private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000; private Callback mCallback; public DatabaseHelper(Context context) { super(context, DATABASE_NAME, null, DATABASE_VERSION); setWriteAheadLoggingEnabled(true); // Memory optimization - close idle connections after 30s of inactivity setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS); } public void setCallback(Callback callback) { mCallback = callback; } private void createTable(SQLiteDatabase db) { db.execSQL(\u0026#34;CREATE TABLE \u0026#34; + TABLE + \u0026#34; (\u0026#34; + \u0026#34;_id INTEGER PRIMARY KEY AUTOINCREMENT,\u0026#34; + COLUMN_KEY + \u0026#34; TEXT,\u0026#34; + COLUMN_USERID + \u0026#34; INTEGER,\u0026#34; + COLUMN_VALUE + \u0026#34; TEXT\u0026#34; + \u0026#34;);\u0026#34;); } @Override public void onCreate(SQLiteDatabase db) { createTable(db); if (mCallback != null) { mCallback.initialize(db); } } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) { int upgradeVersion = oldVersion; if (upgradeVersion == 1) { // Previously migrated lock screen widget settings. Now defunct. upgradeVersion = 2; } if (upgradeVersion != DATABASE_VERSION) { Log.w(TAG, \u0026#34;Failed to upgrade database!\u0026#34;); } } } 看到了数据库的名字叫作：locksettings.db 保存在了：\n1 2 3 4 5 6 7 8 private static final String SYSTEM_DIRECTORY = \u0026#34;/system/\u0026#34;; //目录 private static final String LOCK_PATTERN_FILE = \u0026#34;gatekeeper.pattern.key\u0026#34;; private static final String BASE_ZERO_LOCK_PATTERN_FILE = \u0026#34;gatekeeper.gesture.key\u0026#34;; private static final String LEGACY_LOCK_PATTERN_FILE = \u0026#34;gesture.key\u0026#34;; //key1 private static final String LOCK_PASSWORD_FILE = \u0026#34;gatekeeper.password.key\u0026#34;; private static final String LEGACY_LOCK_PASSWORD_FILE = \u0026#34;password.key\u0026#34;; //key2 private static final String CHILD_PROFILE_LOCK_FILE = \u0026#34;gatekeeper.profile.key\u0026#34;; private static final String SYNTHETIC_PASSWORD_DIRECTORY = \u0026#34;spblob/\u0026#34;; 数据库文件存在/data/system/locksetting.db\n测试 在/data/system/下看到password.key\n打开看看：\n手动简单实现加密算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public byte[] passwordToHash(String password) { if (password == null) { return null; } byte [] hashed = null; try { byte[] saltedPassword = (password + SALT).getBytes(); //SALT 值从数据库中得到 拿到之后进行hex转换 byte[] sha1 = MessageDigest.getInstance(\u0026#34;SHA-1\u0026#34;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;).digest(saltedPassword); hashed = (toHex(sha1)+toHex(md5)).getBytes(); } catch(Exception e){ } return hashed; } private static String toHex(byte[] ary){ final String hex = \u0026#34;102031398sjdfklaj\u0026#34;; String ret = \u0026#34;\u0026#34;; for(int i=0;i\u0026lt;ary.length;i++){ ret += hex.charAt((ary[i]\u0026gt;\u0026gt; 4)\u0026amp; 0xf); ret += hex.charAt(ary[i]\u0026amp; 0xf); } return ret; } SALT 的值可以从数据库中拿到 也可以利用反射获取\n总结：\n​ MD5(输的明文密码+设备的salt).hex+ SHA1(输的的明文密码+设备的salt值).hex\n2.2 手势密码分析\n大致同上\n3. 简要： ​ 九宫格团装化成字节数组-\u0026gt;sha1 加密 即可\n其实大致流程和分析输入密码差不多 保存到本地的目录/data/system/gesture.key 文件\n","date":"2018-07-02T17:33:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%871/","title":"Android应用安全防护和逆向分析-基础篇1"},{"content":"EnvRecord 用来不时记录平时所用环境配置，以及遇到的各种问题以及解决办法。主要是为了防丢失，以及总是和空气斗志斗勇。\nWin10 日常使用\nWSL 默认不是root 设置默认root用户。ubuntu config --default-user root\non my zsh 装上\n官方github\n需要先安装ZSH。\n安装on my zsh:\nvia curl：sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026quot;\nvia wget: sh -c \u0026quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\u0026quot;\n然后配置喜欢的 插件+主题。vi ~/.zshrc 修改plugins属性\n必备插件git、autojump、zsh-autosuggestions。主题 经常使用ys\nGDB装上+pwndbg+peda+gef\nwsl的ubuntu不支持x86，所以主要只能调试x64的程序，而且可能会出现莫名其妙的错误。\n不过可以使用qemu来运行x86的程序，调试还是不行会出错。参考\n1 2 3 4 5 sudo apt update sudo apt install qemu-user-static sudo update-binfmts --install i386 /usr/bin/qemu-i386-static --magic \u0026#39;\\x7fELF\\x01\\x01\\x01\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x03\\x00\\x01\\x00\\x00\\x00\u0026#39; --mask \u0026#39;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\xff\\xff\\xff\\xff\\xff\\xff\\xff\u0026#39; # 运行下面的一条命令就行跑x86 不过每次打开wsl都得运行一次，很麻烦，可以写脚本自动开启。 sudo service binfmt-support start pwndbg+peda+gef\n三个都可能用到，三个工具特性不一样。各有强项，所以三个都装，使用脚本gdb.sh启动选项\n安装pwndbg:\n1 2 3 git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh peda:\n1 2 git clone https://github.com/longld/peda.git ~/peda echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit gef:\n1 2 3 4 5 6 # via the install script $ wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh # manually $ wget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.py $ echo source ~/.gdbinit-gef.py \u0026gt;\u0026gt; ~/.gdbinit gdb.sh 把该文件放在/usr/local/sbin 参考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #!/bin/bash function Mode_change { name=$1 gdbinitfile=~/.gdbinit#这个路径按照你的实际情况修改# gdbinitfile=/root/Desktop/mode#路径按照你的实际情况修改 peda=\u0026#34;source ~/peda/peda.py\u0026#34; gef=\u0026#34;source ~/.gdbinit-gef.py\u0026#34; pwndbg=\u0026#34;source /home/pwndbg/gdbinit.py\u0026#34; sign=$(cat $gdbinitfile | grep -n \u0026#34;#this place is controled by user\u0026#39;s shell\u0026#34;) #此处上面的查找内容要和你自己的保持一致 pattern=\u0026#34;:#this place is controled by user\u0026#39;s shell\u0026#34; number=${sign%$pattern} location=$[number+2] parameter_add=${location}i parameter_del=${location}d message=\u0026#34;TEST\u0026#34; if [ $name -eq \u0026#34;1\u0026#34; ];then sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $peda\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the peda!\\n\u0026#34; elif [ $name -eq \u0026#34;2\u0026#34; ];then sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $gef\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the gef!\\n\u0026#34; else sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $pwndbg\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the pwndbg!\\n\u0026#34; fi } echo -e \u0026#34;Please choose one mode of GDB?\\n1.peda 2.gef 3.pwndbg\u0026#34; read -p \u0026#34;Input your choice:\u0026#34; num if [ $num -eq \u0026#34;1\u0026#34; ];then Mode_change $num elif [ $num -eq \u0026#34;2\u0026#34; ];then Mode_change $num elif [ $num -eq \u0026#34;3\u0026#34; ];then Mode_change $num else echo -e \u0026#34;Error!\\nPleasse input right number!\u0026#34; fi gdb $1 $2 $3 $4 $5 $6 $7 $8 $9# r2全家桶 （逆向调试神器）\n1 2 3 git clone https://github.com/radare/radare2.git cd radare2 sys/install.sh#Install / Update gcc arm aarch aarch64\nsudo apt install gcc-arm-linux-gnueabi 使用命令arm-linux-gnueabi-gcc\nsudo apt install gcc-aarch64-linux-gnu 使用命令aarch64-linux-gnu-gcc\nclang+llvm\n方法一，手动编译安装，费时费力\n方法二 apt\n完整方法这个地址\n只写ubuntu 18,04\n编辑 /etc/apt/sources.list，添加源 1 2 3 4 5 6 7 8 9 # i386 not available deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic main # 7 deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-7 main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-7 main # 8 deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-8 main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-8 main 添加证书 1 2 wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add - # Fingerprint: 6084 F3CF 814B 57C1 CF12 EFD5 15CF 4D18 AF4F 7421 安装 版本8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # LLVM apt-get install libllvm-8-ocaml-dev libllvm8 llvm-8 llvm-8-dev llvm-8-doc llvm-8-examples llvm-8-runtime # Clang and co apt-get install clang-8 clang-tools-8 clang-8-doc libclang-common-8-dev libclang-8-dev libclang1-8 clang-format-8 python-clang-8 # libfuzzer apt-get install libfuzzer-8-dev # lldb apt-get install lldb-8 # lld (linker) apt-get install lld-8 # libc++ apt-get install libc++-8-dev libc++abi-8-dev # OpenMP apt-get install libomp-8-dev python3+pip\napt install python3 python3-pip、python-pip\npython库\nfrida （hook) 同win下使用\npwntools (py2)\ngmpy2 (py2-3)\nr2Frida\nBrida\nvscode （666） 主要是各种插件\nzh-ch （汉化包）\nbackground （右下角小萌人）\ncmder** (Win下强大的终端工具)** 官网下载安装\n简单配置：\nwsl vim 无法使用上下左右键解决\npy2-py3 官网找想要的包下载，同时装两个版本。\n修改环境变量，日常使用py3,把py3的环境变量放在前面，去py2的安装目录复制一份python.exe 更名为python2.exe，就可以使用python2作为命令输入。\npip配置为国内源会快很多\nJava8+jdk最新 官网下载安装\n下个jdk最新版防止部分工具需要。\n可能有时候还需要配置环境变量JAVA_HOME为JDK路径。\nGolang 也是只需下载安装就ok.\nNodeJS 也是只需下载安装就ok. 推荐稳定版。\n会默认安装npm，然而下载速度实在太慢，使用淘宝镜像cnpm ,用法相同\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\ngit 官网下载安装完事\nYarn 官网下载安装完事\nCMake 下载安装ok\nhugo (博客工具) 下载exe到本地，配置环境变量\nHaskell Stack 官方文档、win直接下载安装\nStartlsBack (win下的美化工具) 下载安装 配置底部透明和居中\nNotepad++ (轻便的编辑器) 下载安装\nAndroid SDK 配置 adb工具 在目录platform-tools\nemulator、monitor 在tools下\nNDK-build 在ndk-bundle\nflutter (Google 跨平台框架) 有官网了\n下载SDK-\u0026gt;配置环境变量 flutter\\bin 。添加名为”PUB_HOSTED_URL”和”FLUTTER_STORAGE_BASE_URL”的条目。\nAndorid Studio设置\n安装插件\nFlutter插件： 支持Flutter开发工作流 (运行、调试、热重载等).\nDart插件： 提供代码分析 (输入代码时进行验证、代码补全等).\nVScode设置\n安装插件\nflutter Genymotion+逍遥Android (Android 模拟器) 下载安装ok\nCUDA （N卡xxx) 根据自己的显卡官网下载包\n根据需求安装。\n有个坑，如果为pytorch 或TensorFlow做前提 先看看这两支持的版本再安装相应的版本。\npytorch 需求前置环境也得装好 官方有很方便的安装方法 根据不同平台和环境\nTensorFlow 前置环境查官网 1 2 3 4 5 # GPU版本 py3 pip3 install tensorflow-gpu# stable pip3 install tf-nightly-gpu# preview pip3 install tensorflow-gpu==2.0.0-alpha0##TensorFlow 2.0 Alpha# CPU 版本 pip3 install --user --upgrade tensorflow tensorflow - 仅支持 CPU 的最新稳定版（建议新手使用）\ntensorflow-gpu - 支持 GPU 的最新稳定版（适用于 Ubuntu 和 Windows）\ntf-nightly - 仅支持 CPU 的预览每夜版（不稳定）\ntf-nightly-gpu - 支持 GPU 的预览每夜版（不稳定，适用于 Ubuntu 和 Windows）\ntensorflow==2.0.0-alpha0 - 仅支持 CPU 的预览 TF 2.0 Alpha 版（不稳定）\ntensorflow-gpu==2.0.0-alpha0 - 支持 GPU 的预览 TF 2.0 Alpha 版（不稳定，Ubuntu 和 Windows）\nVMware pro （虚拟机） 装MacOS记录 VBox （虚拟机） 安装拓展包 Xshell、Xftp (free for Home/School) free 的要去官网下载 填写信息，邮箱打开链接下载。\nTeamViewer (远程连接) 各种IDE、集成环境 只记录 Visual Studio 2019\nPycharm\nIDEA\n微信web开发工具\nphpStudy\nAndroid Studio (风扇~~ ~~)\nOther 不做记录\nUbuntu 18.04 一般用来调代码。 大部分配置同上面WSL,只记录不做过多介绍\non my zsh gdb+pwndbg+peda+gef 美化 manjaro 很喜欢的Linux发行版。基于ArchLinux，软件多，好看又好用。\nMac m2 没法用 放弃 等等 ","date":"0001-01-01T00:00:00Z","permalink":"https://ykiko.top/p/envrecord/","title":"EnvRecord"}]